{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Benav Labs FastAPI Boilerplate","text":"<p> A production-ready FastAPI boilerplate to speed up your development. </p> <p> </p>"},{"location":"#what-is-fastapi-boilerplate","title":"What is FastAPI Boilerplate?","text":"<p>FastAPI Boilerplate is a comprehensive, production-ready template that provides everything you need to build scalable, async APIs using modern Python technologies. It combines the power of FastAPI with industry best practices to give you a solid foundation for your next project.</p>"},{"location":"#core-technologies","title":"Core Technologies","text":"<p>This boilerplate leverages cutting-edge Python technologies:</p> <ul> <li>FastAPI - Modern, fast web framework for building APIs with Python 3.7+</li> <li>Pydantic V2 - Data validation library rewritten in Rust (5x-50x faster)</li> <li>SQLAlchemy 2.0 - Python SQL toolkit and Object Relational Mapper</li> <li>PostgreSQL - Advanced open source relational database</li> <li>Redis - In-memory data store for caching and message brokering</li> <li>ARQ - Job queues and RPC with asyncio and Redis</li> <li>Docker - Containerization for easy deployment</li> <li>NGINX - High-performance web server for reverse proxy and load balancing</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Fully async architecture</li> <li>Pydantic V2 for ultra-fast data validation</li> <li>SQLAlchemy 2.0 with efficient query patterns</li> <li>Built-in caching with Redis</li> <li>Horizontal scaling with NGINX load balancing</li> </ul>"},{"location":"#security-authentication","title":"Security &amp; Authentication","text":"<ul> <li>JWT-based authentication with refresh tokens</li> <li>Cookie-based secure token storage</li> <li>Role-based access control with user tiers</li> <li>Rate limiting to prevent abuse</li> <li>Production-ready security configurations</li> </ul>"},{"location":"#developer-experience","title":"Developer Experience","text":"<ul> <li>Comprehensive CRUD operations with FastCRUD</li> <li>Automatic API documentation</li> <li>Database migrations with Alembic</li> <li>Background task processing</li> <li>Extensive test coverage</li> <li>Docker Compose for easy development</li> </ul>"},{"location":"#production-ready","title":"Production Ready","text":"<ul> <li>Environment-based configuration</li> <li>Structured logging</li> <li>Health checks and monitoring</li> <li>NGINX reverse proxy setup</li> <li>Gunicorn with Uvicorn workers</li> <li>Database connection pooling</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get up and running in less than 5 minutes:</p> <pre><code># Clone the repository\ngit clone https://github.com/benavlabs/fastapi-boilerplate\ncd fastapi-boilerplate\n\n# Start with Docker Compose\ndocker compose up\n</code></pre> <p>That's it! Your API will be available at <code>http://localhost:8000/docs</code></p> <p>Continue with the Getting Started Guide \u2192</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#for-new-users","title":"For New Users","text":"<ul> <li>Getting Started - Quick setup and first steps</li> <li>User Guide - Comprehensive feature documentation</li> </ul>"},{"location":"#for-developers","title":"For Developers","text":"<ul> <li>Development - Extending and customizing the boilerplate</li> <li>Testing - Testing strategies and best practices</li> <li>Production - Production deployment guides</li> </ul>"},{"location":"#perfect-for","title":"Perfect For","text":"<ul> <li>REST APIs - Build robust, scalable REST APIs</li> <li>Microservices - Create microservice architectures</li> <li>Smll Applications - Multi-tenant applications with user tiers</li> <li>Data APIs - APIs for data processing and analytics</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub Issues - Bug reports and feature requests</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to the FastAPI Boilerplate! This guide will have you up and running with a production-ready API in just a few minutes.</p>"},{"location":"getting-started/#quick-start-5-minutes","title":"Quick Start (5 minutes)","text":"<p>The fastest way to get started is using Docker Compose. This will set up everything you need including PostgreSQL, Redis, and the API server.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have installed:</p> <ul> <li>Docker (20.10+)</li> <li>Docker Compose (1.29+)</li> </ul>"},{"location":"getting-started/#1-get-the-template","title":"1. Get the Template","text":"<p>Start by using this template for your new project:</p> <ol> <li>Click \"Use this template\" on the GitHub repository</li> <li>Create a new repository with your project name</li> <li>Clone your new repository:</li> </ol> <pre><code>git clone https://github.com/yourusername/your-project-name\ncd your-project-name\n</code></pre>"},{"location":"getting-started/#2-environment-setup","title":"2. Environment Setup","text":"<p>Create your environment configuration:</p> <pre><code># Create the environment file\ntouch src/.env\n</code></pre> <p>Add the following basic configuration to <code>src/.env</code>:</p> <pre><code># Application\nAPP_NAME=\"My FastAPI App\"\nAPP_DESCRIPTION=\"My awesome API\"\nAPP_VERSION=\"0.1.0\"\n\n# Database\nPOSTGRES_USER=\"postgres\"\nPOSTGRES_PASSWORD=\"changethis\"\nPOSTGRES_SERVER=\"db\"\nPOSTGRES_PORT=5432\nPOSTGRES_DB=\"myapp\"\n\n# Security\nSECRET_KEY=\"your-secret-key-here\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n\n# Redis\nREDIS_CACHE_HOST=\"redis\"\nREDIS_CACHE_PORT=6379\nREDIS_QUEUE_HOST=\"redis\"\nREDIS_QUEUE_PORT=6379\n\n# Admin User\nADMIN_NAME=\"Admin\"\nADMIN_EMAIL=\"admin@example.com\"\nADMIN_USERNAME=\"admin\"\nADMIN_PASSWORD=\"changethis\"\n\n# Environment\nENVIRONMENT=\"local\"\n</code></pre> <p>Security Note</p> <p>Generate a secure secret key using: <code>openssl rand -hex 32</code></p>"},{"location":"getting-started/#3-start-the-application","title":"3. Start the Application","text":"<p>Launch all services with a single command:</p> <pre><code>docker compose up\n</code></pre> <p>This will start: - FastAPI server on port 8000 - PostgreSQL database  - Redis for caching and job queues - Worker for background tasks</p>"},{"location":"getting-started/#4-verify-installation","title":"4. Verify Installation","text":"<p>Once the containers are running, you should see output like:</p> <pre><code>fastapi-boilerplate-web-1     | INFO:     Application startup complete.\nfastapi-boilerplate-db-1      | database system is ready to accept connections\nfastapi-boilerplate-worker-1  | redis_version=7.x.x mem_usage=1MB clients_connected=1\n</code></pre> <p>Visit these URLs to confirm everything is working:</p> <ul> <li>API Documentation: http://localhost:8000/docs</li> <li>Alternative Docs: http://localhost:8000/redoc</li> <li>Health Check: http://localhost:8000/api/v1/health</li> </ul>"},{"location":"getting-started/#youre-ready","title":"You're Ready!","text":"<p>Congratulations! You now have a fully functional FastAPI application with:</p> <ul> <li>REST API with automatic documentation</li> <li>PostgreSQL database with migrations</li> <li>Redis caching and job queues</li> <li>JWT authentication system</li> <li>Background task processing</li> <li>Rate limiting</li> <li>Admin user created</li> </ul>"},{"location":"getting-started/#test-your-api","title":"Test Your API","text":"<p>Try these quick tests to see your API in action:</p>"},{"location":"getting-started/#1-health-check","title":"1. Health Check","text":"<pre><code>curl http://localhost:8000/api/v1/health\n</code></pre>"},{"location":"getting-started/#2-create-a-user","title":"2. Create a User","text":"<pre><code>curl -X POST \"http://localhost:8000/api/v1/users\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"John Doe\",\n    \"username\": \"johndoe\",\n    \"email\": \"john@example.com\",\n    \"password\": \"securepassword\"\n  }'\n</code></pre>"},{"location":"getting-started/#3-login","title":"3. Login","text":"<pre><code>curl -X POST \"http://localhost:8000/api/v1/login\" \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=johndoe&amp;password=securepassword\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics running, explore these guides to learn more:</p>"},{"location":"getting-started/#essential-reading","title":"Essential Reading","text":"<ul> <li>Configuration Guide - Understand all configuration options</li> <li>Project Structure - Learn how the code is organized</li> <li>Authentication - Set up user management</li> </ul>"},{"location":"getting-started/#popular-features","title":"Popular Features","text":"<ul> <li>Database Operations - Working with models and CRUD</li> <li>Caching - Speed up your API with Redis caching</li> <li>Background Tasks - Process jobs asynchronously</li> <li>Rate Limiting - Protect your API from abuse</li> </ul>"},{"location":"getting-started/#development-deployment","title":"Development &amp; Deployment","text":"<ul> <li>Development Guide - Extend and customize the boilerplate</li> <li>Testing - Write tests for your API</li> <li>Production Deployment - Deploy to production</li> </ul>"},{"location":"getting-started/#alternative-setup-methods","title":"Alternative Setup Methods","text":"<p>Not using Docker? No problem!</p> <ul> <li>Manual Installation - Install dependencies manually</li> </ul>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<ul> <li>Report issues on GitHub</li> </ul> <p>Ready to dive deeper? Continue with the detailed installation guide or explore the user guide. </p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>This guide covers the essential configuration steps to get your FastAPI application running quickly.</p>"},{"location":"getting-started/configuration/#quick-setup","title":"Quick Setup","text":"<p>The fastest way to get started is to copy the example environment file and modify just a few values:</p> <pre><code>cp src/.env.example src/.env\n</code></pre>"},{"location":"getting-started/configuration/#essential-configuration","title":"Essential Configuration","text":"<p>Open <code>src/.env</code> and set these required values:</p>"},{"location":"getting-started/configuration/#application-settings","title":"Application Settings","text":"<pre><code># App Settings  \nAPP_NAME=\"Your app name here\"\nAPP_DESCRIPTION=\"Your app description here\"\nAPP_VERSION=\"0.1\"\nCONTACT_NAME=\"Your name\"\nCONTACT_EMAIL=\"Your email\"\nLICENSE_NAME=\"The license you picked\"\n</code></pre>"},{"location":"getting-started/configuration/#database-connection","title":"Database Connection","text":"<pre><code># Database\nPOSTGRES_USER=\"your_postgres_user\"\nPOSTGRES_PASSWORD=\"your_password\"\nPOSTGRES_SERVER=\"localhost\"  # Use \"db\" for Docker Compose\nPOSTGRES_PORT=5432           # Use 5432 for Docker Compose\nPOSTGRES_DB=\"your_database_name\"\n</code></pre>"},{"location":"getting-started/configuration/#pgadmin-optional","title":"PGAdmin (Optional)","text":"<p>For database administration:</p> <pre><code># PGAdmin\nPGADMIN_DEFAULT_EMAIL=\"your_email_address\"\nPGADMIN_DEFAULT_PASSWORD=\"your_password\"\nPGADMIN_LISTEN_PORT=80\n</code></pre> <p>To connect to database in PGAdmin: 1. Login with <code>PGADMIN_DEFAULT_EMAIL</code> and <code>PGADMIN_DEFAULT_PASSWORD</code> 2. Click \"Add Server\" 3. Use these connection settings:    - Hostname/address: <code>db</code> (if using containers) or <code>localhost</code>    - Port: Value from <code>POSTGRES_PORT</code>    - Database: <code>postgres</code> (leave as default)    - Username: Value from <code>POSTGRES_USER</code>    - Password: Value from <code>POSTGRES_PASSWORD</code></p>"},{"location":"getting-started/configuration/#security","title":"Security","text":"<p>Generate a secret key and set it:</p> <pre><code># Generate a secure secret key\nopenssl rand -hex 32\n</code></pre> <pre><code># Cryptography\nSECRET_KEY=\"your-generated-secret-key-here\"  # Result of openssl rand -hex 32\nALGORITHM=\"HS256\"                            # Default: HS256\nACCESS_TOKEN_EXPIRE_MINUTES=30               # Default: 30\nREFRESH_TOKEN_EXPIRE_DAYS=7                  # Default: 7\n</code></pre>"},{"location":"getting-started/configuration/#first-admin-user","title":"First Admin User","text":"<pre><code># Admin User\nADMIN_NAME=\"your_name\"\nADMIN_EMAIL=\"your_email\"\nADMIN_USERNAME=\"your_username\"\nADMIN_PASSWORD=\"your_password\"\n</code></pre>"},{"location":"getting-started/configuration/#redis-configuration","title":"Redis Configuration","text":"<pre><code># Redis Cache\nREDIS_CACHE_HOST=\"localhost\"     # Use \"redis\" for Docker Compose\nREDIS_CACHE_PORT=6379\n\n# Client-side Cache\nCLIENT_CACHE_MAX_AGE=30          # Default: 30 seconds\n\n# Redis Job Queue\nREDIS_QUEUE_HOST=\"localhost\"     # Use \"redis\" for Docker Compose  \nREDIS_QUEUE_PORT=6379\n\n# Redis Rate Limiting\nREDIS_RATE_LIMIT_HOST=\"localhost\"  # Use \"redis\" for Docker Compose\nREDIS_RATE_LIMIT_PORT=6379\n</code></pre> <p>Redis in Production</p> <p>You may use the same Redis instance for caching and queues while developing, but use separate containers in production.</p>"},{"location":"getting-started/configuration/#rate-limiting-defaults","title":"Rate Limiting Defaults","text":"<pre><code># Default Rate Limits\nDEFAULT_RATE_LIMIT_LIMIT=10      # Default: 10 requests\nDEFAULT_RATE_LIMIT_PERIOD=3600   # Default: 3600 seconds (1 hour)\n</code></pre>"},{"location":"getting-started/configuration/#first-tier","title":"First Tier","text":"<pre><code># Default Tier\nTIER_NAME=\"free\"\n</code></pre>"},{"location":"getting-started/configuration/#environment-types","title":"Environment Types","text":"<p>Set your environment type:</p> <pre><code>ENVIRONMENT=\"local\"  # local, staging, or production\n</code></pre> <ul> <li>local: API docs available at <code>/docs</code>, <code>/redoc</code>, and <code>/openapi.json</code></li> <li>staging: API docs available to superusers only</li> <li>production: API docs completely disabled</li> </ul>"},{"location":"getting-started/configuration/#docker-compose-settings","title":"Docker Compose Settings","text":"<p>If using Docker Compose, use these values instead:</p> <pre><code># Docker Compose values\nPOSTGRES_SERVER=\"db\"\nREDIS_CACHE_HOST=\"redis\"\nREDIS_QUEUE_HOST=\"redis\"\nREDIS_RATE_LIMIT_HOST=\"redis\"\n</code></pre>"},{"location":"getting-started/configuration/#optional-services","title":"Optional Services","text":"<p>The boilerplate includes Redis for caching, job queues, and rate limiting. If running locally without Docker, either:</p> <ol> <li>Install Redis and keep the default settings</li> <li>Disable Redis services (see User Guide - Configuration for details)</li> </ol>"},{"location":"getting-started/configuration/#thats-it","title":"That's It!","text":"<p>With these basic settings configured, you can start the application:</p> <ul> <li>Docker Compose: <code>docker compose up</code></li> <li>Manual: <code>uv run uvicorn src.app.main:app --reload</code></li> </ul> <p>For detailed configuration options, advanced settings, and production deployment, see the User Guide - Configuration. </p>"},{"location":"getting-started/first-run/","title":"First Run Guide","text":"<p>Congratulations on setting up the FastAPI Boilerplate! This guide will walk you through testing your installation, understanding the basics, and making your first customizations.</p>"},{"location":"getting-started/first-run/#verification-checklist","title":"Verification Checklist","text":"<p>Before diving deeper, let's verify everything is working correctly.</p>"},{"location":"getting-started/first-run/#1-check-all-services","title":"1. Check All Services","text":"<p>Ensure all services are running:</p> <pre><code># For Docker Compose users\ndocker compose ps\n\n# Expected output:\n# NAME                          COMMAND                  SERVICE   STATUS\n# fastapi-boilerplate-web-1     \"uvicorn app.main:app\u2026\"  web       running\n# fastapi-boilerplate-db-1      \"docker-entrypoint.s\u2026\"  db        running\n# fastapi-boilerplate-redis-1   \"docker-entrypoint.s\u2026\"  redis     running\n# fastapi-boilerplate-worker-1  \"arq src.app.core.wo\u2026\"  worker    running\n</code></pre>"},{"location":"getting-started/first-run/#2-test-api-endpoints","title":"2. Test API Endpoints","text":"<p>Visit these URLs to confirm your API is working:</p> <p>API Documentation: - Swagger UI: http://localhost:8000/docs - ReDoc: http://localhost:8000/redoc</p> <p>Health Check: <pre><code>curl http://localhost:8000/api/v1/health\n</code></pre></p> <p>Expected response: <pre><code>{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2024-01-01T12:00:00Z\"\n}\n</code></pre></p>"},{"location":"getting-started/first-run/#3-database-connection","title":"3. Database Connection","text":"<p>Check if the database tables were created:</p> <pre><code># For Docker Compose\ndocker compose exec db psql -U postgres -d myapp -c \"\\dt\"\n\n# You should see tables like:\n# public | users        | table | postgres\n# public | posts        | table | postgres\n# public | tiers        | table | postgres\n# public | rate_limits  | table | postgres\n</code></pre>"},{"location":"getting-started/first-run/#4-redis-connection","title":"4. Redis Connection","text":"<p>Test Redis connectivity:</p> <pre><code># For Docker Compose\ndocker compose exec redis redis-cli ping\n\n# Expected response: PONG\n</code></pre>"},{"location":"getting-started/first-run/#initial-setup","title":"Initial Setup","text":"<p>Before testing features, you need to create the first superuser and tier.</p>"},{"location":"getting-started/first-run/#creating-the-first-superuser","title":"Creating the First Superuser","text":"<p>Prerequisites</p> <p>Make sure the database and tables are created before running create_superuser. The database should be running and the API should have started at least once.</p>"},{"location":"getting-started/first-run/#using-docker-compose","title":"Using Docker Compose","text":"<p>If using Docker Compose, uncomment this section in your <code>docker-compose.yml</code>:</p> <pre><code>#-------- uncomment to create first superuser --------\ncreate_superuser:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  env_file:\n    - ./src/.env\n  depends_on:\n    - db\n  command: python -m src.scripts.create_first_superuser\n  volumes:\n    - ./src:/code/src\n</code></pre> <p>Then run:</p> <pre><code># Start services and run create_superuser automatically\ndocker compose up -d\n\n# Or run it manually\ndocker compose run --rm create_superuser\n\n# Stop the create_superuser service when done\ndocker compose stop create_superuser\n</code></pre>"},{"location":"getting-started/first-run/#from-scratch","title":"From Scratch","text":"<p>If running manually, use:</p> <pre><code># Make sure you're in the root folder\nuv run python -m src.scripts.create_first_superuser\n</code></pre>"},{"location":"getting-started/first-run/#creating-the-first-tier","title":"Creating the First Tier","text":"<p>Prerequisites</p> <p>Make sure the database and tables are created before running create_tier.</p>"},{"location":"getting-started/first-run/#using-docker-compose_1","title":"Using Docker Compose","text":"<p>Uncomment the <code>create_tier</code> service in <code>docker-compose.yml</code> and run:</p> <pre><code>docker compose run --rm create_tier\n</code></pre>"},{"location":"getting-started/first-run/#from-scratch_1","title":"From Scratch","text":"<pre><code># Make sure you're in the root folder\nuv run python -m src.scripts.create_first_tier\n</code></pre>"},{"location":"getting-started/first-run/#testing-core-features","title":"Testing Core Features","text":"<p>Let's test the main features of your API.</p>"},{"location":"getting-started/first-run/#authentication-flow","title":"Authentication Flow","text":""},{"location":"getting-started/first-run/#1-login-with-admin-user","title":"1. Login with Admin User","text":"<p>Use the admin credentials you set in your <code>.env</code> file:</p> <pre><code>curl -X POST \"http://localhost:8000/api/v1/login\" \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=admin&amp;password=your_admin_password\"\n</code></pre> <p>You should receive a response like: <pre><code>{\n  \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\",\n  \"token_type\": \"bearer\",\n  \"refresh_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...\"\n}\n</code></pre></p>"},{"location":"getting-started/first-run/#2-create-a-new-user","title":"2. Create a New User","text":"<pre><code>curl -X POST \"http://localhost:8000/api/v1/users\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"John Doe\",\n    \"username\": \"johndoe\", \n    \"email\": \"john@example.com\",\n    \"password\": \"securepassword123\"\n  }'\n</code></pre>"},{"location":"getting-started/first-run/#3-test-protected-endpoint","title":"3. Test Protected Endpoint","text":"<p>Use the access token from step 1:</p> <pre><code>curl -X GET \"http://localhost:8000/api/v1/users/me\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n</code></pre>"},{"location":"getting-started/first-run/#crud-operations","title":"CRUD Operations","text":""},{"location":"getting-started/first-run/#1-create-a-post","title":"1. Create a Post","text":"<pre><code>curl -X POST \"http://localhost:8000/api/v1/posts\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\" \\\n  -d '{\n    \"title\": \"My First Post\",\n    \"content\": \"This is the content of my first post!\"\n  }'\n</code></pre>"},{"location":"getting-started/first-run/#2-get-all-posts","title":"2. Get All Posts","text":"<pre><code>curl -X GET \"http://localhost:8000/api/v1/posts\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n</code></pre>"},{"location":"getting-started/first-run/#3-get-posts-with-pagination","title":"3. Get Posts with Pagination","text":"<pre><code>curl -X GET \"http://localhost:8000/api/v1/posts?page=1&amp;items_per_page=5\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n</code></pre>"},{"location":"getting-started/first-run/#background-tasks","title":"Background Tasks","text":"<p>Test the job queue system:</p>"},{"location":"getting-started/first-run/#1-submit-a-background-task","title":"1. Submit a Background Task","text":"<pre><code>curl -X POST \"http://localhost:8000/api/v1/tasks/task?message=hello\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n</code></pre> <p>Response: <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n</code></pre></p>"},{"location":"getting-started/first-run/#2-check-task-status","title":"2. Check Task Status","text":"<pre><code>curl -X GET \"http://localhost:8000/api/v1/tasks/task/550e8400-e29b-41d4-a716-446655440000\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n</code></pre>"},{"location":"getting-started/first-run/#caching","title":"Caching","text":"<p>Test the caching system:</p>"},{"location":"getting-started/first-run/#1-make-a-cached-request","title":"1. Make a Cached Request","text":"<pre><code># First request (cache miss)\ncurl -X GET \"http://localhost:8000/api/v1/users/johndoe\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\" \\\n  -w \"Time: %{time_total}s\\n\"\n\n# Second request (cache hit - should be faster)\ncurl -X GET \"http://localhost:8000/api/v1/users/johndoe\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\" \\\n  -w \"Time: %{time_total}s\\n\"\n</code></pre>"},{"location":"getting-started/first-run/#your-first-customization","title":"Your First Customization","text":"<p>Let's create a simple custom endpoint to see how easy it is to extend the boilerplate.</p>"},{"location":"getting-started/first-run/#1-create-a-simple-model","title":"1. Create a Simple Model","text":"<p>Create <code>src/app/models/item.py</code>:</p> <pre><code>from sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom app.core.db.database import Base\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n\n    id: Mapped[int] = mapped_column(\"id\", autoincrement=True, nullable=False, unique=True, primary_key=True, init=False)\n    name: Mapped[str] = mapped_column(String(100))\n    description: Mapped[str] = mapped_column(String(500), default=\"\")\n</code></pre>"},{"location":"getting-started/first-run/#2-create-pydantic-schemas","title":"2. Create Pydantic Schemas","text":"<p>Create <code>src/app/schemas/item.py</code>:</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass ItemBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(\"\", max_length=500)\n\n\nclass ItemCreate(ItemBase):\n    pass\n\n\nclass ItemCreateInternal(ItemCreate):\n    pass\n\n\nclass ItemRead(ItemBase):\n    id: int\n\n\nclass ItemUpdate(BaseModel):\n    name: str | None = None\n    description: str | None = None\n\n\nclass ItemUpdateInternal(ItemUpdate):\n    pass\n\n\nclass ItemDelete(BaseModel):\n    is_deleted: bool = True\n</code></pre>"},{"location":"getting-started/first-run/#3-create-crud-operations","title":"3. Create CRUD Operations","text":"<p>Create <code>src/app/crud/crud_items.py</code>:</p> <pre><code>from fastcrud import FastCRUD\n\nfrom app.models.item import Item\nfrom app.schemas.item import ItemCreateInternal, ItemUpdate, ItemUpdateInternal, ItemDelete\n\nCRUDItem = FastCRUD[Item, ItemCreateInternal, ItemUpdate, ItemUpdateInternal, ItemDelete]\ncrud_items = CRUDItem(Item)\n</code></pre>"},{"location":"getting-started/first-run/#4-create-api-endpoints","title":"4. Create API Endpoints","text":"<p>Create <code>src/app/api/v1/items.py</code>:</p> <pre><code>from typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.api.dependencies import get_current_user\nfrom app.core.db.database import async_get_db\nfrom app.crud.crud_items import crud_items\nfrom app.schemas.item import ItemCreate, ItemRead, ItemUpdate\nfrom app.schemas.user import UserRead\n\nrouter = APIRouter(tags=[\"items\"])\n\n\n@router.post(\"/\", response_model=ItemRead, status_code=201)\nasync def create_item(\n    item: ItemCreate,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    current_user: Annotated[UserRead, Depends(get_current_user)]\n):\n    \"\"\"Create a new item.\"\"\"\n    db_item = await crud_items.create(db=db, object=item)\n    return db_item\n\n\n@router.get(\"/{item_id}\", response_model=ItemRead)\nasync def get_item(\n    item_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    \"\"\"Get an item by ID.\"\"\"\n    db_item = await crud_items.get(db=db, id=item_id)\n    if not db_item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return db_item\n\n\n@router.get(\"/\", response_model=list[ItemRead])\nasync def get_items(\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    skip: int = 0,\n    limit: int = 100\n):\n    \"\"\"Get all items.\"\"\"\n    items = await crud_items.get_multi(db=db, offset=skip, limit=limit)\n    return items[\"data\"]\n\n\n@router.patch(\"/{item_id}\", response_model=ItemRead)\nasync def update_item(\n    item_id: int,\n    item_update: ItemUpdate,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    current_user: Annotated[UserRead, Depends(get_current_user)]\n):\n    \"\"\"Update an item.\"\"\"\n    db_item = await crud_items.get(db=db, id=item_id)\n    if not db_item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n\n    updated_item = await crud_items.update(db=db, object=item_update, id=item_id)\n    return updated_item\n\n\n@router.delete(\"/{item_id}\")\nasync def delete_item(\n    item_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    current_user: Annotated[UserRead, Depends(get_current_user)]\n):\n    \"\"\"Delete an item.\"\"\"\n    db_item = await crud_items.get(db=db, id=item_id)\n    if not db_item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n\n    await crud_items.delete(db=db, id=item_id)\n    return {\"message\": \"Item deleted successfully\"}\n</code></pre>"},{"location":"getting-started/first-run/#5-register-the-router","title":"5. Register the Router","text":"<p>Add your new router to <code>src/app/api/v1/__init__.py</code>:</p> <pre><code>from fastapi import APIRouter\n\nfrom app.api.v1.login import router as login_router\nfrom app.api.v1.logout import router as logout_router\nfrom app.api.v1.posts import router as posts_router\nfrom app.api.v1.rate_limits import router as rate_limits_router\nfrom app.api.v1.tasks import router as tasks_router\nfrom app.api.v1.tiers import router as tiers_router\nfrom app.api.v1.users import router as users_router\nfrom app.api.v1.items import router as items_router  # Add this line\n\nrouter = APIRouter(prefix=\"/v1\")\nrouter.include_router(login_router, prefix=\"/login\")\nrouter.include_router(logout_router, prefix=\"/logout\") \nrouter.include_router(users_router, prefix=\"/users\")\nrouter.include_router(posts_router, prefix=\"/posts\")\nrouter.include_router(tasks_router, prefix=\"/tasks\")\nrouter.include_router(tiers_router, prefix=\"/tiers\")\nrouter.include_router(rate_limits_router, prefix=\"/rate_limits\")\nrouter.include_router(items_router, prefix=\"/items\")  # Add this line\n</code></pre>"},{"location":"getting-started/first-run/#6-create-and-run-migration","title":"6. Create and Run Migration","text":"<p>Import your new model in <code>src/app/models/__init__.py</code>:</p> <pre><code>from .user import User\nfrom .post import Post\nfrom .tier import Tier\nfrom .rate_limit import RateLimit\nfrom .item import Item  # Add this line\n</code></pre> <p>Create and run the migration:</p> <pre><code># For Docker Compose\ndocker compose exec web alembic revision --autogenerate -m \"Add items table\"\ndocker compose exec web alembic upgrade head\n\n# For manual installation\ncd src\nuv run alembic revision --autogenerate -m \"Add items table\"\nuv run alembic upgrade head\n</code></pre>"},{"location":"getting-started/first-run/#7-test-your-new-endpoint","title":"7. Test Your New Endpoint","text":"<p>Restart your application and test the new endpoints:</p> <pre><code># Create an item\ncurl -X POST \"http://localhost:8000/api/v1/items/\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\" \\\n  -d '{\n    \"name\": \"My First Item\",\n    \"description\": \"This is a test item\"\n  }'\n\n# Get all items\ncurl -X GET \"http://localhost:8000/api/v1/items/\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n</code></pre>"},{"location":"getting-started/first-run/#debugging-common-issues","title":"Debugging Common Issues","text":""},{"location":"getting-started/first-run/#logs-and-monitoring","title":"Logs and Monitoring","text":""},{"location":"getting-started/first-run/#check-application-logs","title":"Check Application Logs","text":"<pre><code># For Docker Compose\ndocker compose logs web\n\n# For manual installation\ntail -f src/app/logs/app.log\n</code></pre>"},{"location":"getting-started/first-run/#check-database-logs","title":"Check Database Logs","text":"<pre><code># For Docker Compose\ndocker compose logs db\n</code></pre>"},{"location":"getting-started/first-run/#check-worker-logs","title":"Check Worker Logs","text":"<pre><code># For Docker Compose\ndocker compose logs worker\n</code></pre>"},{"location":"getting-started/first-run/#performance-testing","title":"Performance Testing","text":""},{"location":"getting-started/first-run/#test-api-response-times","title":"Test API Response Times","text":"<pre><code># Test endpoint performance\ncurl -w \"Time: %{time_total}s\\n\" \\\n  -H \"Authorization: Bearer YOUR_ACCESS_TOKEN_HERE\" \\\n  http://localhost:8000/api/v1/users/me\n</code></pre>"},{"location":"getting-started/first-run/#test-database-performance","title":"Test Database Performance","text":"<pre><code># Check active connections\ndocker compose exec db psql -U postgres -d myapp -c \"SELECT count(*) FROM pg_stat_activity;\"\n</code></pre>"},{"location":"getting-started/first-run/#monitoring-dashboard","title":"Monitoring Dashboard","text":""},{"location":"getting-started/first-run/#redis-monitor","title":"Redis Monitor","text":"<pre><code># Monitor Redis operations\ndocker compose exec redis redis-cli monitor\n</code></pre>"},{"location":"getting-started/first-run/#database-activity","title":"Database Activity","text":"<pre><code># Check database activity\ndocker compose exec db psql -U postgres -d myapp -c \"SELECT * FROM pg_stat_activity;\"\n</code></pre>"},{"location":"getting-started/first-run/#next-steps","title":"Next Steps","text":"<p>Now that you've verified everything works and created your first custom endpoint, you're ready to dive deeper:</p>"},{"location":"getting-started/first-run/#essential-learning","title":"Essential Learning","text":"<ol> <li>Project Structure - Understand how the code is organized</li> <li>Database Guide - Learn about models, schemas, and CRUD operations</li> <li>Authentication - Deep dive into JWT and user management</li> </ol>"},{"location":"getting-started/first-run/#advanced-features","title":"Advanced Features","text":"<ol> <li>Caching - Speed up your API with Redis caching</li> <li>Background Tasks - Process long-running tasks asynchronously</li> <li>Rate Limiting - Protect your API from abuse</li> </ol>"},{"location":"getting-started/first-run/#development-workflow","title":"Development Workflow","text":"<ol> <li>Development Guide - Best practices for extending the boilerplate</li> <li>Testing - Write tests for your new features</li> <li>Production - Deploy your API to production</li> </ol>"},{"location":"getting-started/first-run/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues:</p> <ol> <li>Check the logs for error messages</li> <li>Verify your configuration in the <code>.env</code> file</li> <li>Review the GitHub Issues for common solutions</li> <li>Search existing issues on GitHub</li> <li>Create a new issue with detailed information</li> </ol>"},{"location":"getting-started/first-run/#congratulations","title":"Congratulations!","text":"<p>You've successfully:</p> <ul> <li>Verified your FastAPI Boilerplate installation</li> <li>Tested core API functionality</li> <li>Created your first custom endpoint</li> <li>Run database migrations</li> <li>Tested authentication and CRUD operations</li> </ul> <p>You're now ready to build amazing APIs with FastAPI! </p>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide covers different ways to install and set up the FastAPI Boilerplate depending on your needs and environment.</p>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<p>Before you begin, ensure your system meets these requirements:</p> <ul> <li>Python: 3.11 or higher</li> <li>Operating System: Linux, macOS, or Windows (with WSL2 recommended)</li> <li>Memory: Minimum 4GB RAM (8GB recommended)</li> <li>Disk Space: At least 2GB free space</li> </ul>"},{"location":"getting-started/installation/#method-1-docker-compose-recommended","title":"Method 1: Docker Compose (Recommended)","text":"<p>Docker Compose is the easiest way to get started. It handles all dependencies and services automatically.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Install these tools on your system:</p> <ul> <li>Docker (version 20.10+)</li> <li>Docker Compose (version 1.29+)</li> </ul>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":"<ol> <li> <p>Get the template:    <pre><code>git clone https://github.com/benavlabs/fastapi-boilerplate\ncd fastapi-boilerplate\n</code></pre></p> </li> <li> <p>Set up environment:    <pre><code>cp src/.env.example src/.env\n# Edit src/.env with your configuration\n</code></pre></p> </li> <li> <p>Start services:    <pre><code>docker compose up -d\n</code></pre></p> </li> <li> <p>Verify installation:    <pre><code>curl http://localhost:8000/docs\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#what-gets-installed","title":"What Gets Installed","text":"<p>Docker Compose sets up these services:</p> <ul> <li>Web server (FastAPI + Uvicorn) on port 8000</li> <li>PostgreSQL database on port 5432 (internal)</li> <li>Redis server on port 6379 (internal)</li> <li>ARQ Worker for background tasks</li> <li>NGINX (optional, for production)</li> </ul>"},{"location":"getting-started/installation/#method-2-manual-installation","title":"Method 2: Manual Installation","text":"<p>For more control or development purposes, you can install everything manually.</p>"},{"location":"getting-started/installation/#prerequisites_1","title":"Prerequisites","text":"<ol> <li> <p>Install Python 3.11+:    <pre><code># On Ubuntu/Debian\nsudo apt update\nsudo apt install python3.11 python3.11-pip\n\n# On macOS (with Homebrew)\nbrew install python@3.11\n\n# On Windows\n# Download from python.org\n</code></pre></p> </li> <li> <p>Install uv (Python package manager):    <pre><code>pip install uv\n</code></pre></p> </li> <li> <p>Install PostgreSQL:    <pre><code># On Ubuntu/Debian\nsudo apt install postgresql postgresql-contrib\n\n# On macOS\nbrew install postgresql\n\n# On Windows\n# Download from postgresql.org\n</code></pre></p> </li> <li> <p>Install Redis:    <pre><code># On Ubuntu/Debian\nsudo apt install redis-server\n\n# On macOS\nbrew install redis\n\n# On Windows\n# Download from redis.io\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#installation-steps_1","title":"Installation Steps","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/benavlabs/fastapi-boilerplate\ncd fastapi-boilerplate\n</code></pre></p> </li> <li> <p>Install Python dependencies:    <pre><code>uv sync\n</code></pre></p> </li> <li> <p>Set up environment variables:    <pre><code>cp src/.env.example src/.env\n# Edit src/.env with your local database/Redis settings\n</code></pre></p> </li> <li> <p>Set up PostgreSQL:    <pre><code># Create database and user\nsudo -u postgres psql\nCREATE DATABASE myapp;\nCREATE USER myuser WITH PASSWORD 'mypassword';\nGRANT ALL PRIVILEGES ON DATABASE myapp TO myuser;\n\\q\n</code></pre></p> </li> <li> <p>Run database migrations:    <pre><code>cd src\nuv run alembic upgrade head\n</code></pre></p> </li> <li> <p>Create admin user:    <pre><code>uv run python -m src.scripts.create_first_superuser\n</code></pre></p> </li> <li> <p>Start the application:    <pre><code>uv run uvicorn src.app.main:app --reload --host 0.0.0.0 --port 8000\n</code></pre></p> </li> <li> <p>Start the worker (in another terminal):    <pre><code>uv run arq src.app.core.worker.settings.WorkerSettings\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#method-3-development-setup","title":"Method 3: Development Setup","text":"<p>For contributors and advanced users who want to modify the boilerplate.</p>"},{"location":"getting-started/installation/#additional-prerequisites","title":"Additional Prerequisites","text":"<ul> <li>Git for version control</li> <li>Pre-commit for code quality</li> </ul>"},{"location":"getting-started/installation/#installation-steps_2","title":"Installation Steps","text":"<ol> <li> <p>Fork and clone:    <pre><code># Fork the repository on GitHub first\ngit clone https://github.com/yourusername/fastapi-boilerplate\ncd fastapi-boilerplate\n</code></pre></p> </li> <li> <p>Install development dependencies:    <pre><code>uv sync --group dev\n</code></pre></p> </li> <li> <p>Set up pre-commit hooks:    <pre><code>uv run pre-commit install\n</code></pre></p> </li> <li> <p>Set up development environment:    <pre><code>cp src/.env.example src/.env\n# Configure for development\n</code></pre></p> </li> <li> <p>Run tests to verify setup:    <pre><code>uv run pytest\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#docker-services-breakdown","title":"Docker Services Breakdown","text":"<p>Understanding what each Docker service does:</p>"},{"location":"getting-started/installation/#web-service","title":"Web Service","text":"<p><pre><code>web:\n  build: .\n  ports:\n    - \"8000:8000\"\n  depends_on:\n    - db\n    - redis\n</code></pre> - Runs the FastAPI application - Handles HTTP requests - Auto-reloads on code changes (development)</p>"},{"location":"getting-started/installation/#database-service","title":"Database Service","text":"<p><pre><code>db:\n  image: postgres:13\n  environment:\n    POSTGRES_DB: myapp\n    POSTGRES_USER: postgres\n    POSTGRES_PASSWORD: changethis\n</code></pre> - PostgreSQL database server - Persistent data storage - Automatic initialization</p>"},{"location":"getting-started/installation/#redis-service","title":"Redis Service","text":"<p><pre><code>redis:\n  image: redis:alpine\n  command: redis-server --appendonly yes\n</code></pre> - In-memory data store - Used for caching and job queues - Persistent storage with AOF</p>"},{"location":"getting-started/installation/#worker-service","title":"Worker Service","text":"<p><pre><code>worker:\n  build: .\n  command: arq src.app.core.worker.settings.WorkerSettings\n  depends_on:\n    - redis\n</code></pre> - Background task processor - Handles async jobs - Scales independently</p>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":""},{"location":"getting-started/installation/#environment-variables","title":"Environment Variables","text":"<p>The application uses environment variables for configuration. Key variables:</p> <pre><code># Database\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=changethis\nPOSTGRES_SERVER=localhost  # or \"db\" for Docker\nPOSTGRES_PORT=5432\nPOSTGRES_DB=myapp\n\n# Redis\nREDIS_CACHE_HOST=localhost  # or \"redis\" for Docker\nREDIS_CACHE_PORT=6379\n\n# Security\nSECRET_KEY=your-secret-key-here\nALGORITHM=HS256\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre>"},{"location":"getting-started/installation/#database-connection","title":"Database Connection","text":"<p>For manual installation, update your database settings:</p> <pre><code># Local PostgreSQL\nPOSTGRES_SERVER=localhost\nPOSTGRES_PORT=5432\n\n# Docker PostgreSQL\nPOSTGRES_SERVER=db\nPOSTGRES_PORT=5432\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>After installation, verify everything works:</p> <ol> <li>API Documentation: http://localhost:8000/docs</li> <li>Health Check: http://localhost:8000/api/v1/health</li> <li>Database Connection: Check logs for successful connection</li> <li>Redis Connection: Test caching functionality</li> <li>Background Tasks: Submit a test job</li> </ol>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Port Already in Use: <pre><code># Check what's using port 8000\nlsof -i :8000\n\n# Kill the process\nkill -9 &lt;PID&gt;\n</code></pre></p> <p>Database Connection Error: <pre><code># Check PostgreSQL status\nsudo systemctl status postgresql\n\n# Restart PostgreSQL\nsudo systemctl restart postgresql\n</code></pre></p> <p>Redis Connection Error: <pre><code># Check Redis status\nredis-cli ping\n\n# Start Redis\nredis-server\n</code></pre></p> <p>Permission Errors: <pre><code># Fix Docker permissions\nsudo usermod -aG docker $USER\n# Log out and back in\n</code></pre></p>"},{"location":"getting-started/installation/#docker-issues","title":"Docker Issues","text":"<p>Clean Reset: <pre><code># Stop all containers\ndocker compose down\n\n# Remove volumes (\u26a0\ufe0f deletes data)\ndocker compose down -v\n\n# Rebuild images\ndocker compose build --no-cache\n\n# Start fresh\ndocker compose up\n</code></pre></p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Configuration Guide - Set up your environment</li> <li>First Run - Test your installation</li> <li>Project Structure - Understand the codebase</li> </ol>"},{"location":"getting-started/installation/#need-help","title":"Need Help?","text":"<p>If you encounter issues:</p> <ul> <li>Check the GitHub Issues for common problems</li> <li>Search existing issues</li> <li>Create a new issue with details </li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This user guide provides comprehensive information about using and understanding the FastAPI Boilerplate. Whether you're building your first API or looking to understand advanced features, this guide covers everything you need to know.</p>"},{"location":"user-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers all aspects of working with the FastAPI Boilerplate:</p>"},{"location":"user-guide/#project-understanding","title":"Project Understanding","text":"<ul> <li>Project Structure - Navigate the codebase organization and understand architectural decisions</li> <li>Configuration - Configure your application for different environments</li> </ul>"},{"location":"user-guide/#core-components","title":"Core Components","text":""},{"location":"user-guide/#database-operations","title":"Database Operations","text":"<ul> <li>Database Overview - Understand the data layer architecture</li> <li>Models - Define and work with SQLAlchemy models</li> <li>Schemas - Create Pydantic schemas for data validation</li> <li>CRUD Operations - Implement create, read, update, and delete operations</li> <li>Migrations - Manage database schema changes with Alembic</li> </ul>"},{"location":"user-guide/#api-development","title":"API Development","text":"<ul> <li>API Overview - Build robust REST APIs with FastAPI</li> <li>Endpoints - Create and organize API endpoints</li> <li>Pagination - Implement efficient data pagination</li> <li>Exception Handling - Handle errors gracefully</li> <li>API Versioning - Manage API versions and backward compatibility</li> </ul>"},{"location":"user-guide/#security-authentication","title":"Security &amp; Authentication","text":"<ul> <li>Authentication Overview - Secure your API with JWT authentication</li> <li>JWT Tokens - Understand access and refresh token management</li> <li>User Management - Handle user registration, login, and profiles</li> <li>Permissions - Implement role-based access control</li> </ul>"},{"location":"user-guide/#performance-caching","title":"Performance &amp; Caching","text":"<ul> <li>Caching Overview - Improve performance with Redis caching</li> <li>Redis Cache - Server-side caching with Redis</li> <li>Client Cache - HTTP caching headers and browser caching</li> <li>Cache Strategies - Advanced caching patterns and invalidation</li> </ul>"},{"location":"user-guide/#background-processing","title":"Background Processing","text":"<ul> <li>Background Tasks - Handle long-running operations with ARQ</li> </ul>"},{"location":"user-guide/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>Rate Limiting - Protect your API from abuse with Redis-based rate limiting</li> </ul>"},{"location":"user-guide/#prerequisites","title":"Prerequisites","text":"<p>Before diving into this guide, ensure you have:</p> <ul> <li>Completed the Getting Started section</li> <li>A running FastAPI Boilerplate instance</li> <li>Basic understanding of Python, FastAPI, and REST APIs</li> <li>Familiarity with SQL databases (PostgreSQL knowledge is helpful)</li> </ul>"},{"location":"user-guide/#next-steps","title":"Next Steps","text":"<p>Ready to dive in? Here are recommended learning paths:</p>"},{"location":"user-guide/#for-new-users","title":"For New Users","text":"<ol> <li>Start with Project Structure to understand the codebase</li> <li>Learn Database Models and Schemas</li> <li>Create your first API Endpoints</li> <li>Add Authentication to secure your API</li> </ol>"},{"location":"user-guide/#for-experienced-developers","title":"For Experienced Developers","text":"<ol> <li>Review Database CRUD Operations for advanced patterns</li> <li>Implement Caching Strategies for performance</li> <li>Set up Background Tasks for async processing</li> <li>Configure Rate Limiting for production use</li> </ol>"},{"location":"user-guide/#for-production-deployment","title":"For Production Deployment","text":"<ol> <li>Understand Cache Strategies patterns</li> <li>Configure Rate Limiting with user tiers</li> <li>Set up Background Task Processing</li> <li>Review the Production Guide for deployment considerations</li> </ol> <p>Choose your path based on your needs and experience level. Each section builds upon previous concepts while remaining self-contained for reference use. </p>"},{"location":"user-guide/development/","title":"Development Guide","text":"<p>This guide covers everything you need to know about extending, customizing, and developing with the FastAPI boilerplate.</p>"},{"location":"user-guide/development/#extending-the-boilerplate","title":"Extending the Boilerplate","text":""},{"location":"user-guide/development/#adding-new-models","title":"Adding New Models","text":"<p>Follow this step-by-step process to add new entities to your application:</p>"},{"location":"user-guide/development/#1-create-sqlalchemy-model","title":"1. Create SQLAlchemy Model","text":"<p>Create a new file in <code>src/app/models/</code> (e.g., <code>category.py</code>):</p> <pre><code>from sqlalchemy import String, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom ..core.db.database import Base\n\n\nclass Category(Base):\n    __tablename__ = \"category\"\n\n    id: Mapped[int] = mapped_column(\n        \"id\", \n        autoincrement=True, \n        nullable=False, \n        unique=True, \n        primary_key=True, \n        init=False\n    )\n    name: Mapped[str] = mapped_column(String(50))\n    description: Mapped[str | None] = mapped_column(String(255), default=None)\n\n    # Relationships\n    posts: Mapped[list[\"Post\"]] = relationship(back_populates=\"category\")\n</code></pre>"},{"location":"user-guide/development/#2-create-pydantic-schemas","title":"2. Create Pydantic Schemas","text":"<p>Create <code>src/app/schemas/category.py</code>:</p> <pre><code>from datetime import datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, Field, ConfigDict\n\n\nclass CategoryBase(BaseModel):\n    name: Annotated[str, Field(min_length=1, max_length=50)]\n    description: Annotated[str | None, Field(max_length=255, default=None)]\n\n\nclass CategoryCreate(CategoryBase):\n    model_config = ConfigDict(extra=\"forbid\")\n\n\nclass CategoryRead(CategoryBase):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    created_at: datetime\n\n\nclass CategoryUpdate(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    name: Annotated[str | None, Field(min_length=1, max_length=50, default=None)]\n    description: Annotated[str | None, Field(max_length=255, default=None)]\n\n\nclass CategoryUpdateInternal(CategoryUpdate):\n    updated_at: datetime\n\n\nclass CategoryDelete(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    is_deleted: bool\n    deleted_at: datetime\n</code></pre>"},{"location":"user-guide/development/#3-create-crud-operations","title":"3. Create CRUD Operations","text":"<p>Create <code>src/app/crud/crud_categories.py</code>:</p> <pre><code>from fastcrud import FastCRUD\n\nfrom ..models.category import Category\nfrom ..schemas.category import CategoryCreate, CategoryUpdate, CategoryUpdateInternal, CategoryDelete\n\nCRUDCategory = FastCRUD[Category, CategoryCreate, CategoryUpdate, CategoryUpdateInternal, CategoryDelete]\ncrud_categories = CRUDCategory(Category)\n</code></pre>"},{"location":"user-guide/development/#4-update-model-imports","title":"4. Update Model Imports","text":"<p>Add your new model to <code>src/app/models/__init__.py</code>:</p> <pre><code>from .category import Category\nfrom .user import User\nfrom .post import Post\n# ... other imports\n</code></pre>"},{"location":"user-guide/development/#5-create-database-migration","title":"5. Create Database Migration","text":"<p>Generate and apply the migration:</p> <pre><code># From the src/ directory\nuv run alembic revision --autogenerate -m \"Add category model\"\nuv run alembic upgrade head\n</code></pre>"},{"location":"user-guide/development/#6-create-api-endpoints","title":"6. Create API Endpoints","text":"<p>Create <code>src/app/api/v1/categories.py</code>:</p> <pre><code>from typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request\nfrom fastcrud.paginated import PaginatedListResponse, compute_offset\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom ...api.dependencies import get_current_superuser, get_current_user\nfrom ...core.db.database import async_get_db\nfrom ...core.exceptions.http_exceptions import DuplicateValueException, NotFoundException\nfrom ...crud.crud_categories import crud_categories\nfrom ...schemas.category import CategoryCreate, CategoryRead, CategoryUpdate\n\nrouter = APIRouter(tags=[\"categories\"])\n\n\n@router.post(\"/category\", response_model=CategoryRead, status_code=201)\nasync def write_category(\n    request: Request,\n    category: CategoryCreate,\n    current_user: Annotated[dict, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n):\n    category_row = await crud_categories.exists(db=db, name=category.name)\n    if category_row:\n        raise DuplicateValueException(\"Category name already exists\")\n\n    return await crud_categories.create(db=db, object=category)\n\n\n@router.get(\"/categories\", response_model=PaginatedListResponse[CategoryRead])\nasync def read_categories(\n    request: Request,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    page: int = 1,\n    items_per_page: int = 10,\n):\n    categories_data = await crud_categories.get_multi(\n        db=db,\n        offset=compute_offset(page, items_per_page),\n        limit=items_per_page,\n        schema_to_select=CategoryRead,\n        is_deleted=False,\n    )\n\n    return categories_data\n\n\n@router.get(\"/category/{category_id}\", response_model=CategoryRead)\nasync def read_category(\n    request: Request,\n    category_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n):\n    db_category = await crud_categories.get(\n        db=db, \n        schema_to_select=CategoryRead, \n        id=category_id,\n        is_deleted=False\n    )\n    if not db_category:\n        raise NotFoundException(\"Category not found\")\n\n    return db_category\n\n\n@router.patch(\"/category/{category_id}\", response_model=CategoryRead)\nasync def patch_category(\n    request: Request,\n    category_id: int,\n    values: CategoryUpdate,\n    current_user: Annotated[dict, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n):\n    db_category = await crud_categories.get(db=db, id=category_id, is_deleted=False)\n    if not db_category:\n        raise NotFoundException(\"Category not found\")\n\n    if values.name:\n        category_row = await crud_categories.exists(db=db, name=values.name)\n        if category_row and category_row[\"id\"] != category_id:\n            raise DuplicateValueException(\"Category name already exists\")\n\n    return await crud_categories.update(db=db, object=values, id=category_id)\n\n\n@router.delete(\"/category/{category_id}\")\nasync def erase_category(\n    request: Request,\n    category_id: int,\n    current_user: Annotated[dict, Depends(get_current_superuser)],\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n):\n    db_category = await crud_categories.get(db=db, id=category_id, is_deleted=False)\n    if not db_category:\n        raise NotFoundException(\"Category not found\")\n\n    await crud_categories.delete(db=db, db_row=db_category, garbage_collection=False)\n    return {\"message\": \"Category deleted\"}\n</code></pre>"},{"location":"user-guide/development/#7-register-router","title":"7. Register Router","text":"<p>Add your router to <code>src/app/api/v1/__init__.py</code>:</p> <pre><code>from fastapi import APIRouter\nfrom .categories import router as categories_router\n# ... other imports\n\nrouter = APIRouter()\nrouter.include_router(categories_router, prefix=\"/categories\")\n# ... other router includes\n</code></pre>"},{"location":"user-guide/development/#creating-custom-middleware","title":"Creating Custom Middleware","text":"<p>Create middleware in <code>src/app/middleware/</code>:</p> <pre><code>from fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\n\nclass CustomHeaderMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        # Pre-processing\n        start_time = time.time()\n\n        # Process request\n        response = await call_next(request)\n\n        # Post-processing\n        process_time = time.time() - start_time\n        response.headers[\"X-Process-Time\"] = str(process_time)\n\n        return response\n</code></pre> <p>Register in <code>src/app/main.py</code>:</p> <pre><code>from .middleware.custom_header_middleware import CustomHeaderMiddleware\n\napp.add_middleware(CustomHeaderMiddleware)\n</code></pre>"},{"location":"user-guide/development/#testing","title":"Testing","text":""},{"location":"user-guide/development/#test-configuration","title":"Test Configuration","text":"<p>The boilerplate uses pytest for testing. Test configuration is in <code>pytest.ini</code> and test dependencies in <code>pyproject.toml</code>.</p>"},{"location":"user-guide/development/#database-testing-setup","title":"Database Testing Setup","text":"<p>Create test database fixtures in <code>tests/conftest.py</code>:</p> <pre><code>import asyncio\nimport pytest\nimport pytest_asyncio\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom src.app.core.config import settings\nfrom src.app.core.db.database import Base, async_get_db\nfrom src.app.main import app\n\n# Test database URL\nTEST_DATABASE_URL = \"postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db\"\n\n# Create test engine\ntest_engine = create_async_engine(TEST_DATABASE_URL, echo=True)\nTestSessionLocal = sessionmaker(\n    test_engine, class_=AsyncSession, expire_on_commit=False\n)\n\n\n@pytest_asyncio.fixture\nasync def async_session():\n    async with test_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with TestSessionLocal() as session:\n        yield session\n\n    async with test_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n\n@pytest_asyncio.fixture\nasync def async_client(async_session):\n    def get_test_db():\n        return async_session\n\n    app.dependency_overrides[async_get_db] = get_test_db\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        yield client\n\n    app.dependency_overrides.clear()\n</code></pre>"},{"location":"user-guide/development/#writing-tests","title":"Writing Tests","text":""},{"location":"user-guide/development/#model-tests","title":"Model Tests","text":"<pre><code># tests/test_models.py\nimport pytest\nfrom src.app.models.user import User\n\n\n@pytest_asyncio.fixture\nasync def test_user(async_session):\n    user = User(\n        name=\"Test User\",\n        username=\"testuser\",\n        email=\"test@example.com\",\n        hashed_password=\"hashed_password\"\n    )\n    async_session.add(user)\n    await async_session.commit()\n    await async_session.refresh(user)\n    return user\n\n\nasync def test_user_creation(test_user):\n    assert test_user.name == \"Test User\"\n    assert test_user.username == \"testuser\"\n    assert test_user.email == \"test@example.com\"\n</code></pre>"},{"location":"user-guide/development/#api-endpoint-tests","title":"API Endpoint Tests","text":"<pre><code># tests/test_api.py\nimport pytest\nfrom httpx import AsyncClient\n\n\nasync def test_create_user(async_client: AsyncClient):\n    user_data = {\n        \"name\": \"New User\",\n        \"username\": \"newuser\",\n        \"email\": \"new@example.com\",\n        \"password\": \"SecurePass123!\"\n    }\n\n    response = await async_client.post(\"/api/v1/users\", json=user_data)\n    assert response.status_code == 201\n\n    data = response.json()\n    assert data[\"name\"] == \"New User\"\n    assert data[\"username\"] == \"newuser\"\n    assert \"hashed_password\" not in data  # Ensure password not exposed\n\n\nasync def test_read_users(async_client: AsyncClient):\n    response = await async_client.get(\"/api/v1/users\")\n    assert response.status_code == 200\n\n    data = response.json()\n    assert \"data\" in data\n    assert \"total_count\" in data\n</code></pre>"},{"location":"user-guide/development/#crud-tests","title":"CRUD Tests","text":"<pre><code># tests/test_crud.py\nimport pytest\nfrom src.app.crud.crud_users import crud_users\nfrom src.app.schemas.user import UserCreate\n\n\nasync def test_crud_create_user(async_session):\n    user_data = UserCreate(\n        name=\"CRUD User\",\n        username=\"cruduser\",\n        email=\"crud@example.com\",\n        password=\"password123\"\n    )\n\n    user = await crud_users.create(db=async_session, object=user_data)\n    assert user[\"name\"] == \"CRUD User\"\n    assert user[\"username\"] == \"cruduser\"\n\n\nasync def test_crud_get_user(async_session, test_user):\n    retrieved_user = await crud_users.get(\n        db=async_session, \n        id=test_user.id\n    )\n    assert retrieved_user[\"name\"] == test_user.name\n</code></pre>"},{"location":"user-guide/development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=src\n\n# Run specific test file\nuv run pytest tests/test_api.py\n\n# Run with verbose output\nuv run pytest -v\n\n# Run tests matching pattern\nuv run pytest -k \"test_user\"\n</code></pre>"},{"location":"user-guide/development/#customization","title":"Customization","text":""},{"location":"user-guide/development/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Create environment-specific settings:</p> <pre><code># src/app/core/config.py\nclass LocalSettings(Settings):\n    ENVIRONMENT: str = \"local\"\n    DEBUG: bool = True\n\nclass ProductionSettings(Settings):\n    ENVIRONMENT: str = \"production\"\n    DEBUG: bool = False\n    # Production-specific settings\n\ndef get_settings():\n    env = os.getenv(\"ENVIRONMENT\", \"local\")\n    if env == \"production\":\n        return ProductionSettings()\n    return LocalSettings()\n\nsettings = get_settings()\n</code></pre>"},{"location":"user-guide/development/#custom-logging","title":"Custom Logging","text":"<p>Configure logging in <code>src/app/core/config.py</code>:</p> <pre><code>import logging\nfrom pythonjsonlogger import jsonlogger\n\ndef setup_logging():\n    # JSON logging for production\n    if settings.ENVIRONMENT == \"production\":\n        logHandler = logging.StreamHandler()\n        formatter = jsonlogger.JsonFormatter()\n        logHandler.setFormatter(formatter)\n        logger = logging.getLogger()\n        logger.addHandler(logHandler)\n        logger.setLevel(logging.INFO)\n    else:\n        # Simple logging for development\n        logging.basicConfig(\n            level=logging.DEBUG,\n            format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n</code></pre>"},{"location":"user-guide/development/#opting-out-of-services","title":"Opting Out of Services","text":""},{"location":"user-guide/development/#disabling-redis-caching","title":"Disabling Redis Caching","text":"<ol> <li>Remove cache decorators from endpoints</li> <li>Update dependencies in <code>src/app/core/config.py</code>:</li> </ol> <pre><code>class Settings(BaseSettings):\n    # Comment out or remove Redis cache settings\n    # REDIS_CACHE_HOST: str = \"localhost\"\n    # REDIS_CACHE_PORT: int = 6379\n    pass\n</code></pre> <ol> <li>Remove Redis cache imports and usage</li> </ol>"},{"location":"user-guide/development/#disabling-background-tasks-arq","title":"Disabling Background Tasks (ARQ)","text":"<ol> <li>Remove ARQ from <code>pyproject.toml</code> dependencies</li> <li>Remove worker configuration from <code>docker-compose.yml</code></li> <li>Delete <code>src/app/core/worker/</code> directory</li> <li>Remove task-related endpoints</li> </ol>"},{"location":"user-guide/development/#disabling-rate-limiting","title":"Disabling Rate Limiting","text":"<ol> <li>Remove rate limiting dependencies from endpoints:</li> </ol> <pre><code># Remove this dependency\ndependencies=[Depends(rate_limiter_dependency)]\n</code></pre> <ol> <li>Remove rate limiting models and schemas</li> <li>Update database migrations to remove rate limit tables</li> </ol>"},{"location":"user-guide/development/#disabling-authentication","title":"Disabling Authentication","text":"<ol> <li>Remove JWT dependencies from protected endpoints</li> <li>Remove user-related models and endpoints</li> <li>Update database to remove user tables</li> <li>Remove authentication middleware</li> </ol>"},{"location":"user-guide/development/#minimal-fastapi-setup","title":"Minimal FastAPI Setup","text":"<p>For a minimal setup with just basic FastAPI:</p> <pre><code># src/app/main.py (minimal version)\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    title=\"Minimal API\",\n    description=\"Basic FastAPI application\",\n    version=\"1.0.0\"\n)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"user-guide/development/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/development/#code-organization","title":"Code Organization","text":"<ul> <li>Keep models, schemas, and CRUD operations in separate files</li> <li>Use consistent naming conventions across the application</li> <li>Group related functionality in modules</li> <li>Follow FastAPI and Pydantic best practices</li> </ul>"},{"location":"user-guide/development/#database-operations","title":"Database Operations","text":"<ul> <li>Always use transactions for multi-step operations</li> <li>Implement soft deletes for important data</li> <li>Use database constraints for data integrity</li> <li>Index frequently queried columns</li> </ul>"},{"location":"user-guide/development/#api-design","title":"API Design","text":"<ul> <li>Use consistent response formats</li> <li>Implement proper error handling</li> <li>Version your APIs from the start</li> <li>Document all endpoints with proper schemas</li> </ul>"},{"location":"user-guide/development/#security","title":"Security","text":"<ul> <li>Never expose sensitive data in API responses</li> <li>Use proper authentication and authorization</li> <li>Validate all input data</li> <li>Implement rate limiting for public endpoints</li> <li>Use HTTPS in production</li> </ul>"},{"location":"user-guide/development/#performance","title":"Performance","text":"<ul> <li>Use async/await consistently</li> <li>Implement caching for expensive operations</li> <li>Use database connection pooling</li> <li>Monitor and optimize slow queries</li> <li>Use pagination for large datasets</li> </ul>"},{"location":"user-guide/development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/development/#common-issues","title":"Common Issues","text":"<p>Import Errors: Ensure all new models are imported in <code>__init__.py</code> files</p> <p>Migration Failures: Check model definitions and relationships before generating migrations</p> <p>Test Failures: Verify test database configuration and isolation</p> <p>Performance Issues: Check for N+1 queries and missing database indexes</p> <p>Authentication Problems: Verify JWT configuration and token expiration settings</p>"},{"location":"user-guide/development/#debugging-tips","title":"Debugging Tips","text":"<ul> <li>Use FastAPI's automatic interactive docs at <code>/docs</code></li> <li>Enable SQL query logging in development</li> <li>Use proper logging throughout the application</li> <li>Test endpoints with realistic data volumes</li> <li>Monitor database performance with query analysis</li> </ul>"},{"location":"user-guide/development/#database-migrations","title":"Database Migrations","text":"<p>Important Setup for Docker Users</p> <p>If you're using the database in Docker, you need to expose the port to run migrations. Change this in <code>docker-compose.yml</code>:</p> <pre><code>db:\n  image: postgres:13\n  env_file:\n    - ./src/.env\n  volumes:\n    - postgres-data:/var/lib/postgresql/data\n  # -------- replace with comment to run migrations with docker --------\n  ports:\n    - 5432:5432\n  # expose:\n  #   - \"5432\"\n</code></pre>"},{"location":"user-guide/development/#creating-migrations","title":"Creating Migrations","text":"<p>Model Import Requirement</p> <p>To create tables if you haven't created endpoints yet, ensure you import the models in <code>src/app/models/__init__.py</code>. This step is crucial for Alembic to detect new tables.</p> <p>While in the <code>src</code> folder, run Alembic migrations:</p> <pre><code># Generate migration file\nuv run alembic revision --autogenerate -m \"Description of changes\"\n\n# Apply migrations\nuv run alembic upgrade head\n</code></pre> <p>Without uv</p> <p>If you don't have uv, run <code>pip install alembic</code> first, then use <code>alembic</code> commands directly.</p>"},{"location":"user-guide/development/#migration-workflow","title":"Migration Workflow","text":"<ol> <li>Make Model Changes - Modify your SQLAlchemy models</li> <li>Import Models - Ensure models are imported in <code>src/app/models/__init__.py</code></li> <li>Generate Migration - Run <code>alembic revision --autogenerate</code></li> <li>Review Migration - Check the generated migration file in <code>src/migrations/versions/</code></li> <li>Apply Migration - Run <code>alembic upgrade head</code></li> <li>Test Changes - Verify your changes work as expected</li> </ol>"},{"location":"user-guide/development/#common-migration-tasks","title":"Common Migration Tasks","text":""},{"location":"user-guide/development/#adding-a-new-model","title":"Adding a New Model","text":"<pre><code># 1. Create the model file (e.g., src/app/models/category.py)\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom app.core.db.database import Base\n\nclass Category(Base):\n    __tablename__ = \"categories\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(50))\n    description: Mapped[str] = mapped_column(String(255), nullable=True)\n</code></pre> <pre><code># 2. Import in src/app/models/__init__.py\nfrom .user import User\nfrom .post import Post\nfrom .tier import Tier\nfrom .rate_limit import RateLimit\nfrom .category import Category  # Add this line\n</code></pre> <pre><code># 3. Generate and apply migration\ncd src\nuv run alembic revision --autogenerate -m \"Add categories table\"\nuv run alembic upgrade head\n</code></pre>"},{"location":"user-guide/development/#modifying-existing-models","title":"Modifying Existing Models","text":"<pre><code># 1. Modify your model\nclass User(Base):\n    # ... existing fields ...\n    bio: Mapped[str] = mapped_column(String(500), nullable=True)  # New field\n</code></pre> <pre><code># 2. Generate migration\nuv run alembic revision --autogenerate -m \"Add bio field to users\"\n\n# 3. Review the generated migration file\n# 4. Apply migration\nuv run alembic upgrade head\n</code></pre> <p>This guide provides the foundation for extending and customizing the FastAPI boilerplate. For specific implementation details, refer to the existing code examples throughout the boilerplate. </p>"},{"location":"user-guide/production/","title":"Production Deployment","text":"<p>This guide covers deploying the FastAPI boilerplate to production with proper performance, security, and reliability configurations.</p>"},{"location":"user-guide/production/#production-architecture","title":"Production Architecture","text":"<p>The recommended production setup uses:</p> <ul> <li>Gunicorn - WSGI server managing Uvicorn workers</li> <li>Uvicorn Workers - ASGI server handling FastAPI requests</li> <li>NGINX - Reverse proxy and load balancer</li> <li>PostgreSQL - Production database</li> <li>Redis - Caching and background tasks</li> <li>Docker - Containerization</li> </ul>"},{"location":"user-guide/production/#environment-configuration","title":"Environment Configuration","text":""},{"location":"user-guide/production/#production-environment-variables","title":"Production Environment Variables","text":"<p>Update your <code>.env</code> file for production:</p> <pre><code># ------------- environment -------------\nENVIRONMENT=\"production\"\n\n# ------------- app settings -------------\nAPP_NAME=\"Your Production App\"\nDEBUG=false\n\n# ------------- database -------------\nPOSTGRES_USER=\"prod_user\"\nPOSTGRES_PASSWORD=\"secure_production_password\"\nPOSTGRES_SERVER=\"db\"  # or your database host\nPOSTGRES_PORT=5432\nPOSTGRES_DB=\"prod_database\"\n\n# ------------- redis -------------\nREDIS_CACHE_HOST=\"redis\"\nREDIS_CACHE_PORT=6379\nREDIS_QUEUE_HOST=\"redis\"\nREDIS_QUEUE_PORT=6379\nREDIS_RATE_LIMIT_HOST=\"redis\"\nREDIS_RATE_LIMIT_PORT=6379\n\n# ------------- security -------------\nSECRET_KEY=\"your-super-secure-secret-key-generate-with-openssl\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n\n# ------------- logging -------------\nLOG_LEVEL=\"INFO\"\n</code></pre>"},{"location":"user-guide/production/#docker-configuration","title":"Docker Configuration","text":""},{"location":"user-guide/production/#production-dockerfile","title":"Production Dockerfile","text":"<pre><code>FROM python:3.11-slim\n\nWORKDIR /code\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install UV\nRUN pip install uv\n\n# Copy dependency files\nCOPY pyproject.toml uv.lock ./\n\n# Install dependencies\nRUN uv sync --frozen --no-dev\n\n# Copy application code\nCOPY src/ ./src/\n\n# Create non-root user\nRUN useradd --create-home --shell /bin/bash app \\\n    &amp;&amp; chown -R app:app /code\nUSER app\n\n# Production command with Gunicorn\nCMD [\"uv\", \"run\", \"gunicorn\", \"src.app.main:app\", \"-w\", \"4\", \"-k\", \"uvicorn.workers.UvicornWorker\", \"--bind\", \"0.0.0.0:8000\"]\n</code></pre>"},{"location":"user-guide/production/#production-docker-compose","title":"Production Docker Compose","text":"<pre><code>version: '3.8'\n\nservices:\n  web:\n    build: .\n    ports:\n      - \"8000:8000\"\n    env_file:\n      - ./src/.env\n    depends_on:\n      - db\n      - redis\n    restart: unless-stopped\n    deploy:\n      resources:\n        limits:\n          memory: 1G\n        reservations:\n          memory: 512M\n\n  worker:\n    build: .\n    command: uv run arq src.app.core.worker.settings.WorkerSettings\n    env_file:\n      - ./src/.env\n    depends_on:\n      - db\n      - redis\n    restart: unless-stopped\n    deploy:\n      replicas: 2\n\n  db:\n    image: postgres:15\n    volumes:\n      - postgres_data:/var/lib/postgresql/data/\n    environment:\n      - POSTGRES_USER=${POSTGRES_USER}\n      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}\n      - POSTGRES_DB=${POSTGRES_DB}\n    restart: unless-stopped\n    deploy:\n      resources:\n        limits:\n          memory: 2G\n        reservations:\n          memory: 1G\n\n  redis:\n    image: redis:7-alpine\n    restart: unless-stopped\n    volumes:\n      - redis_data:/data\n    deploy:\n      resources:\n        limits:\n          memory: 512M\n        reservations:\n          memory: 256M\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf\n      - ./nginx/ssl:/etc/nginx/ssl\n    depends_on:\n      - web\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  redis_data:\n</code></pre>"},{"location":"user-guide/production/#gunicorn-configuration","title":"Gunicorn Configuration","text":""},{"location":"user-guide/production/#basic-gunicorn-setup","title":"Basic Gunicorn Setup","text":"<p>Create <code>gunicorn.conf.py</code>:</p> <pre><code>import multiprocessing\n\n# Server socket\nbind = \"0.0.0.0:8000\"\nbacklog = 2048\n\n# Worker processes\nworkers = multiprocessing.cpu_count() * 2 + 1\nworker_class = \"uvicorn.workers.UvicornWorker\"\nworker_connections = 1000\nmax_requests = 1000\nmax_requests_jitter = 50\n\n# Restart workers after this many requests, with up to 50 jitter\npreload_app = True\n\n# Logging\naccesslog = \"-\"\nerrorlog = \"-\"\nloglevel = \"info\"\naccess_log_format = '%(h)s %(l)s %(u)s %(t)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\" %(D)s'\n\n# Process naming\nproc_name = \"fastapi-boilerplate\"\n\n# Server mechanics\ndaemon = False\npidfile = \"/tmp/gunicorn.pid\"\nuser = None\ngroup = None\ntmp_upload_dir = None\n\n# SSL (if terminating SSL at application level)\n# keyfile = \"/path/to/keyfile\"\n# certfile = \"/path/to/certfile\"\n\n# Worker timeout\ntimeout = 30\nkeepalive = 2\n\n# Memory management\nmax_requests = 1000\nmax_requests_jitter = 50\npreload_app = True\n</code></pre>"},{"location":"user-guide/production/#running-with-gunicorn","title":"Running with Gunicorn","text":"<pre><code># Basic command\nuv run gunicorn src.app.main:app -w 4 -k uvicorn.workers.UvicornWorker\n\n# With configuration file\nuv run gunicorn src.app.main:app -c gunicorn.conf.py\n\n# With specific bind address\nuv run gunicorn src.app.main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000\n</code></pre>"},{"location":"user-guide/production/#nginx-configuration","title":"NGINX Configuration","text":""},{"location":"user-guide/production/#single-server-setup","title":"Single Server Setup","text":"<p>Create <code>nginx/nginx.conf</code>:</p> <pre><code>events {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream fastapi_backend {\n        server web:8000;\n    }\n\n    server {\n        listen 80;\n        server_name your-domain.com;\n\n        # Redirect HTTP to HTTPS\n        return 301 https://$server_name$request_uri;\n    }\n\n    server {\n        listen 443 ssl http2;\n        server_name your-domain.com;\n\n        # SSL Configuration\n        ssl_certificate /etc/nginx/ssl/cert.pem;\n        ssl_certificate_key /etc/nginx/ssl/key.pem;\n        ssl_protocols TLSv1.2 TLSv1.3;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;\n        ssl_prefer_server_ciphers off;\n\n        # Security headers\n        add_header X-Frame-Options DENY;\n        add_header X-Content-Type-Options nosniff;\n        add_header X-XSS-Protection \"1; mode=block\";\n        add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n\n        # Gzip compression\n        gzip on;\n        gzip_vary on;\n        gzip_min_length 10240;\n        gzip_proxied expired no-cache no-store private must-revalidate auth;\n        gzip_types\n            text/plain\n            text/css\n            text/xml\n            text/javascript\n            application/javascript\n            application/xml+rss\n            application/json;\n\n        # Rate limiting\n        limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n\n        location / {\n            limit_req zone=api burst=20 nodelay;\n\n            proxy_pass http://fastapi_backend;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n\n            # Timeouts\n            proxy_connect_timeout 60s;\n            proxy_send_timeout 60s;\n            proxy_read_timeout 60s;\n\n            # Buffer settings\n            proxy_buffering on;\n            proxy_buffer_size 8k;\n            proxy_buffers 8 8k;\n        }\n\n        # Health check endpoint (no rate limiting)\n        location /health {\n            proxy_pass http://fastapi_backend;\n            proxy_set_header Host $host;\n            access_log off;\n        }\n\n        # Static files (if any)\n        location /static/ {\n            alias /code/static/;\n            expires 1y;\n            add_header Cache-Control \"public, immutable\";\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/production/#simple-single-server-defaultconf","title":"Simple Single Server (default.conf)","text":"<p>For basic production setup, create <code>default.conf</code>:</p> <pre><code># ---------------- Running With One Server ----------------\nserver {\n    listen 80;\n\n    location / {\n        proxy_pass http://web:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre>"},{"location":"user-guide/production/#load-balancing-multiple-servers","title":"Load Balancing Multiple Servers","text":"<p>For horizontal scaling with multiple FastAPI instances:</p> <pre><code># ---------------- To Run with Multiple Servers ----------------\nupstream fastapi_app {\n    server fastapi1:8000;  # Replace with actual server names\n    server fastapi2:8000;\n    # Add more servers as needed\n}\n\nserver {\n    listen 80;\n\n    location / {\n        proxy_pass http://fastapi_app;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre>"},{"location":"user-guide/production/#advanced-load-balancing","title":"Advanced Load Balancing","text":"<p>For production with advanced features:</p> <pre><code>upstream fastapi_backend {\n    least_conn;\n    server web1:8000 weight=3;\n    server web2:8000 weight=2;\n    server web3:8000 weight=1;\n\n    # Health checks\n    keepalive 32;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com;\n\n    location / {\n        proxy_pass http://fastapi_backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Connection settings for load balancing\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"\";\n    }\n}\n</code></pre>"},{"location":"user-guide/production/#ssl-certificate-setup","title":"SSL Certificate Setup","text":""},{"location":"user-guide/production/#using-lets-encrypt-certbot","title":"Using Let's Encrypt (Certbot)","text":"<pre><code># Install certbot\nsudo apt-get update\nsudo apt-get install certbot python3-certbot-nginx\n\n# Obtain certificate\nsudo certbot --nginx -d your-domain.com\n\n# Auto-renewal (add to crontab)\n0 2 * * 1 /usr/bin/certbot renew --quiet\n</code></pre>"},{"location":"user-guide/production/#manual-ssl-setup","title":"Manual SSL Setup","text":"<pre><code># Generate self-signed certificate (development only)\nmkdir -p nginx/ssl\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n    -keyout nginx/ssl/key.pem \\\n    -out nginx/ssl/cert.pem\n</code></pre>"},{"location":"user-guide/production/#production-best-practices","title":"Production Best Practices","text":""},{"location":"user-guide/production/#database-optimization","title":"Database Optimization","text":""},{"location":"user-guide/production/#postgresql-configuration","title":"PostgreSQL Configuration","text":"<pre><code>-- Optimize PostgreSQL for production\nALTER SYSTEM SET shared_buffers = '256MB';\nALTER SYSTEM SET effective_cache_size = '1GB';\nALTER SYSTEM SET random_page_cost = 1.1;\nALTER SYSTEM SET effective_io_concurrency = 200;\nSELECT pg_reload_conf();\n</code></pre>"},{"location":"user-guide/production/#connection-pooling","title":"Connection Pooling","text":"<pre><code># src/app/core/db/database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\n# Production database settings\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,  # Disable in production\n    pool_size=20,\n    max_overflow=0,\n    pool_pre_ping=True,\n    pool_recycle=3600,\n)\n</code></pre>"},{"location":"user-guide/production/#redis-configuration","title":"Redis Configuration","text":""},{"location":"user-guide/production/#redis-production-settings","title":"Redis Production Settings","text":"<pre><code># redis.conf adjustments\nmaxmemory 512mb\nmaxmemory-policy allkeys-lru\nsave 900 1\nsave 300 10\nsave 60 10000\n</code></pre>"},{"location":"user-guide/production/#application-optimization","title":"Application Optimization","text":""},{"location":"user-guide/production/#logging-configuration","title":"Logging Configuration","text":"<pre><code># src/app/core/config.py\nimport logging\nfrom pythonjsonlogger import jsonlogger\n\ndef setup_production_logging():\n    logHandler = logging.StreamHandler()\n    formatter = jsonlogger.JsonFormatter(\n        \"%(asctime)s %(name)s %(levelname)s %(message)s\"\n    )\n    logHandler.setFormatter(formatter)\n\n    logger = logging.getLogger()\n    logger.addHandler(logHandler)\n    logger.setLevel(logging.INFO)\n\n    # Reduce noise from third-party libraries\n    logging.getLogger(\"uvicorn.access\").setLevel(logging.WARNING)\n    logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.WARNING)\n</code></pre>"},{"location":"user-guide/production/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># src/app/middleware/monitoring.py\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass MonitoringMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n\n        response = await call_next(request)\n\n        process_time = time.time() - start_time\n        response.headers[\"X-Process-Time\"] = str(process_time)\n\n        # Log slow requests\n        if process_time &gt; 1.0:\n            logger.warning(f\"Slow request: {request.method} {request.url} - {process_time:.2f}s\")\n\n        return response\n</code></pre>"},{"location":"user-guide/production/#security-configuration","title":"Security Configuration","text":""},{"location":"user-guide/production/#environment-security","title":"Environment Security","text":"<pre><code># src/app/core/config.py\nclass ProductionSettings(Settings):\n    # Hide docs in production\n    ENVIRONMENT: str = \"production\"\n\n    # Security settings\n    SECRET_KEY: str = Field(..., min_length=32)\n    ALLOWED_HOSTS: list[str] = [\"your-domain.com\", \"api.your-domain.com\"]\n\n    # Database security\n    POSTGRES_PASSWORD: str = Field(..., min_length=16)\n\n    class Config:\n        case_sensitive = True\n</code></pre>"},{"location":"user-guide/production/#rate-limiting","title":"Rate Limiting","text":"<pre><code># Adjust rate limits for production\nDEFAULT_RATE_LIMIT_LIMIT = 100  # requests per period\nDEFAULT_RATE_LIMIT_PERIOD = 3600  # 1 hour\n</code></pre>"},{"location":"user-guide/production/#health-checks","title":"Health Checks","text":""},{"location":"user-guide/production/#application-health-check","title":"Application Health Check","text":"<pre><code># src/app/api/v1/health.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom ...core.db.database import async_get_db\nfrom ...core.utils.cache import redis_client\n\nrouter = APIRouter()\n\n@router.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"timestamp\": datetime.utcnow()}\n\n@router.get(\"/health/detailed\")\nasync def detailed_health_check(db: AsyncSession = Depends(async_get_db)):\n    health_status = {\"status\": \"healthy\", \"services\": {}}\n\n    # Check database\n    try:\n        await db.execute(\"SELECT 1\")\n        health_status[\"services\"][\"database\"] = \"healthy\"\n    except Exception:\n        health_status[\"services\"][\"database\"] = \"unhealthy\"\n        health_status[\"status\"] = \"unhealthy\"\n\n    # Check Redis\n    try:\n        await redis_client.ping()\n        health_status[\"services\"][\"redis\"] = \"healthy\"\n    except Exception:\n        health_status[\"services\"][\"redis\"] = \"unhealthy\"\n        health_status[\"status\"] = \"unhealthy\"\n\n    if health_status[\"status\"] == \"unhealthy\":\n        raise HTTPException(status_code=503, detail=health_status)\n\n    return health_status\n</code></pre>"},{"location":"user-guide/production/#deployment-process","title":"Deployment Process","text":""},{"location":"user-guide/production/#cicd-pipeline-github-actions","title":"CI/CD Pipeline (GitHub Actions)","text":"<pre><code># .github/workflows/deploy.yml\nname: Deploy to Production\n\non:\n  push:\n    branches: [main]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build and push Docker image\n        env:\n          DOCKER_REGISTRY: your-registry.com\n        run: |\n          docker build -t $DOCKER_REGISTRY/fastapi-app:latest .\n          docker push $DOCKER_REGISTRY/fastapi-app:latest\n\n      - name: Deploy to production\n        run: |\n          # Your deployment commands\n          ssh production-server \"docker compose pull &amp;&amp; docker compose up -d\"\n</code></pre>"},{"location":"user-guide/production/#zero-downtime-deployment","title":"Zero-Downtime Deployment","text":"<pre><code>#!/bin/bash\n# deploy.sh - Zero-downtime deployment script\n\n# Pull new images\ndocker compose pull\n\n# Start new containers\ndocker compose up -d --no-deps --scale web=2 web\n\n# Wait for health check\nsleep 30\n\n# Stop old containers\ndocker compose up -d --no-deps --scale web=1 web\n\n# Clean up\ndocker system prune -f\n</code></pre>"},{"location":"user-guide/production/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"user-guide/production/#basic-monitoring-setup","title":"Basic Monitoring Setup","text":"<pre><code># Basic metrics collection\nimport psutil\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/metrics\")\nasync def get_metrics():\n    return {\n        \"cpu_percent\": psutil.cpu_percent(),\n        \"memory_percent\": psutil.virtual_memory().percent,\n        \"disk_usage\": psutil.disk_usage('/').percent\n    }\n</code></pre>"},{"location":"user-guide/production/#backup-strategy","title":"Backup Strategy","text":""},{"location":"user-guide/production/#database-backup","title":"Database Backup","text":"<pre><code>#!/bin/bash\n# backup-db.sh\nBACKUP_DIR=\"/backups\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\npg_dump -h localhost -U $POSTGRES_USER $POSTGRES_DB | gzip &gt; $BACKUP_DIR/backup_$DATE.sql.gz\n\n# Keep only last 7 days of backups\nfind $BACKUP_DIR -name \"backup_*.sql.gz\" -mtime +7 -delete\n</code></pre>"},{"location":"user-guide/production/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/production/#common-production-issues","title":"Common Production Issues","text":"<p>High Memory Usage: Check for memory leaks, optimize database queries, adjust worker counts</p> <p>Slow Response Times: Enable query logging, check database indexes, optimize N+1 queries</p> <p>Connection Timeouts: Adjust proxy timeouts, check database connection pool settings</p> <p>SSL Certificate Issues: Verify certificate paths, check renewal process</p>"},{"location":"user-guide/production/#performance-tuning","title":"Performance Tuning","text":"<ul> <li>Monitor database query performance</li> <li>Implement proper caching strategies</li> <li>Use connection pooling</li> <li>Optimize Docker image layers</li> <li>Configure proper resource limits</li> </ul> <p>This production guide provides a solid foundation for deploying the FastAPI boilerplate to production environments with proper performance, security, and reliability configurations. </p>"},{"location":"user-guide/project-structure/","title":"Project Structure","text":"<p>Understanding the project structure is essential for navigating the FastAPI Boilerplate effectively. This guide explains the organization of the codebase, the purpose of each directory, and how components interact with each other.</p>"},{"location":"user-guide/project-structure/#overview","title":"Overview","text":"<p>The FastAPI Boilerplate follows a clean, modular architecture that separates concerns and promotes maintainability. The structure is designed to scale from simple APIs to complex applications while maintaining code organization and clarity.</p>"},{"location":"user-guide/project-structure/#root-directory-structure","title":"Root Directory Structure","text":"<pre><code>FastAPI-boilerplate/\n\u251c\u2500\u2500 Dockerfile                 # Container configuration\n\u251c\u2500\u2500 docker-compose.yml         # Multi-service orchestration\n\u251c\u2500\u2500 pyproject.toml            # Project configuration and dependencies\n\u251c\u2500\u2500 uv.lock                   # Dependency lock file\n\u251c\u2500\u2500 README.md                 # Project documentation\n\u251c\u2500\u2500 LICENSE.md                # License information\n\u251c\u2500\u2500 tests/                    # Test suite\n\u251c\u2500\u2500 docs/                     # Documentation\n\u2514\u2500\u2500 src/                      # Source code\n</code></pre>"},{"location":"user-guide/project-structure/#configuration-files","title":"Configuration Files","text":"File Purpose <code>Dockerfile</code> Defines the container image for the application <code>docker-compose.yml</code> Orchestrates multiple services (API, database, Redis, worker) <code>pyproject.toml</code> Modern Python project configuration with dependencies and metadata <code>uv.lock</code> Locks exact dependency versions for reproducible builds"},{"location":"user-guide/project-structure/#source-code-structure","title":"Source Code Structure","text":"<p>The <code>src/</code> directory contains all application code:</p> <pre><code>src/\n\u251c\u2500\u2500 app/                      # Main application package\n\u2502   \u251c\u2500\u2500 main.py              # Application entry point\n\u2502   \u251c\u2500\u2500 api/                 # API layer\n\u2502   \u251c\u2500\u2500 core/                # Core utilities and configurations\n\u2502   \u251c\u2500\u2500 crud/                # Database operations\n\u2502   \u251c\u2500\u2500 models/              # SQLAlchemy models\n\u2502   \u251c\u2500\u2500 schemas/             # Pydantic schemas\n\u2502   \u251c\u2500\u2500 middleware/          # Custom middleware\n\u2502   \u2514\u2500\u2500 logs/                # Application logs\n\u251c\u2500\u2500 migrations/              # Database migrations\n\u2514\u2500\u2500 scripts/                 # Utility scripts\n</code></pre>"},{"location":"user-guide/project-structure/#core-application-srcapp","title":"Core Application (<code>src/app/</code>)","text":""},{"location":"user-guide/project-structure/#entry-point","title":"Entry Point","text":"<ul> <li><code>main.py</code> - FastAPI application instance and configuration</li> </ul>"},{"location":"user-guide/project-structure/#api-layer-api","title":"API Layer (<code>api/</code>)","text":"<pre><code>api/\n\u251c\u2500\u2500 dependencies.py          # Shared dependencies\n\u2514\u2500\u2500 v1/                     # API version 1\n    \u251c\u2500\u2500 login.py            # Authentication endpoints\n    \u251c\u2500\u2500 logout.py           # Logout functionality\n    \u251c\u2500\u2500 users.py            # User management\n    \u251c\u2500\u2500 posts.py            # Post operations\n    \u251c\u2500\u2500 tasks.py            # Background task endpoints\n    \u251c\u2500\u2500 tiers.py            # User tier management\n    \u2514\u2500\u2500 rate_limits.py      # Rate limiting endpoints\n</code></pre> <p>Purpose: Contains all API endpoints organized by functionality and version.</p>"},{"location":"user-guide/project-structure/#core-system-core","title":"Core System (<code>core/</code>)","text":"<pre><code>core/\n\u251c\u2500\u2500 config.py               # Application settings\n\u251c\u2500\u2500 logger.py               # Logging configuration\n\u251c\u2500\u2500 schemas.py              # Core Pydantic schemas\n\u251c\u2500\u2500 security.py             # Security utilities\n\u251c\u2500\u2500 setup.py                # Application factory\n\u251c\u2500\u2500 db/                     # Database core\n\u251c\u2500\u2500 exceptions/             # Custom exceptions\n\u251c\u2500\u2500 utils/                  # Utility functions\n\u2514\u2500\u2500 worker/                 # Background worker\n</code></pre> <p>Purpose: Houses core functionality, configuration, and shared utilities.</p>"},{"location":"user-guide/project-structure/#database-core-coredb","title":"Database Core (<code>core/db/</code>)","text":"<pre><code>db/\n\u251c\u2500\u2500 database.py             # Database connection and session management\n\u251c\u2500\u2500 models.py               # Base models and mixins\n\u251c\u2500\u2500 crud_token_blacklist.py # Token blacklist operations\n\u2514\u2500\u2500 token_blacklist.py      # Token blacklist model\n</code></pre>"},{"location":"user-guide/project-structure/#exceptions-coreexceptions","title":"Exceptions (<code>core/exceptions/</code>)","text":"<pre><code>exceptions/\n\u251c\u2500\u2500 cache_exceptions.py     # Cache-related exceptions\n\u2514\u2500\u2500 http_exceptions.py      # HTTP exceptions\n</code></pre>"},{"location":"user-guide/project-structure/#utilities-coreutils","title":"Utilities (<code>core/utils/</code>)","text":"<pre><code>utils/\n\u251c\u2500\u2500 cache.py                # Caching utilities\n\u251c\u2500\u2500 queue.py                # Task queue management\n\u2514\u2500\u2500 rate_limit.py           # Rate limiting utilities\n</code></pre>"},{"location":"user-guide/project-structure/#worker-coreworker","title":"Worker (<code>core/worker/</code>)","text":"<pre><code>worker/\n\u251c\u2500\u2500 settings.py             # Worker configuration\n\u2514\u2500\u2500 functions.py            # Background task definitions\n</code></pre>"},{"location":"user-guide/project-structure/#data-layer","title":"Data Layer","text":""},{"location":"user-guide/project-structure/#models-models","title":"Models (<code>models/</code>)","text":"<pre><code>models/\n\u251c\u2500\u2500 user.py                 # User model\n\u251c\u2500\u2500 post.py                 # Post model\n\u251c\u2500\u2500 tier.py                 # User tier model\n\u2514\u2500\u2500 rate_limit.py           # Rate limit model\n</code></pre> <p>Purpose: SQLAlchemy ORM models defining database schema.</p>"},{"location":"user-guide/project-structure/#schemas-schemas","title":"Schemas (<code>schemas/</code>)","text":"<pre><code>schemas/\n\u251c\u2500\u2500 user.py                 # User validation schemas\n\u251c\u2500\u2500 post.py                 # Post validation schemas\n\u251c\u2500\u2500 tier.py                 # Tier validation schemas\n\u251c\u2500\u2500 rate_limit.py           # Rate limit schemas\n\u2514\u2500\u2500 job.py                  # Background job schemas\n</code></pre> <p>Purpose: Pydantic schemas for request/response validation and serialization.</p>"},{"location":"user-guide/project-structure/#crud-operations-crud","title":"CRUD Operations (<code>crud/</code>)","text":"<pre><code>crud/\n\u251c\u2500\u2500 crud_base.py            # Base CRUD class\n\u251c\u2500\u2500 crud_users.py           # User operations\n\u251c\u2500\u2500 crud_posts.py           # Post operations\n\u251c\u2500\u2500 crud_tier.py            # Tier operations\n\u251c\u2500\u2500 crud_rate_limit.py      # Rate limit operations\n\u2514\u2500\u2500 helper.py               # CRUD helper functions\n</code></pre> <p>Purpose: Database operations using FastCRUD for consistent data access patterns.</p>"},{"location":"user-guide/project-structure/#additional-components","title":"Additional Components","text":""},{"location":"user-guide/project-structure/#middleware-middleware","title":"Middleware (<code>middleware/</code>)","text":"<pre><code>middleware/\n\u2514\u2500\u2500 client_cache_middleware.py  # Client-side caching middleware\n</code></pre>"},{"location":"user-guide/project-structure/#logs-logs","title":"Logs (<code>logs/</code>)","text":"<pre><code>logs/\n\u2514\u2500\u2500 app.log                 # Application log file\n</code></pre>"},{"location":"user-guide/project-structure/#database-migrations-srcmigrations","title":"Database Migrations (<code>src/migrations/</code>)","text":"<pre><code>migrations/\n\u251c\u2500\u2500 README                  # Migration instructions\n\u251c\u2500\u2500 env.py                  # Alembic environment configuration\n\u251c\u2500\u2500 script.py.mako          # Migration template\n\u2514\u2500\u2500 versions/               # Individual migration files\n</code></pre> <p>Purpose: Alembic database migrations for schema version control.</p>"},{"location":"user-guide/project-structure/#utility-scripts-srcscripts","title":"Utility Scripts (<code>src/scripts/</code>)","text":"<pre><code>scripts/\n\u251c\u2500\u2500 create_first_superuser.py  # Create initial admin user\n\u2514\u2500\u2500 create_first_tier.py       # Create initial user tier\n</code></pre> <p>Purpose: Initialization and maintenance scripts.</p>"},{"location":"user-guide/project-structure/#testing-structure-tests","title":"Testing Structure (<code>tests/</code>)","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py             # Pytest configuration and fixtures\n\u251c\u2500\u2500 test_user_unit.py       # User-related unit tests\n\u2514\u2500\u2500 helpers/                # Test utilities\n    \u251c\u2500\u2500 generators.py       # Test data generators\n    \u2514\u2500\u2500 mocks.py            # Mock objects and functions\n</code></pre>"},{"location":"user-guide/project-structure/#architectural-patterns","title":"Architectural Patterns","text":""},{"location":"user-guide/project-structure/#layered-architecture","title":"Layered Architecture","text":"<p>The boilerplate implements a clean layered architecture:</p> <ol> <li>API Layer (<code>api/</code>) - Handles HTTP requests and responses</li> <li>Business Logic (<code>crud/</code>) - Implements business rules and data operations</li> <li>Data Access (<code>models/</code>) - Defines data structure and database interaction</li> <li>Core Services (<code>core/</code>) - Provides shared functionality and configuration</li> </ol>"},{"location":"user-guide/project-structure/#dependency-injection","title":"Dependency Injection","text":"<p>FastAPI's dependency injection system is used throughout:</p> <ul> <li>Database Sessions - Injected into endpoints via <code>async_get_db</code></li> <li>Authentication - User context provided by <code>get_current_user</code></li> <li>Rate Limiting - Applied via <code>rate_limiter_dependency</code></li> <li>Caching - Managed through decorators and middleware</li> </ul>"},{"location":"user-guide/project-structure/#configuration-management","title":"Configuration Management","text":"<p>All configuration is centralized in <code>core/config.py</code>:</p> <ul> <li>Environment Variables - Loaded from <code>.env</code> file</li> <li>Settings Classes - Organized by functionality (database, security, etc.)</li> <li>Type Safety - Using Pydantic for validation</li> </ul>"},{"location":"user-guide/project-structure/#error-handling","title":"Error Handling","text":"<p>Centralized exception handling:</p> <ul> <li>Custom Exceptions - Defined in <code>core/exceptions/</code></li> <li>HTTP Status Codes - Consistent error responses</li> <li>Logging - Automatic error logging and tracking</li> </ul>"},{"location":"user-guide/project-structure/#design-principles","title":"Design Principles","text":""},{"location":"user-guide/project-structure/#single-responsibility","title":"Single Responsibility","text":"<p>Each module has a clear, single purpose:</p> <ul> <li>Models define data structure</li> <li>Schemas handle validation</li> <li>CRUD manages data operations</li> <li>API endpoints handle requests</li> </ul>"},{"location":"user-guide/project-structure/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li>Business logic separated from presentation</li> <li>Database operations isolated from API logic</li> <li>Configuration centralized and environment-aware</li> </ul>"},{"location":"user-guide/project-structure/#modularity","title":"Modularity","text":"<ul> <li>Features can be added/removed independently</li> <li>Services can be disabled via configuration</li> <li>Clear interfaces between components</li> </ul>"},{"location":"user-guide/project-structure/#scalability","title":"Scalability","text":"<ul> <li>Async/await throughout the application</li> <li>Connection pooling for database access</li> <li>Caching and background task support</li> <li>Horizontal scaling ready</li> </ul>"},{"location":"user-guide/project-structure/#navigation-tips","title":"Navigation Tips","text":""},{"location":"user-guide/project-structure/#finding-code","title":"Finding Code","text":"<ul> <li>Models \u2192 <code>src/app/models/</code></li> <li>API Endpoints \u2192 <code>src/app/api/v1/</code></li> <li>Database Operations \u2192 <code>src/app/crud/</code></li> <li>Configuration \u2192 <code>src/app/core/config.py</code></li> <li>Business Logic \u2192 Distributed across CRUD and API layers</li> </ul>"},{"location":"user-guide/project-structure/#adding-new-features","title":"Adding New Features","text":"<ol> <li>Model \u2192 Define in <code>models/</code></li> <li>Schema \u2192 Create in <code>schemas/</code></li> <li>CRUD \u2192 Implement in <code>crud/</code></li> <li>API \u2192 Add endpoints in <code>api/v1/</code></li> <li>Migration \u2192 Generate with Alembic</li> </ol>"},{"location":"user-guide/project-structure/#understanding-data-flow","title":"Understanding Data Flow","text":"<pre><code>Request \u2192 API Endpoint \u2192 Dependencies \u2192 CRUD \u2192 Model \u2192 Database\nResponse \u2190 API Response \u2190 Schema \u2190 CRUD \u2190 Query Result \u2190 Database\n</code></pre> <p>This structure provides a solid foundation for building scalable, maintainable APIs while keeping the codebase organized and easy to navigate. </p>"},{"location":"user-guide/testing/","title":"Testing Guide","text":"<p>This guide covers comprehensive testing strategies for the FastAPI boilerplate, including unit tests, integration tests, and API testing.</p>"},{"location":"user-guide/testing/#test-setup","title":"Test Setup","text":""},{"location":"user-guide/testing/#testing-dependencies","title":"Testing Dependencies","text":"<p>The boilerplate uses these testing libraries:</p> <ul> <li>pytest - Testing framework</li> <li>pytest-asyncio - Async test support</li> <li>httpx - Async HTTP client for API tests</li> <li>pytest-cov - Coverage reporting</li> <li>faker - Test data generation</li> </ul>"},{"location":"user-guide/testing/#test-configuration","title":"Test Configuration","text":""},{"location":"user-guide/testing/#pytestini","title":"pytest.ini","text":"<pre><code>[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts = \n    -v\n    --strict-markers\n    --strict-config\n    --cov=src\n    --cov-report=term-missing\n    --cov-report=html\n    --cov-report=xml\n    --cov-fail-under=80\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    api: API tests\n    slow: Slow tests\nasyncio_mode = auto\n</code></pre>"},{"location":"user-guide/testing/#test-database-setup","title":"Test Database Setup","text":"<p>Create <code>tests/conftest.py</code>:</p> <pre><code>import asyncio\nimport pytest\nimport pytest_asyncio\nfrom typing import AsyncGenerator\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom faker import Faker\n\nfrom src.app.core.config import settings\nfrom src.app.core.db.database import Base, async_get_db\nfrom src.app.main import app\nfrom src.app.models.user import User\nfrom src.app.models.post import Post\nfrom src.app.core.security import get_password_hash\n\n# Test database configuration\nTEST_DATABASE_URL = \"postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db\"\n\n# Create test engine and session\ntest_engine = create_async_engine(TEST_DATABASE_URL, echo=False)\nTestSessionLocal = sessionmaker(\n    test_engine, class_=AsyncSession, expire_on_commit=False\n)\n\nfake = Faker()\n\n\n@pytest_asyncio.fixture\nasync def async_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"Create a fresh database session for each test.\"\"\"\n    async with test_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with TestSessionLocal() as session:\n        yield session\n\n    async with test_engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n\n@pytest_asyncio.fixture\nasync def async_client(async_session: AsyncSession) -&gt; AsyncGenerator[AsyncClient, None]:\n    \"\"\"Create an async HTTP client for testing.\"\"\"\n    def get_test_db():\n        return async_session\n\n    app.dependency_overrides[async_get_db] = get_test_db\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        yield client\n\n    app.dependency_overrides.clear()\n\n\n@pytest_asyncio.fixture\nasync def test_user(async_session: AsyncSession) -&gt; User:\n    \"\"\"Create a test user.\"\"\"\n    user = User(\n        name=fake.name(),\n        username=fake.user_name(),\n        email=fake.email(),\n        hashed_password=get_password_hash(\"testpassword123\"),\n        is_superuser=False\n    )\n    async_session.add(user)\n    await async_session.commit()\n    await async_session.refresh(user)\n    return user\n\n\n@pytest_asyncio.fixture\nasync def test_superuser(async_session: AsyncSession) -&gt; User:\n    \"\"\"Create a test superuser.\"\"\"\n    user = User(\n        name=\"Super Admin\",\n        username=\"superadmin\",\n        email=\"admin@test.com\",\n        hashed_password=get_password_hash(\"superpassword123\"),\n        is_superuser=True\n    )\n    async_session.add(user)\n    await async_session.commit()\n    await async_session.refresh(user)\n    return user\n\n\n@pytest_asyncio.fixture\nasync def test_post(async_session: AsyncSession, test_user: User) -&gt; Post:\n    \"\"\"Create a test post.\"\"\"\n    post = Post(\n        title=fake.sentence(),\n        content=fake.text(),\n        created_by_user_id=test_user.id\n    )\n    async_session.add(post)\n    await async_session.commit()\n    await async_session.refresh(post)\n    return post\n\n\n@pytest_asyncio.fixture\nasync def auth_headers(async_client: AsyncClient, test_user: User) -&gt; dict:\n    \"\"\"Get authentication headers for a test user.\"\"\"\n    login_data = {\n        \"username\": test_user.username,\n        \"password\": \"testpassword123\"\n    }\n\n    response = await async_client.post(\"/api/v1/auth/login\", data=login_data)\n    token = response.json()[\"access_token\"]\n\n    return {\"Authorization\": f\"Bearer {token}\"}\n\n\n@pytest_asyncio.fixture\nasync def superuser_headers(async_client: AsyncClient, test_superuser: User) -&gt; dict:\n    \"\"\"Get authentication headers for a test superuser.\"\"\"\n    login_data = {\n        \"username\": test_superuser.username,\n        \"password\": \"superpassword123\"\n    }\n\n    response = await async_client.post(\"/api/v1/auth/login\", data=login_data)\n    token = response.json()[\"access_token\"]\n\n    return {\"Authorization\": f\"Bearer {token}\"}\n</code></pre>"},{"location":"user-guide/testing/#unit-tests","title":"Unit Tests","text":""},{"location":"user-guide/testing/#model-tests","title":"Model Tests","text":"<pre><code># tests/test_models.py\nimport pytest\nfrom datetime import datetime\nfrom src.app.models.user import User\nfrom src.app.models.post import Post\n\n\n@pytest.mark.unit\nclass TestUserModel:\n    \"\"\"Test User model functionality.\"\"\"\n\n    async def test_user_creation(self, async_session):\n        \"\"\"Test creating a user.\"\"\"\n        user = User(\n            name=\"Test User\",\n            username=\"testuser\",\n            email=\"test@example.com\",\n            hashed_password=\"hashed_password\"\n        )\n\n        async_session.add(user)\n        await async_session.commit()\n        await async_session.refresh(user)\n\n        assert user.id is not None\n        assert user.name == \"Test User\"\n        assert user.username == \"testuser\"\n        assert user.email == \"test@example.com\"\n        assert user.created_at is not None\n        assert user.is_superuser is False\n        assert user.is_deleted is False\n\n    async def test_user_relationships(self, async_session, test_user):\n        \"\"\"Test user relationships.\"\"\"\n        post = Post(\n            title=\"Test Post\",\n            content=\"Test content\",\n            created_by_user_id=test_user.id\n        )\n\n        async_session.add(post)\n        await async_session.commit()\n\n        # Test relationship\n        await async_session.refresh(test_user)\n        assert len(test_user.posts) == 1\n        assert test_user.posts[0].title == \"Test Post\"\n\n\n@pytest.mark.unit\nclass TestPostModel:\n    \"\"\"Test Post model functionality.\"\"\"\n\n    async def test_post_creation(self, async_session, test_user):\n        \"\"\"Test creating a post.\"\"\"\n        post = Post(\n            title=\"Test Post\",\n            content=\"This is test content\",\n            created_by_user_id=test_user.id\n        )\n\n        async_session.add(post)\n        await async_session.commit()\n        await async_session.refresh(post)\n\n        assert post.id is not None\n        assert post.title == \"Test Post\"\n        assert post.content == \"This is test content\"\n        assert post.created_by_user_id == test_user.id\n        assert post.created_at is not None\n        assert post.is_deleted is False\n</code></pre>"},{"location":"user-guide/testing/#schema-tests","title":"Schema Tests","text":"<pre><code># tests/test_schemas.py\nimport pytest\nfrom pydantic import ValidationError\nfrom src.app.schemas.user import UserCreate, UserRead, UserUpdate\nfrom src.app.schemas.post import PostCreate, PostRead, PostUpdate\n\n\n@pytest.mark.unit\nclass TestUserSchemas:\n    \"\"\"Test User schema validation.\"\"\"\n\n    def test_user_create_valid(self):\n        \"\"\"Test valid user creation schema.\"\"\"\n        user_data = {\n            \"name\": \"John Doe\",\n            \"username\": \"johndoe\",\n            \"email\": \"john@example.com\",\n            \"password\": \"SecurePass123!\"\n        }\n\n        user = UserCreate(**user_data)\n        assert user.name == \"John Doe\"\n        assert user.username == \"johndoe\"\n        assert user.email == \"john@example.com\"\n        assert user.password == \"SecurePass123!\"\n\n    def test_user_create_invalid_email(self):\n        \"\"\"Test invalid email validation.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            UserCreate(\n                name=\"John Doe\",\n                username=\"johndoe\",\n                email=\"invalid-email\",\n                password=\"SecurePass123!\"\n            )\n\n        errors = exc_info.value.errors()\n        assert any(error['type'] == 'value_error' for error in errors)\n\n    def test_user_create_short_password(self):\n        \"\"\"Test password length validation.\"\"\"\n        with pytest.raises(ValidationError) as exc_info:\n            UserCreate(\n                name=\"John Doe\",\n                username=\"johndoe\",\n                email=\"john@example.com\",\n                password=\"123\"\n            )\n\n        errors = exc_info.value.errors()\n        assert any(error['type'] == 'value_error' for error in errors)\n\n    def test_user_update_partial(self):\n        \"\"\"Test partial user update.\"\"\"\n        update_data = {\"name\": \"Jane Doe\"}\n        user_update = UserUpdate(**update_data)\n\n        assert user_update.name == \"Jane Doe\"\n        assert user_update.username is None\n        assert user_update.email is None\n\n\n@pytest.mark.unit\nclass TestPostSchemas:\n    \"\"\"Test Post schema validation.\"\"\"\n\n    def test_post_create_valid(self):\n        \"\"\"Test valid post creation.\"\"\"\n        post_data = {\n            \"title\": \"Test Post\",\n            \"content\": \"This is a test post content\"\n        }\n\n        post = PostCreate(**post_data)\n        assert post.title == \"Test Post\"\n        assert post.content == \"This is a test post content\"\n\n    def test_post_create_empty_title(self):\n        \"\"\"Test empty title validation.\"\"\"\n        with pytest.raises(ValidationError):\n            PostCreate(\n                title=\"\",\n                content=\"This is a test post content\"\n            )\n\n    def test_post_create_long_title(self):\n        \"\"\"Test title length validation.\"\"\"\n        with pytest.raises(ValidationError):\n            PostCreate(\n                title=\"x\" * 101,  # Exceeds max length\n                content=\"This is a test post content\"\n            )\n</code></pre>"},{"location":"user-guide/testing/#crud-tests","title":"CRUD Tests","text":"<pre><code># tests/test_crud.py\nimport pytest\nfrom src.app.crud.crud_users import crud_users\nfrom src.app.crud.crud_posts import crud_posts\nfrom src.app.schemas.user import UserCreate, UserUpdate\nfrom src.app.schemas.post import PostCreate, PostUpdate\n\n\n@pytest.mark.unit\nclass TestUserCRUD:\n    \"\"\"Test User CRUD operations.\"\"\"\n\n    async def test_create_user(self, async_session):\n        \"\"\"Test creating a user.\"\"\"\n        user_data = UserCreate(\n            name=\"CRUD User\",\n            username=\"cruduser\",\n            email=\"crud@example.com\",\n            password=\"password123\"\n        )\n\n        user = await crud_users.create(db=async_session, object=user_data)\n        assert user[\"name\"] == \"CRUD User\"\n        assert user[\"username\"] == \"cruduser\"\n        assert user[\"email\"] == \"crud@example.com\"\n        assert \"id\" in user\n\n    async def test_get_user(self, async_session, test_user):\n        \"\"\"Test getting a user.\"\"\"\n        retrieved_user = await crud_users.get(\n            db=async_session, \n            id=test_user.id\n        )\n\n        assert retrieved_user is not None\n        assert retrieved_user[\"id\"] == test_user.id\n        assert retrieved_user[\"name\"] == test_user.name\n        assert retrieved_user[\"username\"] == test_user.username\n\n    async def test_get_user_by_email(self, async_session, test_user):\n        \"\"\"Test getting a user by email.\"\"\"\n        retrieved_user = await crud_users.get(\n            db=async_session,\n            email=test_user.email\n        )\n\n        assert retrieved_user is not None\n        assert retrieved_user[\"email\"] == test_user.email\n\n    async def test_update_user(self, async_session, test_user):\n        \"\"\"Test updating a user.\"\"\"\n        update_data = UserUpdate(name=\"Updated Name\")\n\n        updated_user = await crud_users.update(\n            db=async_session,\n            object=update_data,\n            id=test_user.id\n        )\n\n        assert updated_user[\"name\"] == \"Updated Name\"\n        assert updated_user[\"id\"] == test_user.id\n\n    async def test_delete_user(self, async_session, test_user):\n        \"\"\"Test soft deleting a user.\"\"\"\n        await crud_users.delete(db=async_session, id=test_user.id)\n\n        # User should be soft deleted\n        deleted_user = await crud_users.get(\n            db=async_session,\n            id=test_user.id,\n            is_deleted=True\n        )\n\n        assert deleted_user is not None\n        assert deleted_user[\"is_deleted\"] is True\n\n    async def test_get_multi_users(self, async_session):\n        \"\"\"Test getting multiple users.\"\"\"\n        # Create multiple users\n        for i in range(5):\n            user_data = UserCreate(\n                name=f\"User {i}\",\n                username=f\"user{i}\",\n                email=f\"user{i}@example.com\",\n                password=\"password123\"\n            )\n            await crud_users.create(db=async_session, object=user_data)\n\n        # Get users with pagination\n        result = await crud_users.get_multi(\n            db=async_session,\n            offset=0,\n            limit=3\n        )\n\n        assert len(result[\"data\"]) == 3\n        assert result[\"total_count\"] == 5\n        assert result[\"has_more\"] is True\n\n\n@pytest.mark.unit\nclass TestPostCRUD:\n    \"\"\"Test Post CRUD operations.\"\"\"\n\n    async def test_create_post(self, async_session, test_user):\n        \"\"\"Test creating a post.\"\"\"\n        post_data = PostCreate(\n            title=\"Test Post\",\n            content=\"This is test content\"\n        )\n\n        post = await crud_posts.create(\n            db=async_session,\n            object=post_data,\n            created_by_user_id=test_user.id\n        )\n\n        assert post[\"title\"] == \"Test Post\"\n        assert post[\"content\"] == \"This is test content\"\n        assert post[\"created_by_user_id\"] == test_user.id\n\n    async def test_get_posts_by_user(self, async_session, test_user):\n        \"\"\"Test getting posts by user.\"\"\"\n        # Create multiple posts\n        for i in range(3):\n            post_data = PostCreate(\n                title=f\"Post {i}\",\n                content=f\"Content {i}\"\n            )\n            await crud_posts.create(\n                db=async_session,\n                object=post_data,\n                created_by_user_id=test_user.id\n            )\n\n        # Get posts by user\n        result = await crud_posts.get_multi(\n            db=async_session,\n            created_by_user_id=test_user.id\n        )\n\n        assert len(result[\"data\"]) == 3\n        assert result[\"total_count\"] == 3\n</code></pre>"},{"location":"user-guide/testing/#integration-tests","title":"Integration Tests","text":""},{"location":"user-guide/testing/#api-endpoint-tests","title":"API Endpoint Tests","text":"<pre><code># tests/test_api_users.py\nimport pytest\nfrom httpx import AsyncClient\n\n\n@pytest.mark.integration\nclass TestUserAPI:\n    \"\"\"Test User API endpoints.\"\"\"\n\n    async def test_create_user(self, async_client: AsyncClient):\n        \"\"\"Test user creation endpoint.\"\"\"\n        user_data = {\n            \"name\": \"New User\",\n            \"username\": \"newuser\",\n            \"email\": \"new@example.com\",\n            \"password\": \"SecurePass123!\"\n        }\n\n        response = await async_client.post(\"/api/v1/users\", json=user_data)\n        assert response.status_code == 201\n\n        data = response.json()\n        assert data[\"name\"] == \"New User\"\n        assert data[\"username\"] == \"newuser\"\n        assert data[\"email\"] == \"new@example.com\"\n        assert \"hashed_password\" not in data\n        assert \"id\" in data\n\n    async def test_create_user_duplicate_email(self, async_client: AsyncClient, test_user):\n        \"\"\"Test creating user with duplicate email.\"\"\"\n        user_data = {\n            \"name\": \"Duplicate User\",\n            \"username\": \"duplicateuser\",\n            \"email\": test_user.email,  # Use existing email\n            \"password\": \"SecurePass123!\"\n        }\n\n        response = await async_client.post(\"/api/v1/users\", json=user_data)\n        assert response.status_code == 409  # Conflict\n\n    async def test_get_users(self, async_client: AsyncClient):\n        \"\"\"Test getting users list.\"\"\"\n        response = await async_client.get(\"/api/v1/users\")\n        assert response.status_code == 200\n\n        data = response.json()\n        assert \"data\" in data\n        assert \"total_count\" in data\n        assert \"has_more\" in data\n        assert isinstance(data[\"data\"], list)\n\n    async def test_get_user_by_id(self, async_client: AsyncClient, test_user):\n        \"\"\"Test getting specific user.\"\"\"\n        response = await async_client.get(f\"/api/v1/users/{test_user.id}\")\n        assert response.status_code == 200\n\n        data = response.json()\n        assert data[\"id\"] == test_user.id\n        assert data[\"name\"] == test_user.name\n        assert data[\"username\"] == test_user.username\n\n    async def test_get_user_not_found(self, async_client: AsyncClient):\n        \"\"\"Test getting non-existent user.\"\"\"\n        response = await async_client.get(\"/api/v1/users/99999\")\n        assert response.status_code == 404\n\n    async def test_update_user_authorized(self, async_client: AsyncClient, test_user, auth_headers):\n        \"\"\"Test updating user with proper authorization.\"\"\"\n        update_data = {\"name\": \"Updated Name\"}\n\n        response = await async_client.patch(\n            f\"/api/v1/users/{test_user.id}\",\n            json=update_data,\n            headers=auth_headers\n        )\n        assert response.status_code == 200\n\n        data = response.json()\n        assert data[\"name\"] == \"Updated Name\"\n        assert data[\"id\"] == test_user.id\n\n    async def test_update_user_unauthorized(self, async_client: AsyncClient, test_user):\n        \"\"\"Test updating user without authorization.\"\"\"\n        update_data = {\"name\": \"Updated Name\"}\n\n        response = await async_client.patch(\n            f\"/api/v1/users/{test_user.id}\",\n            json=update_data\n        )\n        assert response.status_code == 401\n\n    async def test_delete_user_superuser(self, async_client: AsyncClient, test_user, superuser_headers):\n        \"\"\"Test deleting user as superuser.\"\"\"\n        response = await async_client.delete(\n            f\"/api/v1/users/{test_user.id}\",\n            headers=superuser_headers\n        )\n        assert response.status_code == 200\n\n    async def test_delete_user_forbidden(self, async_client: AsyncClient, test_user, auth_headers):\n        \"\"\"Test deleting user without superuser privileges.\"\"\"\n        response = await async_client.delete(\n            f\"/api/v1/users/{test_user.id}\",\n            headers=auth_headers\n        )\n        assert response.status_code == 403\n\n\n@pytest.mark.integration\nclass TestAuthAPI:\n    \"\"\"Test Authentication API endpoints.\"\"\"\n\n    async def test_login_success(self, async_client: AsyncClient, test_user):\n        \"\"\"Test successful login.\"\"\"\n        login_data = {\n            \"username\": test_user.username,\n            \"password\": \"testpassword123\"\n        }\n\n        response = await async_client.post(\"/api/v1/auth/login\", data=login_data)\n        assert response.status_code == 200\n\n        data = response.json()\n        assert \"access_token\" in data\n        assert \"refresh_token\" in data\n        assert data[\"token_type\"] == \"bearer\"\n\n    async def test_login_invalid_credentials(self, async_client: AsyncClient, test_user):\n        \"\"\"Test login with invalid credentials.\"\"\"\n        login_data = {\n            \"username\": test_user.username,\n            \"password\": \"wrongpassword\"\n        }\n\n        response = await async_client.post(\"/api/v1/auth/login\", data=login_data)\n        assert response.status_code == 401\n\n    async def test_get_current_user(self, async_client: AsyncClient, test_user, auth_headers):\n        \"\"\"Test getting current user information.\"\"\"\n        response = await async_client.get(\"/api/v1/auth/me\", headers=auth_headers)\n        assert response.status_code == 200\n\n        data = response.json()\n        assert data[\"id\"] == test_user.id\n        assert data[\"username\"] == test_user.username\n\n    async def test_refresh_token(self, async_client: AsyncClient, test_user):\n        \"\"\"Test token refresh.\"\"\"\n        # First login to get refresh token\n        login_data = {\n            \"username\": test_user.username,\n            \"password\": \"testpassword123\"\n        }\n\n        login_response = await async_client.post(\"/api/v1/auth/login\", data=login_data)\n        refresh_token = login_response.json()[\"refresh_token\"]\n\n        # Use refresh token to get new access token\n        refresh_response = await async_client.post(\n            \"/api/v1/auth/refresh\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"}\n        )\n\n        assert refresh_response.status_code == 200\n        data = refresh_response.json()\n        assert \"access_token\" in data\n</code></pre>"},{"location":"user-guide/testing/#running-tests","title":"Running Tests","text":""},{"location":"user-guide/testing/#basic-test-commands","title":"Basic Test Commands","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run specific test categories\nuv run pytest -m unit\nuv run pytest -m integration\nuv run pytest -m api\n\n# Run tests with coverage\nuv run pytest --cov=src --cov-report=html\n\n# Run tests in parallel\nuv run pytest -n auto\n\n# Run specific test file\nuv run pytest tests/test_api_users.py\n\n# Run with verbose output\nuv run pytest -v\n\n# Run tests matching pattern\nuv run pytest -k \"test_user\"\n\n# Run tests and stop on first failure\nuv run pytest -x\n\n# Run slow tests\nuv run pytest -m slow\n</code></pre>"},{"location":"user-guide/testing/#test-environment-setup","title":"Test Environment Setup","text":"<pre><code># Set up test database\ncreatedb test_db\n\n# Run tests with specific environment\nENVIRONMENT=testing uv run pytest\n\n# Run tests with debug output\nuv run pytest -s --log-cli-level=DEBUG\n</code></pre>"},{"location":"user-guide/testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"user-guide/testing/#test-organization","title":"Test Organization","text":"<ul> <li>Separate concerns: Unit tests for business logic, integration tests for API endpoints</li> <li>Use fixtures: Create reusable test data and setup</li> <li>Test isolation: Each test should be independent</li> <li>Clear naming: Test names should describe what they're testing</li> </ul>"},{"location":"user-guide/testing/#test-data","title":"Test Data","text":"<ul> <li>Use factories: Create test data programmatically</li> <li>Avoid hardcoded values: Use variables and constants</li> <li>Clean up: Ensure tests don't leave data behind</li> <li>Realistic data: Use faker or similar libraries for realistic test data</li> </ul>"},{"location":"user-guide/testing/#assertions","title":"Assertions","text":"<ul> <li>Specific assertions: Test specific behaviors, not just \"it works\"</li> <li>Multiple assertions: Test all relevant aspects of the response</li> <li>Error cases: Test error conditions and edge cases</li> <li>Performance: Include performance tests for critical paths</li> </ul>"},{"location":"user-guide/testing/#mocking","title":"Mocking","text":"<pre><code># Example of mocking external dependencies\nfrom unittest.mock import patch, AsyncMock\n\n@pytest.mark.unit\nasync def test_external_api_call():\n    \"\"\"Test function that calls external API.\"\"\"\n    with patch('src.app.services.external_api.make_request') as mock_request:\n        mock_request.return_value = {\"status\": \"success\"}\n\n        result = await some_function_that_calls_external_api()\n\n        assert result[\"status\"] == \"success\"\n        mock_request.assert_called_once()\n</code></pre>"},{"location":"user-guide/testing/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_USER: test_user\n          POSTGRES_PASSWORD: test_pass\n          POSTGRES_DB: test_db\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: 3.11\n\n    - name: Install dependencies\n      run: |\n        pip install uv\n        uv sync\n\n    - name: Run tests\n      run: uv run pytest --cov=src --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n</code></pre> <p>This testing guide provides comprehensive coverage of testing strategies for the FastAPI boilerplate, ensuring reliable and maintainable code. </p>"},{"location":"user-guide/api/","title":"API Development","text":"<p>Learn how to build REST APIs with the FastAPI Boilerplate. This section covers everything you need to create robust, production-ready APIs.</p>"},{"location":"user-guide/api/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Endpoints - Create CRUD endpoints with authentication and validation</li> <li>Pagination - Add pagination to handle large datasets</li> <li>Exception Handling - Handle errors properly with built-in exceptions</li> <li>API Versioning - Version your APIs and maintain backward compatibility</li> <li>Database Integration - Use the boilerplate's CRUD layer and schemas</li> </ul>"},{"location":"user-guide/api/#quick-overview","title":"Quick Overview","text":"<p>The boilerplate provides everything you need for API development:</p> <pre><code>from fastapi import APIRouter, Depends\nfrom app.crud.crud_users import crud_users\nfrom app.schemas.user import UserRead, UserCreate\nfrom app.core.db.database import async_get_db\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n@router.get(\"/\", response_model=list[UserRead])\nasync def get_users(db: Annotated[AsyncSession, Depends(async_get_db)]):\n    users = await crud_users.get_multi(db=db, schema_to_select=UserRead)\n    return users[\"data\"]\n\n@router.post(\"/\", response_model=UserRead, status_code=201)\nasync def create_user(\n    user_data: UserCreate,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    return await crud_users.create(db=db, object=user_data)\n</code></pre>"},{"location":"user-guide/api/#key-features","title":"Key Features","text":""},{"location":"user-guide/api/#built-in-authentication","title":"\ud83d\udd10 Built-in Authentication","text":"<p>Add authentication to any endpoint: <pre><code>from app.api.dependencies import get_current_user\n\n@router.get(\"/me\", response_model=UserRead)\nasync def get_profile(current_user: Annotated[dict, Depends(get_current_user)]):\n    return current_user\n</code></pre></p>"},{"location":"user-guide/api/#easy-pagination","title":"\ud83d\udcca Easy Pagination","text":"<p>Paginate any endpoint with one line: <pre><code>from fastcrud.paginated import PaginatedListResponse\n\n@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(page: int = 1, items_per_page: int = 10):\n    # Add pagination to any endpoint\n</code></pre></p>"},{"location":"user-guide/api/#automatic-validation","title":"\u2705 Automatic Validation","text":"<p>Request and response validation is handled automatically: <pre><code>@router.post(\"/\", response_model=UserRead)\nasync def create_user(user_data: UserCreate):  # \u2190 Validates input\n    return await crud_users.create(object=user_data)  # \u2190 Validates output\n</code></pre></p>"},{"location":"user-guide/api/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":"<p>Use built-in exceptions for consistent error responses: <pre><code>from app.core.exceptions.http_exceptions import NotFoundException\n\n@router.get(\"/{user_id}\")\nasync def get_user(user_id: int):\n    user = await crud_users.get(id=user_id)\n    if not user:\n        raise NotFoundException(\"User not found\")  # Returns proper 404\n    return user\n</code></pre></p>"},{"location":"user-guide/api/#architecture","title":"Architecture","text":"<p>The boilerplate follows a layered architecture:</p> <pre><code>API Endpoint\n    \u2193\nPydantic Schema (validation)\n    \u2193\nCRUD Layer (database operations)\n    \u2193\nSQLAlchemy Model (database)\n</code></pre> <p>This separation makes your code: - Testable - Mock any layer easily - Maintainable - Clear separation of concerns - Scalable - Add features without breaking existing code</p>"},{"location":"user-guide/api/#directory-structure","title":"Directory Structure","text":"<pre><code>src/app/api/\n\u251c\u2500\u2500 dependencies.py          # Shared dependencies (auth, rate limiting)\n\u2514\u2500\u2500 v1/                     # API version 1\n    \u251c\u2500\u2500 users.py           # User endpoints\n    \u251c\u2500\u2500 posts.py           # Post endpoints\n    \u251c\u2500\u2500 login.py           # Authentication\n    \u2514\u2500\u2500 ...                # Other endpoints\n</code></pre>"},{"location":"user-guide/api/#whats-next","title":"What's Next","text":"<p>Start with the basics:</p> <ol> <li>Endpoints - Learn the common patterns for creating API endpoints</li> <li>Pagination - Add pagination to handle large datasets</li> <li>Exception Handling - Handle errors properly with built-in exceptions</li> <li>API Versioning - Version your APIs and maintain backward compatibility</li> </ol> <p>Then dive deeper into the foundation: 5. Database Schemas - Create schemas for your data 6. CRUD Operations - Understand the database layer</p> <p>Each guide builds on the previous one with practical examples you can use immediately. </p>"},{"location":"user-guide/api/endpoints/","title":"API Endpoints","text":"<p>This guide shows you how to create API endpoints using the boilerplate's established patterns. You'll learn the common patterns you need for building CRUD APIs.</p>"},{"location":"user-guide/api/endpoints/#quick-start","title":"Quick Start","text":"<p>Here's how to create a typical endpoint using the boilerplate's patterns:</p> <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom typing import Annotated\n\nfrom app.core.db.database import async_get_db\nfrom app.crud.crud_users import crud_users\nfrom app.schemas.user import UserRead, UserCreate\nfrom app.api.dependencies import get_current_user\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\n\n@router.get(\"/{user_id}\", response_model=UserRead)\nasync def get_user(\n    user_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    \"\"\"Get a user by ID.\"\"\"\n    user = await crud_users.get(db=db, id=user_id, schema_to_select=UserRead)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n</code></pre> <p>That's it! The boilerplate handles the rest.</p>"},{"location":"user-guide/api/endpoints/#common-endpoint-patterns","title":"Common Endpoint Patterns","text":""},{"location":"user-guide/api/endpoints/#1-get-single-item","title":"1. Get Single Item","text":"<pre><code>@router.get(\"/{user_id}\", response_model=UserRead)\nasync def get_user(\n    user_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    user = await crud_users.get(db=db, id=user_id, schema_to_select=UserRead)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n</code></pre>"},{"location":"user-guide/api/endpoints/#2-get-multiple-items-with-pagination","title":"2. Get Multiple Items (with Pagination)","text":"<pre><code>from fastcrud.paginated import PaginatedListResponse\n\n@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(\n    page: int = 1,\n    items_per_page: int = 10,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page,\n        schema_to_select=UserRead,\n        return_as_model=True,\n        return_total_count=True\n    )\n\n    return paginated_response(\n        crud_data=users,\n        page=page, \n        items_per_page=items_per_page\n    )\n</code></pre>"},{"location":"user-guide/api/endpoints/#3-create-item","title":"3. Create Item","text":"<pre><code>@router.post(\"/\", response_model=UserRead, status_code=201)\nasync def create_user(\n    user_data: UserCreate,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Check if user already exists\n    if await crud_users.exists(db=db, email=user_data.email):\n        raise HTTPException(status_code=409, detail=\"Email already exists\")\n\n    # Create user\n    new_user = await crud_users.create(db=db, object=user_data)\n    return new_user\n</code></pre>"},{"location":"user-guide/api/endpoints/#4-update-item","title":"4. Update Item","text":"<pre><code>@router.patch(\"/{user_id}\", response_model=UserRead)\nasync def update_user(\n    user_id: int,\n    user_data: UserUpdate,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Check if user exists\n    if not await crud_users.exists(db=db, id=user_id):\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Update user\n    updated_user = await crud_users.update(db=db, object=user_data, id=user_id)\n    return updated_user\n</code></pre>"},{"location":"user-guide/api/endpoints/#5-delete-item-soft-delete","title":"5. Delete Item (Soft Delete)","text":"<pre><code>@router.delete(\"/{user_id}\")\nasync def delete_user(\n    user_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    if not await crud_users.exists(db=db, id=user_id):\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    await crud_users.delete(db=db, id=user_id)\n    return {\"message\": \"User deleted\"}\n</code></pre>"},{"location":"user-guide/api/endpoints/#adding-authentication","title":"Adding Authentication","text":"<p>To require login, add the <code>get_current_user</code> dependency:</p> <pre><code>@router.get(\"/me\", response_model=UserRead)  \nasync def get_my_profile(\n    current_user: Annotated[dict, Depends(get_current_user)]\n):\n    \"\"\"Get current user's profile.\"\"\"\n    return current_user\n\n@router.post(\"/\", response_model=UserRead)\nasync def create_user(\n    user_data: UserCreate,\n    current_user: Annotated[dict, Depends(get_current_user)],  # Requires login\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Only logged-in users can create users\n    new_user = await crud_users.create(db=db, object=user_data)\n    return new_user\n</code></pre>"},{"location":"user-guide/api/endpoints/#adding-admin-only-endpoints","title":"Adding Admin-Only Endpoints","text":"<p>For admin-only endpoints, use <code>get_current_superuser</code>:</p> <pre><code>from app.api.dependencies import get_current_superuser\n\n@router.delete(\"/{user_id}/permanent\", dependencies=[Depends(get_current_superuser)])\nasync def permanently_delete_user(\n    user_id: int,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    \"\"\"Admin-only: Permanently delete user from database.\"\"\"\n    await crud_users.db_delete(db=db, id=user_id)\n    return {\"message\": \"User permanently deleted\"}\n</code></pre>"},{"location":"user-guide/api/endpoints/#query-parameters","title":"Query Parameters","text":""},{"location":"user-guide/api/endpoints/#simple-parameters","title":"Simple Parameters","text":"<pre><code>@router.get(\"/search\")\nasync def search_users(\n    name: str | None = None,        # Optional string\n    age: int | None = None,         # Optional integer  \n    is_active: bool = True,         # Boolean with default\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    filters = {\"is_active\": is_active}\n    if name:\n        filters[\"name\"] = name\n    if age:\n        filters[\"age\"] = age\n\n    users = await crud_users.get_multi(db=db, **filters)\n    return users[\"data\"]\n</code></pre>"},{"location":"user-guide/api/endpoints/#parameters-with-validation","title":"Parameters with Validation","text":"<pre><code>from fastapi import Query\n\n@router.get(\"/\")\nasync def get_users(\n    page: Annotated[int, Query(ge=1)] = 1,                    # Must be &gt;= 1\n    limit: Annotated[int, Query(ge=1, le=100)] = 10,          # Between 1-100\n    search: Annotated[str | None, Query(max_length=50)] = None, # Max 50 chars\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Use the validated parameters\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * limit,\n        limit=limit\n    )\n    return users[\"data\"]\n</code></pre>"},{"location":"user-guide/api/endpoints/#error-handling","title":"Error Handling","text":"<p>The boilerplate includes custom exceptions you can use:</p> <pre><code>from app.core.exceptions.http_exceptions import (\n    NotFoundException, \n    DuplicateValueException,\n    ForbiddenException\n)\n\n@router.get(\"/{user_id}\")\nasync def get_user(user_id: int, db: AsyncSession):\n    user = await crud_users.get(db=db, id=user_id)\n    if not user:\n        raise NotFoundException(\"User not found\")  # Returns 404\n    return user\n\n@router.post(\"/\")\nasync def create_user(user_data: UserCreate, db: AsyncSession):\n    if await crud_users.exists(db=db, email=user_data.email):\n        raise DuplicateValueException(\"Email already exists\")  # Returns 409\n\n    return await crud_users.create(db=db, object=user_data)\n</code></pre>"},{"location":"user-guide/api/endpoints/#file-uploads","title":"File Uploads","text":"<pre><code>from fastapi import UploadFile, File\n\n@router.post(\"/{user_id}/avatar\")\nasync def upload_avatar(\n    user_id: int,\n    file: UploadFile = File(...),\n    current_user: Annotated[dict, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Check file type\n    if not file.content_type.startswith('image/'):\n        raise HTTPException(status_code=400, detail=\"File must be an image\")\n\n    # Save file and update user\n    # ... file handling logic ...\n\n    return {\"message\": \"Avatar uploaded successfully\"}\n</code></pre>"},{"location":"user-guide/api/endpoints/#creating-new-endpoints","title":"Creating New Endpoints","text":""},{"location":"user-guide/api/endpoints/#step-1-create-the-router-file","title":"Step 1: Create the Router File","text":"<p>Create <code>src/app/api/v1/posts.py</code>:</p> <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom typing import Annotated\n\nfrom app.core.db.database import async_get_db\nfrom app.crud.crud_posts import crud_posts  # You'll create this\nfrom app.schemas.post import PostRead, PostCreate, PostUpdate  # You'll create these\nfrom app.api.dependencies import get_current_user\n\nrouter = APIRouter(prefix=\"/posts\", tags=[\"posts\"])\n\n@router.get(\"/\", response_model=list[PostRead])\nasync def get_posts(db: Annotated[AsyncSession, Depends(async_get_db)]):\n    posts = await crud_posts.get_multi(db=db, schema_to_select=PostRead)\n    return posts[\"data\"]\n\n@router.post(\"/\", response_model=PostRead, status_code=201)\nasync def create_post(\n    post_data: PostCreate,\n    current_user: Annotated[dict, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Add current user as post author\n    post_dict = post_data.model_dump()\n    post_dict[\"author_id\"] = current_user[\"id\"]\n\n    new_post = await crud_posts.create(db=db, object=post_dict)\n    return new_post\n</code></pre>"},{"location":"user-guide/api/endpoints/#step-2-register-the-router","title":"Step 2: Register the Router","text":"<p>In <code>src/app/api/v1/__init__.py</code>, add:</p> <pre><code>from .posts import router as posts_router\n\napi_router.include_router(posts_router)\n</code></pre>"},{"location":"user-guide/api/endpoints/#step-3-test-your-endpoints","title":"Step 3: Test Your Endpoints","text":"<p>Your new endpoints will be available at: - <code>GET /api/v1/posts/</code> - Get all posts - <code>POST /api/v1/posts/</code> - Create new post (requires login)</p>"},{"location":"user-guide/api/endpoints/#best-practices","title":"Best Practices","text":"<ol> <li>Always use the database dependency: <code>Depends(async_get_db)</code></li> <li>Use existing CRUD methods: <code>crud_users.get()</code>, <code>crud_users.create()</code>, etc.</li> <li>Check if items exist before operations: Use <code>crud_users.exists()</code></li> <li>Use proper HTTP status codes: <code>status_code=201</code> for creation</li> <li>Add authentication when needed: <code>Depends(get_current_user)</code></li> <li>Use response models: <code>response_model=UserRead</code></li> <li>Handle errors with custom exceptions: <code>NotFoundException</code>, <code>DuplicateValueException</code></li> </ol>"},{"location":"user-guide/api/endpoints/#whats-next","title":"What's Next","text":"<p>Now that you understand basic endpoints:</p> <ul> <li>Pagination - Add pagination to your endpoints</li> <li>Database Schemas - Create schemas for your data</li> <li>CRUD Operations - Understand the CRUD layer</li> </ul> <p>The boilerplate provides everything you need - just follow these patterns! </p>"},{"location":"user-guide/api/exceptions/","title":"API Exception Handling","text":"<p>Learn how to handle errors properly in your API endpoints using the boilerplate's built-in exceptions and patterns.</p>"},{"location":"user-guide/api/exceptions/#quick-start","title":"Quick Start","text":"<p>The boilerplate provides ready-to-use exceptions that return proper HTTP status codes:</p> <pre><code>from app.core.exceptions.http_exceptions import NotFoundException\n\n@router.get(\"/{user_id}\")\nasync def get_user(user_id: int, db: AsyncSession):\n    user = await crud_users.get(db=db, id=user_id)\n    if not user:\n        raise NotFoundException(\"User not found\")  # Returns 404\n    return user\n</code></pre> <p>That's it! The exception automatically becomes a proper JSON error response.</p>"},{"location":"user-guide/api/exceptions/#built-in-exceptions","title":"Built-in Exceptions","text":"<p>The boilerplate includes common HTTP exceptions you'll need:</p>"},{"location":"user-guide/api/exceptions/#notfoundexception-404","title":"NotFoundException (404)","text":"<pre><code>from app.core.exceptions.http_exceptions import NotFoundException\n\n@router.get(\"/{user_id}\")\nasync def get_user(user_id: int):\n    user = await crud_users.get(db=db, id=user_id)\n    if not user:\n        raise NotFoundException(\"User not found\")\n    return user\n\n# Returns:\n# Status: 404\n# {\"detail\": \"User not found\"}\n</code></pre>"},{"location":"user-guide/api/exceptions/#duplicatevalueexception-409","title":"DuplicateValueException (409)","text":"<pre><code>from app.core.exceptions.http_exceptions import DuplicateValueException\n\n@router.post(\"/\")\nasync def create_user(user_data: UserCreate):\n    if await crud_users.exists(db=db, email=user_data.email):\n        raise DuplicateValueException(\"Email already exists\")\n\n    return await crud_users.create(db=db, object=user_data)\n\n# Returns:\n# Status: 409\n# {\"detail\": \"Email already exists\"}\n</code></pre>"},{"location":"user-guide/api/exceptions/#forbiddenexception-403","title":"ForbiddenException (403)","text":"<pre><code>from app.core.exceptions.http_exceptions import ForbiddenException\n\n@router.delete(\"/{user_id}\")\nasync def delete_user(\n    user_id: int,\n    current_user: Annotated[dict, Depends(get_current_user)]\n):\n    if current_user[\"id\"] != user_id and not current_user[\"is_superuser\"]:\n        raise ForbiddenException(\"You can only delete your own account\")\n\n    await crud_users.delete(db=db, id=user_id)\n    return {\"message\": \"User deleted\"}\n\n# Returns:\n# Status: 403\n# {\"detail\": \"You can only delete your own account\"}\n</code></pre>"},{"location":"user-guide/api/exceptions/#unauthorizedexception-401","title":"UnauthorizedException (401)","text":"<pre><code>from app.core.exceptions.http_exceptions import UnauthorizedException\n\n# This is typically used in the auth system, but you can use it too:\n@router.get(\"/admin-only\")\nasync def admin_endpoint():\n    # Some validation logic\n    if not user_is_admin:\n        raise UnauthorizedException(\"Admin access required\")\n\n    return {\"data\": \"secret admin data\"}\n\n# Returns:\n# Status: 401\n# {\"detail\": \"Admin access required\"}\n</code></pre>"},{"location":"user-guide/api/exceptions/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/api/exceptions/#check-before-create","title":"Check Before Create","text":"<pre><code>@router.post(\"/\", response_model=UserRead)\nasync def create_user(user_data: UserCreate, db: AsyncSession):\n    # Check email\n    if await crud_users.exists(db=db, email=user_data.email):\n        raise DuplicateValueException(\"Email already exists\")\n\n    # Check username  \n    if await crud_users.exists(db=db, username=user_data.username):\n        raise DuplicateValueException(\"Username already taken\")\n\n    # Create user\n    return await crud_users.create(db=db, object=user_data)\n\n# For public registration endpoints, consider rate limiting\n# to prevent email enumeration attacks\n</code></pre>"},{"location":"user-guide/api/exceptions/#check-before-update","title":"Check Before Update","text":"<pre><code>@router.patch(\"/{user_id}\", response_model=UserRead)\nasync def update_user(\n    user_id: int,\n    user_data: UserUpdate,\n    db: AsyncSession\n):\n    # Check if user exists\n    if not await crud_users.exists(db=db, id=user_id):\n        raise NotFoundException(\"User not found\")\n\n    # Check for email conflicts (if email is being updated)\n    if user_data.email:\n        existing = await crud_users.get(db=db, email=user_data.email)\n        if existing and existing.id != user_id:\n            raise DuplicateValueException(\"Email already taken\")\n\n    # Update user\n    return await crud_users.update(db=db, object=user_data, id=user_id)\n</code></pre>"},{"location":"user-guide/api/exceptions/#check-ownership","title":"Check Ownership","text":"<pre><code>@router.get(\"/{post_id}\")\nasync def get_post(\n    post_id: int,\n    current_user: Annotated[dict, Depends(get_current_user)],\n    db: AsyncSession\n):\n    post = await crud_posts.get(db=db, id=post_id)\n    if not post:\n        raise NotFoundException(\"Post not found\")\n\n    # Check if user owns the post or is admin\n    if post.author_id != current_user[\"id\"] and not current_user[\"is_superuser\"]:\n        raise ForbiddenException(\"You can only view your own posts\")\n\n    return post\n</code></pre>"},{"location":"user-guide/api/exceptions/#validation-errors","title":"Validation Errors","text":"<p>FastAPI automatically handles Pydantic validation errors, but you can catch and customize them:</p> <pre><code>from fastapi import HTTPException\nfrom pydantic import ValidationError\n\n@router.post(\"/\")\nasync def create_user(user_data: UserCreate):\n    try:\n        # If user_data fails validation, Pydantic raises ValidationError\n        # FastAPI automatically converts this to a 422 response\n        return await crud_users.create(db=db, object=user_data)\n    except ValidationError as e:\n        # You can catch and customize if needed\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid data: {e.errors()}\"\n        )\n</code></pre>"},{"location":"user-guide/api/exceptions/#standard-http-exceptions","title":"Standard HTTP Exceptions","text":"<p>For other status codes, use FastAPI's HTTPException:</p> <pre><code>from fastapi import HTTPException\n\n# Bad Request (400)\n@router.post(\"/\")\nasync def create_something(data: dict):\n    if not data.get(\"required_field\"):\n        raise HTTPException(\n            status_code=400,\n            detail=\"required_field is missing\"\n        )\n\n# Too Many Requests (429)\n@router.post(\"/\")\nasync def rate_limited_endpoint():\n    if rate_limit_exceeded():\n        raise HTTPException(\n            status_code=429,\n            detail=\"Rate limit exceeded. Try again later.\"\n        )\n\n# Internal Server Error (500)\n@router.get(\"/\")\nasync def risky_endpoint():\n    try:\n        # Some operation that might fail\n        result = risky_operation()\n        return result\n    except Exception as e:\n        # Log the error\n        logger.error(f\"Unexpected error: {e}\")\n        raise HTTPException(\n            status_code=500,\n            detail=\"An unexpected error occurred\"\n        )\n</code></pre>"},{"location":"user-guide/api/exceptions/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":"<p>If you need custom exceptions, follow the boilerplate's pattern:</p> <pre><code># In app/core/exceptions/http_exceptions.py (add to existing file)\nfrom fastapi import HTTPException\n\nclass PaymentRequiredException(HTTPException):\n    \"\"\"402 Payment Required\"\"\"\n    def __init__(self, detail: str = \"Payment required\"):\n        super().__init__(status_code=402, detail=detail)\n\nclass TooManyRequestsException(HTTPException):\n    \"\"\"429 Too Many Requests\"\"\"\n    def __init__(self, detail: str = \"Too many requests\"):\n        super().__init__(status_code=429, detail=detail)\n\n# Use them in your endpoints\nfrom app.core.exceptions.http_exceptions import PaymentRequiredException\n\n@router.get(\"/premium-feature\")\nasync def premium_feature(current_user: dict):\n    if current_user[\"tier\"] == \"free\":\n        raise PaymentRequiredException(\"Upgrade to access this feature\")\n\n    return {\"data\": \"premium content\"}\n</code></pre>"},{"location":"user-guide/api/exceptions/#error-response-format","title":"Error Response Format","text":"<p>All exceptions return consistent JSON responses:</p> <pre><code>{\n    \"detail\": \"Error message here\"\n}\n</code></pre> <p>For validation errors (422), you get more detail:</p> <pre><code>{\n    \"detail\": [\n        {\n            \"type\": \"missing\",\n            \"loc\": [\"body\", \"email\"],\n            \"msg\": \"Field required\",\n            \"input\": null\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/api/exceptions/#global-exception-handling","title":"Global Exception Handling","text":"<p>The boilerplate includes global exception handlers. You can add your own in <code>main.py</code>:</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(ValueError)\nasync def value_error_handler(request: Request, exc: ValueError):\n    \"\"\"Handle ValueError exceptions globally\"\"\"\n    return JSONResponse(\n        status_code=400,\n        content={\"detail\": f\"Invalid value: {str(exc)}\"}\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(request: Request, exc: Exception):\n    \"\"\"Catch-all exception handler\"\"\"\n    # Log the error\n    logger.error(f\"Unhandled exception: {exc}\")\n\n    return JSONResponse(\n        status_code=500,\n        content={\"detail\": \"An unexpected error occurred\"}\n    )\n</code></pre>"},{"location":"user-guide/api/exceptions/#security-considerations","title":"Security Considerations","text":""},{"location":"user-guide/api/exceptions/#authentication-endpoints-use-generic-messages","title":"Authentication Endpoints - Use Generic Messages","text":"<p>For security, authentication endpoints should use generic error messages to prevent information disclosure:</p> <pre><code># SECURITY: Don't reveal if username exists\n@router.post(\"/login\")\nasync def login(credentials: LoginCredentials):\n    user = await crud_users.get(db=db, username=credentials.username)\n\n    # Don't do this - reveals if username exists\n    # if not user:\n    #     raise NotFoundException(\"User not found\")\n    # if not verify_password(credentials.password, user.hashed_password):\n    #     raise UnauthorizedException(\"Invalid password\")\n\n    # Do this - generic message for all auth failures\n    if not user or not verify_password(credentials.password, user.hashed_password):\n        raise UnauthorizedException(\"Invalid username or password\")\n\n    return create_access_token(user.id)\n\n# SECURITY: Don't reveal if email is registered during password reset\n@router.post(\"/forgot-password\")\nasync def forgot_password(email: str):\n    user = await crud_users.get(db=db, email=email)\n\n    # Don't do this - reveals if email exists\n    # if not user:\n    #     raise NotFoundException(\"Email not found\")\n\n    # Do this - always return success message\n    if user:\n        await send_password_reset_email(user.email)\n\n    # Always return the same message\n    return {\"message\": \"If the email exists, a reset link has been sent\"}\n</code></pre>"},{"location":"user-guide/api/exceptions/#resource-access-be-specific-when-safe","title":"Resource Access - Be Specific When Safe","text":"<p>For non-auth operations, specific messages help developers:</p> <pre><code># Safe to be specific for resource operations\n@router.get(\"/{post_id}\")\nasync def get_post(\n    post_id: int,\n    current_user: Annotated[dict, Depends(get_current_user)]\n):\n    post = await crud_posts.get(db=db, id=post_id)\n    if not post:\n        raise NotFoundException(\"Post not found\")  # Safe to be specific\n\n    if post.author_id != current_user[\"id\"]:\n        # Don't reveal post exists if user can't access it\n        raise NotFoundException(\"Post not found\")  # Generic, not \"Access denied\"\n\n    return post\n</code></pre>"},{"location":"user-guide/api/exceptions/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/api/exceptions/#1-use-specific-exceptions-when-safe","title":"1. Use Specific Exceptions (When Safe)","text":"<pre><code># Good for non-sensitive operations\nif not user:\n    raise NotFoundException(\"User not found\")\n\n# Good for validation errors\nraise DuplicateValueException(\"Username already taken\")\n</code></pre>"},{"location":"user-guide/api/exceptions/#2-use-generic-messages-for-security","title":"2. Use Generic Messages for Security","text":"<pre><code># Good for authentication\nraise UnauthorizedException(\"Invalid username or password\")\n\n# Good for authorization (don't reveal resource exists)\nraise NotFoundException(\"Resource not found\")  # Instead of \"Access denied\"\n</code></pre>"},{"location":"user-guide/api/exceptions/#3-check-permissions-early","title":"3. Check Permissions Early","text":"<pre><code>@router.delete(\"/{user_id}\")\nasync def delete_user(\n    user_id: int,\n    current_user: Annotated[dict, Depends(get_current_user)]\n):\n    # Check permission first\n    if current_user[\"id\"] != user_id:\n        raise ForbiddenException(\"Cannot delete other users\")\n\n    # Then check if user exists\n    if not await crud_users.exists(db=db, id=user_id):\n        raise NotFoundException(\"User not found\")\n\n    await crud_users.delete(db=db, id=user_id)\n</code></pre>"},{"location":"user-guide/api/exceptions/#4-log-important-errors","title":"4. Log Important Errors","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\n@router.post(\"/\")\nasync def create_user(user_data: UserCreate):\n    try:\n        return await crud_users.create(db=db, object=user_data)\n    except Exception as e:\n        logger.error(f\"Failed to create user: {e}\")\n        raise HTTPException(status_code=500, detail=\"User creation failed\")\n</code></pre>"},{"location":"user-guide/api/exceptions/#testing-exceptions","title":"Testing Exceptions","text":"<p>Test that your endpoints raise the right exceptions:</p> <pre><code>import pytest\nfrom httpx import AsyncClient\n\n@pytest.mark.asyncio\nasync def test_user_not_found(client: AsyncClient):\n    response = await client.get(\"/api/v1/users/99999\")\n    assert response.status_code == 404\n    assert \"User not found\" in response.json()[\"detail\"]\n\n@pytest.mark.asyncio\nasync def test_duplicate_email(client: AsyncClient):\n    # Create a user\n    await client.post(\"/api/v1/users/\", json={\n        \"name\": \"Test User\",\n        \"username\": \"test1\",\n        \"email\": \"test@example.com\",\n        \"password\": \"Password123!\"\n    })\n\n    # Try to create another with same email\n    response = await client.post(\"/api/v1/users/\", json={\n        \"name\": \"Test User 2\",\n        \"username\": \"test2\", \n        \"email\": \"test@example.com\",  # Same email\n        \"password\": \"Password123!\"\n    })\n\n    assert response.status_code == 409\n    assert \"Email already exists\" in response.json()[\"detail\"]\n</code></pre>"},{"location":"user-guide/api/exceptions/#whats-next","title":"What's Next","text":"<p>Now that you understand error handling: - Versioning - Learn how to version your APIs - Database CRUD - Understand the database operations - Authentication - Add user authentication to your APIs</p> <p>Proper error handling makes your API much more user-friendly and easier to debug! </p>"},{"location":"user-guide/api/pagination/","title":"API Pagination","text":"<p>This guide shows you how to add pagination to your API endpoints using the boilerplate's built-in utilities. Pagination helps you handle large datasets efficiently.</p>"},{"location":"user-guide/api/pagination/#quick-start","title":"Quick Start","text":"<p>Here's how to add basic pagination to any endpoint:</p> <pre><code>from fastcrud.paginated import PaginatedListResponse\n\n@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(\n    page: int = 1,\n    items_per_page: int = 10,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page,\n        schema_to_select=UserRead,\n        return_as_model=True,\n        return_total_count=True\n    )\n\n    return paginated_response(\n        crud_data=users,\n        page=page,\n        items_per_page=items_per_page\n    )\n</code></pre> <p>That's it! Your endpoint now returns paginated results with metadata.</p>"},{"location":"user-guide/api/pagination/#what-you-get","title":"What You Get","text":"<p>The response includes everything frontends need:</p> <pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"John Doe\",\n            \"username\": \"johndoe\",\n            \"email\": \"john@example.com\"\n        }\n        // ... more users\n    ],\n    \"total_count\": 150,\n    \"has_more\": true,\n    \"page\": 1,\n    \"items_per_page\": 10,\n    \"total_pages\": 15\n}\n</code></pre>"},{"location":"user-guide/api/pagination/#adding-filters","title":"Adding Filters","text":"<p>You can easily add filtering to paginated endpoints:</p> <pre><code>@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(\n    page: int = 1,\n    items_per_page: int = 10,\n    # Add filter parameters\n    search: str | None = None,\n    is_active: bool | None = None,\n    tier_id: int | None = None,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Build filters\n    filters = {}\n    if search:\n        filters[\"name__icontains\"] = search  # Search by name\n    if is_active is not None:\n        filters[\"is_active\"] = is_active\n    if tier_id:\n        filters[\"tier_id\"] = tier_id\n\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page,\n        schema_to_select=UserRead,\n        return_as_model=True,\n        return_total_count=True,\n        **filters\n    )\n\n    return paginated_response(\n        crud_data=users,\n        page=page,\n        items_per_page=items_per_page\n    )\n</code></pre> <p>Now you can call:</p> <ul> <li><code>/users/?search=john</code> - Find users with \"john\" in their name</li> <li><code>/users/?is_active=true</code> - Only active users</li> <li><code>/users/?tier_id=1&amp;page=2</code> - Users in tier 1, page 2</li> </ul>"},{"location":"user-guide/api/pagination/#adding-sorting","title":"Adding Sorting","text":"<p>Add sorting options to your paginated endpoints:</p> <pre><code>@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(\n    page: int = 1,\n    items_per_page: int = 10,\n    # Add sorting parameters\n    sort_by: str = \"created_at\",\n    sort_order: str = \"desc\",\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page,\n        schema_to_select=UserRead,\n        return_as_model=True,\n        return_total_count=True,\n        sort_columns=sort_by,\n        sort_orders=sort_order\n    )\n\n    return paginated_response(\n        crud_data=users,\n        page=page,\n        items_per_page=items_per_page\n    )\n</code></pre> <p>Usage:</p> <ul> <li><code>/users/?sort_by=name&amp;sort_order=asc</code> - Sort by name A-Z</li> <li><code>/users/?sort_by=created_at&amp;sort_order=desc</code> - Newest first</li> </ul>"},{"location":"user-guide/api/pagination/#validation","title":"Validation","text":"<p>Add validation to prevent issues:</p> <pre><code>from fastapi import Query\n\n@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(\n    page: Annotated[int, Query(ge=1)] = 1,                    # Must be &gt;= 1\n    items_per_page: Annotated[int, Query(ge=1, le=100)] = 10, # Between 1-100\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Your pagination logic here\n</code></pre>"},{"location":"user-guide/api/pagination/#complete-example","title":"Complete Example","text":"<p>Here's a full-featured paginated endpoint:</p> <pre><code>@router.get(\"/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(\n    # Pagination\n    page: Annotated[int, Query(ge=1)] = 1,\n    items_per_page: Annotated[int, Query(ge=1, le=100)] = 10,\n\n    # Filtering\n    search: Annotated[str | None, Query(max_length=100)] = None,\n    is_active: bool | None = None,\n    tier_id: int | None = None,\n\n    # Sorting\n    sort_by: str = \"created_at\",\n    sort_order: str = \"desc\",\n\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    \"\"\"Get paginated users with filtering and sorting.\"\"\"\n\n    # Build filters\n    filters = {\"is_deleted\": False}  # Always exclude deleted users\n\n    if is_active is not None:\n        filters[\"is_active\"] = is_active\n    if tier_id:\n        filters[\"tier_id\"] = tier_id\n\n    # Handle search\n    search_criteria = []\n    if search:\n        from sqlalchemy import or_, func\n        search_criteria = [\n            or_(\n                func.lower(User.name).contains(search.lower()),\n                func.lower(User.username).contains(search.lower()),\n                func.lower(User.email).contains(search.lower())\n            )\n        ]\n\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page,\n        schema_to_select=UserRead,\n        return_as_model=True,\n        return_total_count=True,\n        sort_columns=sort_by,\n        sort_orders=sort_order,\n        **filters,\n        **{\"filter_criteria\": search_criteria} if search_criteria else {}\n    )\n\n    return paginated_response(\n        crud_data=users,\n        page=page,\n        items_per_page=items_per_page\n    )\n</code></pre> <p>This endpoint supports:</p> <ul> <li><code>/users/</code> - First 10 users</li> <li><code>/users/?page=2&amp;items_per_page=20</code> - Page 2, 20 items</li> <li><code>/users/?search=john&amp;is_active=true</code> - Active users named john</li> <li><code>/users/?sort_by=name&amp;sort_order=asc</code> - Sorted by name</li> </ul>"},{"location":"user-guide/api/pagination/#simple-list-no-pagination","title":"Simple List (No Pagination)","text":"<p>Sometimes you just want a simple list without pagination:</p> <pre><code>@router.get(\"/all\", response_model=list[UserRead])\nasync def get_all_users(\n    limit: int = 100,  # Prevent too many results\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    users = await crud_users.get_multi(\n        db=db,\n        limit=limit,\n        schema_to_select=UserRead,\n        return_as_model=True\n    )\n    return users[\"data\"]\n</code></pre>"},{"location":"user-guide/api/pagination/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Always set a maximum page size: <pre><code>items_per_page: Annotated[int, Query(ge=1, le=100)] = 10  # Max 100 items\n</code></pre></p> </li> <li> <p>Use <code>schema_to_select</code> to only fetch needed fields: <pre><code>users = await crud_users.get_multi(\n    schema_to_select=UserRead,  # Only fetch UserRead fields\n    return_as_model=True\n)\n</code></pre></p> </li> <li> <p>Add database indexes for columns you sort by: <pre><code>-- In your migration\nCREATE INDEX idx_users_created_at ON users(created_at);\nCREATE INDEX idx_users_name ON users(name);\n</code></pre></p> </li> </ol>"},{"location":"user-guide/api/pagination/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/api/pagination/#admin-list-with-all-users","title":"Admin List with All Users","text":"<pre><code>@router.get(\"/admin\", dependencies=[Depends(get_current_superuser)])\nasync def get_all_users_admin(\n    include_deleted: bool = False,\n    page: int = 1,\n    items_per_page: int = 50,\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    filters = {}\n    if not include_deleted:\n        filters[\"is_deleted\"] = False\n\n    users = await crud_users.get_multi(db=db, **filters)\n    return paginated_response(users, page, items_per_page)\n</code></pre>"},{"location":"user-guide/api/pagination/#users-own-items","title":"User's Own Items","text":"<pre><code>@router.get(\"/my-posts\", response_model=PaginatedListResponse[PostRead])\nasync def get_my_posts(\n    page: int = 1,\n    items_per_page: int = 10,\n    current_user: Annotated[dict, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    posts = await crud_posts.get_multi(\n        db=db,\n        author_id=current_user[\"id\"],  # Only user's own posts\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page\n    )\n    return paginated_response(posts, page, items_per_page)\n</code></pre>"},{"location":"user-guide/api/pagination/#whats-next","title":"What's Next","text":"<p>Now that you understand pagination:</p> <ul> <li>Database CRUD - Learn more about the CRUD operations</li> <li>Database Schemas - Create schemas for your data</li> <li>Authentication - Add user authentication to your endpoints</li> </ul> <p>The boilerplate makes pagination simple - just use these patterns! </p>"},{"location":"user-guide/api/versioning/","title":"API Versioning","text":"<p>Learn how to version your APIs properly using the boilerplate's built-in versioning structure and best practices for maintaining backward compatibility.</p>"},{"location":"user-guide/api/versioning/#quick-start","title":"Quick Start","text":"<p>The boilerplate is already set up for versioning with a <code>v1</code> structure:</p> <pre><code>src/app/api/\n\u251c\u2500\u2500 dependencies.py          # Shared across all versions\n\u2514\u2500\u2500 v1/                     # Version 1 of your API\n    \u251c\u2500\u2500 __init__.py         # Router registration\n    \u251c\u2500\u2500 users.py           # User endpoints\n    \u251c\u2500\u2500 posts.py           # Post endpoints\n    \u2514\u2500\u2500 ...                # Other endpoints\n</code></pre> <p>Your endpoints are automatically available at <code>/api/v1/...</code>:</p> <ul> <li><code>GET /api/v1/users/</code> - Get users</li> <li><code>POST /api/v1/users/</code> - Create user</li> <li><code>GET /api/v1/posts/</code> - Get posts</li> </ul>"},{"location":"user-guide/api/versioning/#current-structure","title":"Current Structure","text":""},{"location":"user-guide/api/versioning/#version-1-v1","title":"Version 1 (v1)","text":"<p>The current API version is in <code>src/app/api/v1/</code>:</p> <pre><code># src/app/api/v1/__init__.py\nfrom fastapi import APIRouter\n\nfrom .users import router as users_router\nfrom .posts import router as posts_router\nfrom .login import router as login_router\n\n# Main v1 router\napi_router = APIRouter()\n\n# Include all v1 endpoints\napi_router.include_router(users_router)\napi_router.include_router(posts_router)\napi_router.include_router(login_router)\n</code></pre>"},{"location":"user-guide/api/versioning/#main-app-registration","title":"Main App Registration","text":"<p>In <code>src/app/main.py</code>, v1 is registered:</p> <pre><code>from fastapi import FastAPI\nfrom app.api.v1 import api_router as api_v1_router\n\napp = FastAPI()\n\n# Register v1 API\napp.include_router(api_v1_router, prefix=\"/api/v1\")\n</code></pre>"},{"location":"user-guide/api/versioning/#adding-version-2","title":"Adding Version 2","text":"<p>When you need to make breaking changes, create a new version:</p>"},{"location":"user-guide/api/versioning/#step-1-create-v2-directory","title":"Step 1: Create v2 Directory","text":"<pre><code>src/app/api/\n\u251c\u2500\u2500 dependencies.py\n\u251c\u2500\u2500 v1/                     # Keep v1 unchanged\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 users.py\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 v2/                     # New version\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 users.py           # Updated user endpoints\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"user-guide/api/versioning/#step-2-create-v2-router","title":"Step 2: Create v2 Router","text":"<pre><code># src/app/api/v2/__init__.py\nfrom fastapi import APIRouter\n\nfrom .users import router as users_router\n# Import other v2 routers\n\n# Main v2 router\napi_router = APIRouter()\n\n# Include v2 endpoints\napi_router.include_router(users_router)\n</code></pre>"},{"location":"user-guide/api/versioning/#step-3-register-v2-in-main-app","title":"Step 3: Register v2 in Main App","text":"<pre><code># src/app/main.py\nfrom fastapi import FastAPI\nfrom app.api.v1 import api_router as api_v1_router\nfrom app.api.v2 import api_router as api_v2_router\n\napp = FastAPI()\n\n# Register both versions\napp.include_router(api_v1_router, prefix=\"/api/v1\")\napp.include_router(api_v2_router, prefix=\"/api/v2\")\n</code></pre>"},{"location":"user-guide/api/versioning/#version-2-example","title":"Version 2 Example","text":"<p>Here's how you might evolve the user endpoints in v2:</p>"},{"location":"user-guide/api/versioning/#v1-user-endpoint","title":"v1 User Endpoint","text":"<pre><code># src/app/api/v1/users.py\nfrom app.schemas.user import UserRead, UserCreate\n\n@router.get(\"/\", response_model=list[UserRead])\nasync def get_users():\n    users = await crud_users.get_multi(db=db, schema_to_select=UserRead)\n    return users[\"data\"]\n\n@router.post(\"/\", response_model=UserRead)\nasync def create_user(user_data: UserCreate):\n    return await crud_users.create(db=db, object=user_data)\n</code></pre>"},{"location":"user-guide/api/versioning/#v2-user-endpoint-with-breaking-changes","title":"v2 User Endpoint (with breaking changes)","text":"<pre><code># src/app/api/v2/users.py\nfrom app.schemas.user import UserReadV2, UserCreateV2  # New schemas\nfrom fastcrud.paginated import PaginatedListResponse\n\n# Breaking change: Always return paginated response\n@router.get(\"/\", response_model=PaginatedListResponse[UserReadV2])\nasync def get_users(page: int = 1, items_per_page: int = 10):\n    users = await crud_users.get_multi(\n        db=db,\n        offset=(page - 1) * items_per_page,\n        limit=items_per_page,\n        schema_to_select=UserReadV2\n    )\n    return paginated_response(users, page, items_per_page)\n\n# Breaking change: Require authentication\n@router.post(\"/\", response_model=UserReadV2)\nasync def create_user(\n    user_data: UserCreateV2,\n    current_user: Annotated[dict, Depends(get_current_user)]  # Now required\n):\n    return await crud_users.create(db=db, object=user_data)\n</code></pre>"},{"location":"user-guide/api/versioning/#schema-versioning","title":"Schema Versioning","text":"<p>Create separate schemas for different versions:</p>"},{"location":"user-guide/api/versioning/#version-1-schema","title":"Version 1 Schema","text":"<pre><code># src/app/schemas/user.py (existing)\nclass UserRead(BaseModel):\n    id: int\n    name: str\n    username: str\n    email: str\n    profile_image_url: str\n    tier_id: int | None\n\nclass UserCreate(BaseModel):\n    name: str\n    username: str\n    email: str\n    password: str\n</code></pre>"},{"location":"user-guide/api/versioning/#version-2-schema-with-changes","title":"Version 2 Schema (with changes)","text":"<pre><code># src/app/schemas/user_v2.py (new file)\nfrom datetime import datetime\n\nclass UserReadV2(BaseModel):\n    id: int\n    name: str\n    username: str\n    email: str\n    avatar_url: str          # Changed from profile_image_url\n    subscription_tier: str   # Changed from tier_id to string\n    created_at: datetime     # New field\n    is_verified: bool        # New field\n\nclass UserCreateV2(BaseModel):\n    name: str\n    username: str\n    email: str\n    password: str\n    accept_terms: bool       # New required field\n</code></pre>"},{"location":"user-guide/api/versioning/#gradual-migration-strategy","title":"Gradual Migration Strategy","text":""},{"location":"user-guide/api/versioning/#1-keep-both-versions-running","title":"1. Keep Both Versions Running","text":"<pre><code># Both versions work simultaneously\n# v1: GET /api/v1/users/ -&gt; list[UserRead]\n# v2: GET /api/v2/users/ -&gt; PaginatedListResponse[UserReadV2]\n</code></pre>"},{"location":"user-guide/api/versioning/#2-add-deprecation-warnings","title":"2. Add Deprecation Warnings","text":"<pre><code># src/app/api/v1/users.py\nimport warnings\nfrom fastapi import HTTPException\n\n@router.get(\"/\", response_model=list[UserRead])\nasync def get_users(response: Response):\n    # Add deprecation header\n    response.headers[\"X-API-Deprecation\"] = \"v1 is deprecated. Use v2.\"\n    response.headers[\"X-API-Sunset\"] = \"2024-12-31\"  # When v1 will be removed\n\n    users = await crud_users.get_multi(db=db, schema_to_select=UserRead)\n    return users[\"data\"]\n</code></pre>"},{"location":"user-guide/api/versioning/#3-monitor-usage","title":"3. Monitor Usage","text":"<p>Track which versions are being used:</p> <pre><code># src/app/api/middleware.py\nfrom fastapi import Request\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def version_tracking_middleware(request: Request, call_next):\n    if request.url.path.startswith(\"/api/v1/\"):\n        logger.info(f\"v1 usage: {request.method} {request.url.path}\")\n    elif request.url.path.startswith(\"/api/v2/\"):\n        logger.info(f\"v2 usage: {request.method} {request.url.path}\")\n\n    response = await call_next(request)\n    return response\n</code></pre>"},{"location":"user-guide/api/versioning/#shared-code-between-versions","title":"Shared Code Between Versions","text":"<p>Keep common logic in shared modules:</p>"},{"location":"user-guide/api/versioning/#shared-dependencies","title":"Shared Dependencies","text":"<pre><code># src/app/api/dependencies.py - shared across all versions\nasync def get_current_user(...):\n    # Authentication logic used by all versions\n    pass\n\nasync def get_db():\n    # Database connection used by all versions\n    pass\n</code></pre>"},{"location":"user-guide/api/versioning/#shared-crud-operations","title":"Shared CRUD Operations","text":"<pre><code># The CRUD layer can be shared between versions\n# Only the schemas and endpoints change\n\n# v1 endpoint\n@router.get(\"/\", response_model=list[UserRead])\nasync def get_users_v1():\n    users = await crud_users.get_multi(schema_to_select=UserRead)\n    return users[\"data\"]\n\n# v2 endpoint  \n@router.get(\"/\", response_model=PaginatedListResponse[UserReadV2])\nasync def get_users_v2():\n    users = await crud_users.get_multi(schema_to_select=UserReadV2)\n    return paginated_response(users, page, items_per_page)\n</code></pre>"},{"location":"user-guide/api/versioning/#version-discovery","title":"Version Discovery","text":"<p>Let clients discover available versions:</p> <pre><code># src/app/api/versions.py\nfrom fastapi import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/versions\")\nasync def get_api_versions():\n    return {\n        \"available_versions\": [\"v1\", \"v2\"],\n        \"current_version\": \"v2\",\n        \"deprecated_versions\": [],\n        \"sunset_dates\": {\n            \"v1\": \"2024-12-31\"\n        }\n    }\n</code></pre> <p>Register it in main.py: <pre><code># src/app/main.py\nfrom app.api.versions import router as versions_router\n\napp.include_router(versions_router, prefix=\"/api\")\n# Now available at GET /api/versions\n</code></pre></p>"},{"location":"user-guide/api/versioning/#testing-multiple-versions","title":"Testing Multiple Versions","text":"<p>Test both versions to ensure compatibility:</p> <pre><code># tests/test_api_versioning.py\nimport pytest\nfrom httpx import AsyncClient\n\n@pytest.mark.asyncio\nasync def test_v1_users(client: AsyncClient):\n    \"\"\"Test v1 returns simple list\"\"\"\n    response = await client.get(\"/api/v1/users/\")\n    assert response.status_code == 200\n\n    data = response.json()\n    assert isinstance(data, list)  # v1 returns list\n\n@pytest.mark.asyncio  \nasync def test_v2_users(client: AsyncClient):\n    \"\"\"Test v2 returns paginated response\"\"\"\n    response = await client.get(\"/api/v2/users/\")\n    assert response.status_code == 200\n\n    data = response.json()\n    assert \"data\" in data  # v2 returns paginated response\n    assert \"total_count\" in data\n    assert \"page\" in data\n</code></pre>"},{"location":"user-guide/api/versioning/#openapi-documentation","title":"OpenAPI Documentation","text":"<p>Each version gets its own docs:</p> <pre><code># src/app/main.py\nfrom fastapi import FastAPI\n\n# Create separate apps for documentation\nv1_app = FastAPI(title=\"My API v1\", version=\"1.0.0\")\nv2_app = FastAPI(title=\"My API v2\", version=\"2.0.0\")\n\n# Register routes\nv1_app.include_router(api_v1_router)\nv2_app.include_router(api_v2_router)\n\n# Mount as sub-applications\nmain_app = FastAPI()\nmain_app.mount(\"/api/v1\", v1_app)\nmain_app.mount(\"/api/v2\", v2_app)\n</code></pre> <p>Now you have separate documentation: - <code>/api/v1/docs</code> - v1 documentation - <code>/api/v2/docs</code> - v2 documentation</p>"},{"location":"user-guide/api/versioning/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/api/versioning/#1-semantic-versioning","title":"1. Semantic Versioning","text":"<ul> <li>v1.0 \u2192 v1.1: New features (backward compatible)</li> <li>v1.1 \u2192 v2.0: Breaking changes (new version)</li> </ul>"},{"location":"user-guide/api/versioning/#2-clear-migration-path","title":"2. Clear Migration Path","text":"<pre><code># Document what changed in v2\n\"\"\"\nAPI v2 Changes:\n- GET /users/ now returns paginated response instead of array\n- POST /users/ now requires authentication\n- UserRead.profile_image_url renamed to avatar_url\n- UserRead.tier_id changed to subscription_tier (string)\n- Added UserRead.created_at and is_verified fields\n- UserCreate now requires accept_terms field\n\"\"\"\n</code></pre>"},{"location":"user-guide/api/versioning/#3-gradual-deprecation","title":"3. Gradual Deprecation","text":"<ol> <li>Release v2 alongside v1</li> <li>Add deprecation warnings to v1</li> <li>Set sunset date for v1</li> <li>Monitor v1 usage</li> <li>Remove v1 after sunset date</li> </ol>"},{"location":"user-guide/api/versioning/#4-consistent-patterns","title":"4. Consistent Patterns","text":"<p>Keep the same patterns across versions:</p> <ul> <li>Same URL structure: <code>/api/v{number}/resource</code></li> <li>Same HTTP methods and status codes</li> <li>Same authentication approach</li> <li>Same error response format</li> </ul>"},{"location":"user-guide/api/versioning/#whats-next","title":"What's Next","text":"<p>Now that you understand API versioning:</p> <ul> <li>Database Migrations - Handle database schema changes</li> <li>Testing - Test multiple API versions</li> <li>Production - Deploy versioned APIs</li> </ul> <p>Proper versioning lets you evolve your API without breaking existing clients!</p>"},{"location":"user-guide/authentication/","title":"Authentication &amp; Security","text":"<p>Learn how to implement secure authentication in your FastAPI application. The boilerplate provides a complete JWT-based authentication system with user management, permissions, and security best practices.</p>"},{"location":"user-guide/authentication/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>JWT Tokens - Understand access and refresh token management</li> <li>User Management - Handle registration, login, and user profiles</li> <li>Permissions - Implement role-based access control and authorization</li> </ul>"},{"location":"user-guide/authentication/#authentication-overview","title":"Authentication Overview","text":"<p>The system uses JWT tokens with refresh token rotation for secure, stateless authentication:</p> <pre><code># Basic login flow\n@router.post(\"/login\", response_model=Token)\nasync def login_for_access_token(response: Response, form_data: OAuth2PasswordRequestForm):\n    user = await authenticate_user(form_data.username, form_data.password, db)\n    access_token = await create_access_token(data={\"sub\": user[\"username\"]})\n    refresh_token = await create_refresh_token(data={\"sub\": user[\"username\"]})\n\n    # Set secure HTTP-only cookie for refresh token\n    response.set_cookie(\"refresh_token\", refresh_token, httponly=True, secure=True)\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"user-guide/authentication/#key-features","title":"Key Features","text":""},{"location":"user-guide/authentication/#jwt-token-system","title":"JWT Token System","text":"<ul> <li>Access tokens: Short-lived (30 minutes), for API requests</li> <li>Refresh tokens: Long-lived (7 days), stored in secure cookies</li> <li>Token blacklisting: Secure logout implementation</li> <li>Automatic expiration: Built-in token lifecycle management</li> </ul>"},{"location":"user-guide/authentication/#user-management","title":"User Management","text":"<ul> <li>Flexible authentication: Username or email login</li> <li>Secure passwords: bcrypt hashing with salt</li> <li>Profile management: Complete user CRUD operations</li> <li>Soft delete: User deactivation without data loss</li> </ul>"},{"location":"user-guide/authentication/#permission-system","title":"Permission System","text":"<ul> <li>Superuser privileges: Administrative access control</li> <li>Resource ownership: User-specific data access</li> <li>User tiers: Subscription-based feature access</li> <li>Rate limiting: Per-user and per-tier API limits</li> </ul>"},{"location":"user-guide/authentication/#authentication-patterns","title":"Authentication Patterns","text":""},{"location":"user-guide/authentication/#endpoint-protection","title":"Endpoint Protection","text":"<pre><code># Required authentication\n@router.get(\"/protected\")\nasync def protected_endpoint(current_user: dict = Depends(get_current_user)):\n    return {\"message\": f\"Hello {current_user['username']}\"}\n\n# Optional authentication\n@router.get(\"/public\")\nasync def public_endpoint(user: dict | None = Depends(get_optional_user)):\n    if user:\n        return {\"premium_content\": True}\n    return {\"premium_content\": False}\n\n# Superuser only\n@router.get(\"/admin\", dependencies=[Depends(get_current_superuser)])\nasync def admin_endpoint():\n    return {\"admin_data\": \"sensitive\"}\n</code></pre>"},{"location":"user-guide/authentication/#resource-ownership","title":"Resource Ownership","text":"<pre><code>@router.patch(\"/posts/{post_id}\")\nasync def update_post(post_id: int, current_user: dict = Depends(get_current_user)):\n    post = await crud_posts.get(db=db, id=post_id)\n\n    # Check ownership or admin privileges\n    if post[\"created_by_user_id\"] != current_user[\"id\"] and not current_user[\"is_superuser\"]:\n        raise ForbiddenException(\"Cannot update other users' posts\")\n\n    return await crud_posts.update(db=db, id=post_id, object=updates)\n</code></pre>"},{"location":"user-guide/authentication/#security-features","title":"Security Features","text":""},{"location":"user-guide/authentication/#token-security","title":"Token Security","text":"<ul> <li>Short-lived access tokens limit exposure</li> <li>HTTP-only refresh token cookies prevent XSS</li> <li>Token blacklisting enables secure logout</li> <li>Configurable token expiration times</li> </ul>"},{"location":"user-guide/authentication/#password-security","title":"Password Security","text":"<ul> <li>bcrypt hashing with automatic salt generation</li> <li>Configurable password complexity requirements</li> <li>No plain text passwords stored anywhere</li> <li>Rate limiting on authentication endpoints</li> </ul>"},{"location":"user-guide/authentication/#api-protection","title":"API Protection","text":"<ul> <li>CORS policies for cross-origin request control</li> <li>Rate limiting prevents brute force attacks</li> <li>Input validation prevents injection attacks</li> <li>Consistent error messages prevent information disclosure</li> </ul>"},{"location":"user-guide/authentication/#configuration","title":"Configuration","text":""},{"location":"user-guide/authentication/#jwt-settings","title":"JWT Settings","text":"<pre><code>SECRET_KEY=\"your-super-secret-key-here\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n</code></pre>"},{"location":"user-guide/authentication/#security-settings","title":"Security Settings","text":"<pre><code># Cookie security\nCOOKIE_SECURE=true\nCOOKIE_SAMESITE=\"lax\"\n\n# Password requirements\nPASSWORD_MIN_LENGTH=8\nENABLE_PASSWORD_COMPLEXITY=true\n</code></pre>"},{"location":"user-guide/authentication/#getting-started","title":"Getting Started","text":"<p>Follow this progressive learning path:</p>"},{"location":"user-guide/authentication/#1-jwt-tokens-foundation","title":"1. JWT Tokens - Foundation","text":"<p>Understand how JWT tokens work, including access and refresh token management, verification, and blacklisting.</p>"},{"location":"user-guide/authentication/#2-user-management-core-features","title":"2. User Management - Core Features","text":"<p>Implement user registration, login, profile management, and administrative operations.</p>"},{"location":"user-guide/authentication/#3-permissions-access-control","title":"3. Permissions - Access Control","text":"<p>Set up role-based access control, resource ownership checking, and tier-based permissions.</p>"},{"location":"user-guide/authentication/#implementation-examples","title":"Implementation Examples","text":""},{"location":"user-guide/authentication/#quick-authentication-setup","title":"Quick Authentication Setup","text":"<pre><code># Protect an endpoint\n@router.get(\"/my-data\")\nasync def get_my_data(current_user: dict = Depends(get_current_user)):\n    return await get_user_specific_data(current_user[\"id\"])\n\n# Check user permissions\ndef check_tier_access(user: dict, required_tier: str):\n    if not user.get(\"tier\") or user[\"tier\"][\"name\"] != required_tier:\n        raise ForbiddenException(f\"Requires {required_tier} tier\")\n\n# Custom authentication dependency\nasync def get_premium_user(current_user: dict = Depends(get_current_user)):\n    check_tier_access(current_user, \"Pro\")\n    return current_user\n</code></pre>"},{"location":"user-guide/authentication/#frontend-integration","title":"Frontend Integration","text":"<pre><code>// Basic authentication flow\nclass AuthManager {\n    async login(username, password) {\n        const response = await fetch('/api/v1/login', {\n            method: 'POST',\n            headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n            body: new URLSearchParams({username, password})\n        });\n\n        const tokens = await response.json();\n        localStorage.setItem('access_token', tokens.access_token);\n        return tokens;\n    }\n\n    async makeAuthenticatedRequest(url, options = {}) {\n        const token = localStorage.getItem('access_token');\n        return fetch(url, {\n            ...options,\n            headers: {\n                ...options.headers,\n                'Authorization': `Bearer ${token}`\n            }\n        });\n    }\n}\n</code></pre>"},{"location":"user-guide/authentication/#whats-next","title":"What's Next","text":"<p>Start building your authentication system:</p> <ol> <li>JWT Tokens - Learn token creation, verification, and lifecycle management</li> <li>User Management - Implement registration, login, and profile operations  </li> <li>Permissions - Add authorization patterns and access control</li> </ol> <p>The authentication system provides a secure foundation for your API. Each guide includes practical examples and implementation details for production-ready authentication. </p>"},{"location":"user-guide/authentication/jwt-tokens/","title":"JWT Tokens","text":"<p>JSON Web Tokens (JWT) form the backbone of modern web authentication. This comprehensive guide explains how the boilerplate implements a secure, stateless authentication system using access and refresh tokens.</p>"},{"location":"user-guide/authentication/jwt-tokens/#understanding-jwt-authentication","title":"Understanding JWT Authentication","text":"<p>JWT tokens are self-contained, digitally signed packages of information that can be safely transmitted between parties. Unlike traditional session-based authentication that requires server-side storage, JWT tokens are stateless - all the information needed to verify a user's identity is contained within the token itself.</p>"},{"location":"user-guide/authentication/jwt-tokens/#why-use-jwt","title":"Why Use JWT?","text":"<p>Stateless Design: No need to store session data on the server, making it perfect for distributed systems and microservices.</p> <p>Scalability: Since tokens contain all necessary information, they work seamlessly across multiple servers without shared session storage.</p> <p>Security: Digital signatures ensure tokens can't be tampered with, and expiration times limit exposure if compromised.</p> <p>Cross-Domain Support: Unlike cookies, JWT tokens work across different domains and can be used in mobile applications.</p>"},{"location":"user-guide/authentication/jwt-tokens/#token-types","title":"Token Types","text":"<p>The authentication system uses a dual-token approach for maximum security and user experience:</p>"},{"location":"user-guide/authentication/jwt-tokens/#access-tokens","title":"Access Tokens","text":"<p>Access tokens are short-lived credentials that prove a user's identity for API requests. Think of them as temporary keys that grant access to protected resources.</p> <ul> <li>Purpose: Authenticate API requests and authorize actions</li> <li>Lifetime: 30 minutes (configurable) - short enough to limit damage if compromised</li> <li>Storage: Authorization header (<code>Bearer &lt;token&gt;</code>) - sent with each API request</li> <li>Usage: Include in every call to protected endpoints</li> </ul> <p>Why Short-Lived? If an access token is stolen (e.g., through XSS), the damage window is limited to 30 minutes before it expires naturally.</p>"},{"location":"user-guide/authentication/jwt-tokens/#refresh-tokens","title":"Refresh Tokens","text":"<p>Refresh tokens are longer-lived credentials used solely to generate new access tokens. They provide a balance between security and user convenience.</p> <ul> <li>Purpose: Generate new access tokens without requiring re-login</li> <li>Lifetime: 7 days (configurable) - long enough for good UX, short enough for security</li> <li>Storage: Secure HTTP-only cookie - inaccessible to JavaScript, preventing XSS attacks</li> <li>Usage: Automatically used by the browser when access tokens need refreshing</li> </ul> <p>Why HTTP-Only Cookies? This prevents malicious JavaScript from accessing refresh tokens, providing protection against XSS attacks while allowing automatic renewal.</p>"},{"location":"user-guide/authentication/jwt-tokens/#token-creation","title":"Token Creation","text":"<p>Understanding how tokens are created helps you customize the authentication system for your specific needs.</p>"},{"location":"user-guide/authentication/jwt-tokens/#creating-access-tokens","title":"Creating Access Tokens","text":"<p>Access tokens are generated during login and token refresh operations. The process involves encoding user information with an expiration time and signing it with your secret key.</p> <pre><code>from datetime import timedelta\nfrom app.core.security import create_access_token, ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Basic access token with default expiration\naccess_token = await create_access_token(data={\"sub\": username})\n\n# Custom expiration for special cases (e.g., admin sessions)\ncustom_expires = timedelta(minutes=60)\naccess_token = await create_access_token(\n    data={\"sub\": username}, \n    expires_delta=custom_expires\n)\n</code></pre> <p>When to Customize Expiration: - High-security environments: Shorter expiration (15 minutes) - Development/testing: Longer expiration for convenience - Admin operations: Variable expiration based on sensitivity</p>"},{"location":"user-guide/authentication/jwt-tokens/#creating-refresh-tokens","title":"Creating Refresh Tokens","text":"<p>Refresh tokens follow the same creation pattern but with longer expiration times. They're typically created only during login.</p> <pre><code>from app.core.security import create_refresh_token, REFRESH_TOKEN_EXPIRE_DAYS\n\n# Standard refresh token\nrefresh_token = await create_refresh_token(data={\"sub\": username})\n\n# Extended refresh token for \"remember me\" functionality\nextended_expires = timedelta(days=30)\nrefresh_token = await create_refresh_token(\n    data={\"sub\": username}, \n    expires_delta=extended_expires\n)\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#token-structure","title":"Token Structure","text":"<p>JWT tokens consist of three parts separated by dots: <code>header.payload.signature</code>. The payload contains the actual user information and metadata.</p> <pre><code># Access token payload structure\n{\n    \"sub\": \"username\",           # Subject (user identifier)\n    \"exp\": 1234567890,          # Expiration timestamp (Unix)\n    \"token_type\": \"access\",     # Distinguishes from refresh tokens\n    \"iat\": 1234567890           # Issued at (automatic)\n}\n\n# Refresh token payload structure\n{\n    \"sub\": \"username\",          # Same user identifier\n    \"exp\": 1234567890,         # Longer expiration time\n    \"token_type\": \"refresh\",   # Prevents confusion/misuse\n    \"iat\": 1234567890          # Issue timestamp\n}\n</code></pre> <p>Key Fields Explained: - <code>sub</code> (Subject): Identifies the user - can be username, email, or user ID - <code>exp</code> (Expiration): Unix timestamp when token becomes invalid - <code>token_type</code>: Custom field preventing tokens from being used incorrectly - <code>iat</code> (Issued At): Useful for token rotation and audit trails</p>"},{"location":"user-guide/authentication/jwt-tokens/#token-verification","title":"Token Verification","text":"<p>Token verification is a multi-step process that ensures both the token's authenticity and the user's current authorization status.</p>"},{"location":"user-guide/authentication/jwt-tokens/#verifying-access-tokens","title":"Verifying Access Tokens","text":"<p>Every protected endpoint must verify the access token before processing the request. This involves checking the signature, expiration, and blacklist status.</p> <pre><code>from app.core.security import verify_token, TokenType\n\n# Verify access token in endpoint\ntoken_data = await verify_token(token, TokenType.ACCESS, db)\nif token_data:\n    username = token_data.username_or_email\n    # Token is valid, proceed with request processing\nelse:\n    # Token is invalid, expired, or blacklisted\n    raise UnauthorizedException(\"Invalid or expired token\")\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#verifying-refresh-tokens","title":"Verifying Refresh Tokens","text":"<p>Refresh token verification follows the same process but with different validation rules and outcomes.</p> <pre><code># Verify refresh token for renewal\ntoken_data = await verify_token(token, TokenType.REFRESH, db)\nif token_data:\n    # Generate new access token\n    new_access_token = await create_access_token(\n        data={\"sub\": token_data.username_or_email}\n    )\n    return {\"access_token\": new_access_token, \"token_type\": \"bearer\"}\nelse:\n    # Refresh token invalid - user must log in again\n    raise UnauthorizedException(\"Invalid refresh token\")\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#token-verification-process","title":"Token Verification Process","text":"<p>The verification process includes several security checks to prevent various attack vectors:</p> <pre><code>async def verify_token(token: str, expected_token_type: TokenType, db: AsyncSession) -&gt; TokenData | None:\n    # 1. Check blacklist first (prevents use of logged-out tokens)\n    is_blacklisted = await crud_token_blacklist.exists(db, token=token)\n    if is_blacklisted:\n        return None\n\n    try:\n        # 2. Verify signature and decode payload\n        payload = jwt.decode(token, SECRET_KEY.get_secret_value(), algorithms=[ALGORITHM])\n\n        # 3. Extract and validate claims\n        username_or_email: str | None = payload.get(\"sub\")\n        token_type: str | None = payload.get(\"token_type\")\n\n        # 4. Ensure token type matches expectation\n        if username_or_email is None or token_type != expected_token_type:\n            return None\n\n        # 5. Return validated data\n        return TokenData(username_or_email=username_or_email)\n\n    except JWTError:\n        # Token is malformed, expired, or signature invalid\n        return None\n</code></pre> <p>Security Checks Explained:</p> <ol> <li>Blacklist Check: Prevents use of tokens from logged-out users</li> <li>Signature Verification: Ensures token hasn't been tampered with</li> <li>Expiration Check: Automatically handled by JWT library</li> <li>Type Validation: Prevents refresh tokens from being used as access tokens</li> <li>Subject Validation: Ensures token contains valid user identifier</li> </ol>"},{"location":"user-guide/authentication/jwt-tokens/#client-side-authentication-flow","title":"Client-Side Authentication Flow","text":"<p>Understanding the complete authentication flow helps frontend developers integrate properly with the API.</p>"},{"location":"user-guide/authentication/jwt-tokens/#recommended-client-flow","title":"Recommended Client Flow","text":"<p>1. Login Process <pre><code>// Send credentials to login endpoint\nconst response = await fetch('/api/v1/login', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: 'username=user&amp;password=pass',\n    credentials: 'include'  // Important: includes cookies\n});\n\nconst { access_token, token_type } = await response.json();\n\n// Store access token in memory (not localStorage)\nsessionStorage.setItem('access_token', access_token);\n</code></pre></p> <p>2. Making Authenticated Requests <pre><code>// Include access token in Authorization header\nconst response = await fetch('/api/v1/protected-endpoint', {\n    headers: {\n        'Authorization': `Bearer ${sessionStorage.getItem('access_token')}`\n    },\n    credentials: 'include'\n});\n</code></pre></p> <p>3. Handling Token Expiration <pre><code>// Automatic token refresh on 401 errors\nasync function apiCall(url, options = {}) {\n    let response = await fetch(url, {\n        ...options,\n        headers: {\n            ...options.headers,\n            'Authorization': `Bearer ${sessionStorage.getItem('access_token')}`\n        },\n        credentials: 'include'\n    });\n\n    // If token expired, try to refresh\n    if (response.status === 401) {\n        const refreshResponse = await fetch('/api/v1/refresh', {\n            method: 'POST',\n            credentials: 'include'  // Sends refresh token cookie\n        });\n\n        if (refreshResponse.ok) {\n            const { access_token } = await refreshResponse.json();\n            sessionStorage.setItem('access_token', access_token);\n\n            // Retry original request\n            response = await fetch(url, {\n                ...options,\n                headers: {\n                    ...options.headers,\n                    'Authorization': `Bearer ${access_token}`\n                },\n                credentials: 'include'\n            });\n        } else {\n            // Refresh failed - redirect to login\n            window.location.href = '/login';\n        }\n    }\n\n    return response;\n}\n</code></pre></p> <p>4. Logout Process <pre><code>// Clear tokens and call logout endpoint\nawait fetch('/api/v1/logout', {\n    method: 'POST',\n    credentials: 'include'\n});\n\nsessionStorage.removeItem('access_token');\n// Refresh token cookie is cleared by server\n</code></pre></p>"},{"location":"user-guide/authentication/jwt-tokens/#cookie-configuration","title":"Cookie Configuration","text":"<p>The refresh token cookie is configured for maximum security:</p> <pre><code>response.set_cookie(\n    key=\"refresh_token\",\n    value=refresh_token,\n    httponly=True,    # Prevents JavaScript access (XSS protection)\n    secure=True,      # HTTPS only in production\n    samesite=\"Lax\",   # CSRF protection with good usability\n    max_age=REFRESH_TOKEN_EXPIRE_DAYS * 24 * 60 * 60\n)\n</code></pre> <p>SameSite Options:</p> <ul> <li><code>Lax</code> (Recommended): Cookies sent on top-level navigation but not cross-site requests</li> <li><code>Strict</code>: Maximum security but may break some user flows</li> <li><code>None</code>: Required for cross-origin requests (must use with Secure)</li> </ul>"},{"location":"user-guide/authentication/jwt-tokens/#token-blacklisting","title":"Token Blacklisting","text":"<p>Token blacklisting solves a fundamental problem with JWT tokens: once issued, they remain valid until expiration, even if the user logs out. Blacklisting provides immediate token revocation.</p>"},{"location":"user-guide/authentication/jwt-tokens/#why-blacklisting-matters","title":"Why Blacklisting Matters","text":"<p>Without blacklisting, logged-out users could continue accessing your API until their tokens naturally expire. This creates security risks, especially on shared computers or if tokens are compromised.</p>"},{"location":"user-guide/authentication/jwt-tokens/#blacklisting-implementation","title":"Blacklisting Implementation","text":"<p>The system uses a database table to track invalidated tokens:</p> <pre><code># models/token_blacklist.py\nclass TokenBlacklist(Base):\n    __tablename__ = \"token_blacklist\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    token: Mapped[str] = mapped_column(unique=True, index=True)  # Full token string\n    expires_at: Mapped[datetime] = mapped_column()              # When to clean up\n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n</code></pre> <p>Design Considerations: - Unique constraint: Prevents duplicate entries - Index on token: Fast lookup during verification - Expires_at field: Enables automatic cleanup of old entries</p>"},{"location":"user-guide/authentication/jwt-tokens/#blacklisting-tokens","title":"Blacklisting Tokens","text":"<p>The system provides functions for both single token and dual token blacklisting:</p> <pre><code>from app.core.security import blacklist_token, blacklist_tokens\n\n# Single token blacklisting (for specific scenarios)\nawait blacklist_token(token, db)\n\n# Dual token blacklisting (standard logout)\nawait blacklist_tokens(access_token, refresh_token, db)\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#blacklisting-process","title":"Blacklisting Process","text":"<p>The blacklisting process extracts the expiration time from the token to set an appropriate cleanup schedule:</p> <pre><code>async def blacklist_token(token: str, db: AsyncSession) -&gt; None:\n    # 1. Decode token to extract expiration (no verification needed)\n    payload = jwt.decode(token, SECRET_KEY.get_secret_value(), algorithms=[ALGORITHM])\n    exp_timestamp = payload.get(\"exp\")\n\n    if exp_timestamp is not None:\n        # 2. Convert Unix timestamp to datetime\n        expires_at = datetime.fromtimestamp(exp_timestamp)\n\n        # 3. Store in blacklist with expiration\n        await crud_token_blacklist.create(\n            db, \n            object=TokenBlacklistCreate(token=token, expires_at=expires_at)\n        )\n</code></pre> <p>Cleanup Strategy: Blacklisted tokens can be automatically removed from the database after their natural expiration time, preventing unlimited database growth.</p>"},{"location":"user-guide/authentication/jwt-tokens/#login-flow-implementation","title":"Login Flow Implementation","text":""},{"location":"user-guide/authentication/jwt-tokens/#complete-login-endpoint","title":"Complete Login Endpoint","text":"<pre><code>@router.post(\"/login\", response_model=Token)\nasync def login_for_access_token(\n    response: Response,\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n) -&gt; dict[str, str]:\n    # 1. Authenticate user\n    user = await authenticate_user(\n        username_or_email=form_data.username, \n        password=form_data.password, \n        db=db\n    )\n\n    if not user:\n        raise HTTPException(\n            status_code=401, \n            detail=\"Incorrect username or password\"\n        )\n\n    # 2. Create access token\n    access_token = await create_access_token(data={\"sub\": user[\"username\"]})\n\n    # 3. Create refresh token\n    refresh_token = await create_refresh_token(data={\"sub\": user[\"username\"]})\n\n    # 4. Set refresh token as HTTP-only cookie\n    response.set_cookie(\n        key=\"refresh_token\",\n        value=refresh_token,\n        httponly=True,\n        secure=True,\n        samesite=\"strict\",\n        max_age=REFRESH_TOKEN_EXPIRE_DAYS * 24 * 60 * 60\n    )\n\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#token-refresh-endpoint","title":"Token Refresh Endpoint","text":"<pre><code>@router.post(\"/refresh\", response_model=Token)\nasync def refresh_access_token(\n    response: Response,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    refresh_token: str = Cookie(None)\n) -&gt; dict[str, str]:\n    if not refresh_token:\n        raise HTTPException(status_code=401, detail=\"Refresh token missing\")\n\n    # 1. Verify refresh token\n    token_data = await verify_token(refresh_token, TokenType.REFRESH, db)\n    if not token_data:\n        raise HTTPException(status_code=401, detail=\"Invalid refresh token\")\n\n    # 2. Create new access token\n    new_access_token = await create_access_token(\n        data={\"sub\": token_data.username_or_email}\n    )\n\n    # 3. Optionally create new refresh token (token rotation)\n    new_refresh_token = await create_refresh_token(\n        data={\"sub\": token_data.username_or_email}\n    )\n\n    # 4. Blacklist old refresh token\n    await blacklist_token(refresh_token, db)\n\n    # 5. Set new refresh token cookie\n    response.set_cookie(\n        key=\"refresh_token\",\n        value=new_refresh_token,\n        httponly=True,\n        secure=True,\n        samesite=\"strict\",\n        max_age=REFRESH_TOKEN_EXPIRE_DAYS * 24 * 60 * 60\n    )\n\n    return {\"access_token\": new_access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#logout-implementation","title":"Logout Implementation","text":"<pre><code>@router.post(\"/logout\")\nasync def logout(\n    response: Response,\n    db: Annotated[AsyncSession, Depends(async_get_db)],\n    current_user: dict = Depends(get_current_user),\n    token: str = Depends(oauth2_scheme),\n    refresh_token: str = Cookie(None)\n) -&gt; dict[str, str]:\n    # 1. Blacklist access token\n    await blacklist_token(token, db)\n\n    # 2. Blacklist refresh token if present\n    if refresh_token:\n        await blacklist_token(refresh_token, db)\n\n    # 3. Clear refresh token cookie\n    response.delete_cookie(\n        key=\"refresh_token\",\n        httponly=True,\n        secure=True,\n        samesite=\"strict\"\n    )\n\n    return {\"message\": \"Successfully logged out\"}\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#authentication-dependencies","title":"Authentication Dependencies","text":""},{"location":"user-guide/authentication/jwt-tokens/#get_current_user","title":"get_current_user","text":"<pre><code>async def get_current_user(\n    db: AsyncSession = Depends(async_get_db),\n    token: str = Depends(oauth2_scheme)\n) -&gt; dict:\n    # 1. Verify token\n    token_data = await verify_token(token, TokenType.ACCESS, db)\n    if not token_data:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    # 2. Get user from database\n    user = await crud_users.get(\n        db=db, \n        username=token_data.username_or_email,\n        schema_to_select=UserRead\n    )\n\n    if user is None:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n\n    return user\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#get_optional_user","title":"get_optional_user","text":"<pre><code>async def get_optional_user(\n    db: AsyncSession = Depends(async_get_db),\n    token: str = Depends(optional_oauth2_scheme)\n) -&gt; dict | None:\n    if not token:\n        return None\n\n    try:\n        return await get_current_user(db=db, token=token)\n    except HTTPException:\n        return None\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#get_current_superuser","title":"get_current_superuser","text":"<pre><code>async def get_current_superuser(\n    current_user: dict = Depends(get_current_user)\n) -&gt; dict:\n    if not current_user.get(\"is_superuser\", False):\n        raise HTTPException(\n            status_code=403, \n            detail=\"Not enough permissions\"\n        )\n    return current_user\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#configuration","title":"Configuration","text":""},{"location":"user-guide/authentication/jwt-tokens/#environment-variables","title":"Environment Variables","text":"<pre><code># JWT Configuration\nSECRET_KEY=your-secret-key-here\nALGORITHM=HS256\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n\n# Security Headers\nSECURE_COOKIES=true\nCORS_ORIGINS=[\"http://localhost:3000\", \"https://yourapp.com\"]\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#security-configuration","title":"Security Configuration","text":"<pre><code># app/core/config.py\nclass Settings(BaseSettings):\n    SECRET_KEY: SecretStr\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    REFRESH_TOKEN_EXPIRE_DAYS: int = 7\n\n    # Cookie settings\n    SECURE_COOKIES: bool = True\n    COOKIE_DOMAIN: str | None = None\n    COOKIE_SAMESITE: str = \"strict\"\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#security-best-practices","title":"Security Best Practices","text":""},{"location":"user-guide/authentication/jwt-tokens/#token-security","title":"Token Security","text":"<ul> <li>Use strong secrets: Generate cryptographically secure SECRET_KEY</li> <li>Rotate secrets: Regularly change SECRET_KEY in production</li> <li>Environment separation: Different secrets for dev/staging/production</li> <li>Secure transmission: Always use HTTPS in production</li> </ul>"},{"location":"user-guide/authentication/jwt-tokens/#cookie-security","title":"Cookie Security","text":"<ul> <li>HttpOnly flag: Prevents JavaScript access to refresh tokens</li> <li>Secure flag: Ensures cookies only sent over HTTPS</li> <li>SameSite attribute: Prevents CSRF attacks</li> <li>Domain restrictions: Set cookie domain appropriately</li> </ul>"},{"location":"user-guide/authentication/jwt-tokens/#implementation-security","title":"Implementation Security","text":"<ul> <li>Input validation: Validate all token inputs</li> <li>Rate limiting: Implement login attempt limits</li> <li>Audit logging: Log authentication events</li> <li>Token rotation: Regularly refresh tokens</li> </ul>"},{"location":"user-guide/authentication/jwt-tokens/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/authentication/jwt-tokens/#api-key-authentication","title":"API Key Authentication","text":"<p>For service-to-service communication:</p> <pre><code>async def get_api_key_user(\n    api_key: str = Header(None),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict:\n    if not api_key:\n        raise HTTPException(status_code=401, detail=\"API key required\")\n\n    # Verify API key\n    user = await crud_users.get(db=db, api_key=api_key)\n    if not user:\n        raise HTTPException(status_code=401, detail=\"Invalid API key\")\n\n    return user\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<pre><code>async def get_authenticated_user(\n    db: AsyncSession = Depends(async_get_db),\n    token: str = Depends(optional_oauth2_scheme),\n    api_key: str = Header(None)\n) -&gt; dict:\n    # Try JWT token first\n    if token:\n        try:\n            return await get_current_user(db=db, token=token)\n        except HTTPException:\n            pass\n\n    # Fall back to API key\n    if api_key:\n        return await get_api_key_user(api_key=api_key, db=db)\n\n    raise HTTPException(status_code=401, detail=\"Authentication required\")\n</code></pre>"},{"location":"user-guide/authentication/jwt-tokens/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/authentication/jwt-tokens/#common-issues","title":"Common Issues","text":"<p>Token Expired: Implement automatic refresh using refresh tokens Invalid Signature: Check SECRET_KEY consistency across environments Blacklisted Token: User logged out - redirect to login Missing Token: Ensure Authorization header is properly set</p>"},{"location":"user-guide/authentication/jwt-tokens/#debugging-tips","title":"Debugging Tips","text":"<pre><code># Enable debug logging\nimport logging\nlogging.getLogger(\"app.core.security\").setLevel(logging.DEBUG)\n\n# Test token validation\nasync def debug_token(token: str, db: AsyncSession):\n    try:\n        payload = jwt.decode(token, SECRET_KEY.get_secret_value(), algorithms=[ALGORITHM])\n        print(f\"Token payload: {payload}\")\n\n        is_blacklisted = await crud_token_blacklist.exists(db, token=token)\n        print(f\"Is blacklisted: {is_blacklisted}\")\n\n    except JWTError as e:\n        print(f\"JWT Error: {e}\")\n</code></pre> <p>This comprehensive JWT implementation provides secure, scalable authentication for your FastAPI application. </p>"},{"location":"user-guide/authentication/permissions/","title":"Permissions and Authorization","text":"<p>Authorization determines what authenticated users can do within your application. While authentication answers \"who are you?\", authorization answers \"what can you do?\". This section covers the permission system, access control patterns, and how to implement secure authorization in your endpoints.</p>"},{"location":"user-guide/authentication/permissions/#understanding-authorization","title":"Understanding Authorization","text":"<p>Authorization is a multi-layered security concept that protects resources and operations based on user identity, roles, and contextual information. The boilerplate implements several authorization patterns to handle different security requirements.</p>"},{"location":"user-guide/authentication/permissions/#authorization-vs-authentication","title":"Authorization vs Authentication","text":"<p>Authentication: Verifies user identity - confirms the user is who they claim to be Authorization: Determines user permissions - decides what the authenticated user can access</p> <p>These work together: you must authenticate first (prove identity) before you can authorize (check permissions).</p>"},{"location":"user-guide/authentication/permissions/#authorization-patterns","title":"Authorization Patterns","text":"<p>The system implements several common authorization patterns:</p> <ol> <li>Role-Based Access Control (RBAC): Users have roles (superuser, regular user) that determine permissions</li> <li>Resource Ownership: Users can only access resources they own</li> <li>Tiered Access: Different user tiers have different capabilities and limits</li> <li>Contextual Authorization: Permissions based on request context (rate limits, time-based access)</li> </ol>"},{"location":"user-guide/authentication/permissions/#core-authorization-patterns","title":"Core Authorization Patterns","text":""},{"location":"user-guide/authentication/permissions/#superuser-permissions","title":"Superuser Permissions","text":"<p>Superusers have elevated privileges for administrative operations. This pattern is essential for system management but must be carefully controlled.</p> <pre><code>from app.api.dependencies import get_current_superuser\n\n# Superuser-only endpoint\n@router.get(\"/admin/users/\", dependencies=[Depends(get_current_superuser)])\nasync def get_all_users(\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; list[UserRead]:\n    # Only superusers can access this endpoint\n    users = await crud_users.get_multi(\n        db=db,\n        schema_to_select=UserRead,\n        return_as_model=True\n    )\n    return users.data\n</code></pre> <p>When to Use Superuser Authorization:</p> <ul> <li>User management operations: Creating, deleting, or modifying other users</li> <li>System configuration: Changing application settings or configuration</li> <li>Data export/import: Bulk operations on sensitive data</li> <li>Administrative reporting: Access to system-wide analytics and logs</li> </ul> <p>Security Considerations:</p> <ul> <li>Minimal Assignment: Only assign superuser status when absolutely necessary</li> <li>Regular Audits: Periodically review who has superuser access</li> <li>Activity Logging: Log all superuser actions for security monitoring</li> <li>Time-Limited Access: Consider temporary superuser elevation for specific tasks</li> </ul>"},{"location":"user-guide/authentication/permissions/#resource-ownership","title":"Resource Ownership","text":"<p>Resource ownership ensures users can only access and modify their own data. This is the most common authorization pattern in user-facing applications.</p> <pre><code>@router.get(\"/posts/me/\")\nasync def get_my_posts(\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; list[PostRead]:\n    # Get posts owned by current user\n    posts = await crud_posts.get_multi(\n        db=db,\n        created_by_user_id=current_user[\"id\"],\n        schema_to_select=PostRead,\n        return_as_model=True\n    )\n    return posts.data\n\n@router.delete(\"/posts/{post_id}\")\nasync def delete_post(\n    post_id: int,\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict[str, str]:\n    # 1. Get the post\n    post = await crud_posts.get(db=db, id=post_id)\n    if not post:\n        raise NotFoundException(\"Post not found\")\n\n    # 2. Check ownership\n    if post[\"created_by_user_id\"] != current_user[\"id\"]:\n        raise ForbiddenException(\"You can only delete your own posts\")\n\n    # 3. Delete the post\n    await crud_posts.delete(db=db, id=post_id)\n    return {\"message\": \"Post deleted\"}\n</code></pre> <p>Ownership Validation Pattern:</p> <ol> <li>Retrieve Resource: Get the resource from the database</li> <li>Check Ownership: Compare resource owner with current user</li> <li>Authorize or Deny: Allow action if user owns resource, deny otherwise</li> </ol>"},{"location":"user-guide/authentication/permissions/#user-tiers-and-rate-limiting","title":"User Tiers and Rate Limiting","text":"<p>User tiers provide differentiated access based on subscription levels or user status. This enables business models with different feature sets for different user types.</p> <pre><code>@router.post(\"/posts/\", response_model=PostRead)\nasync def create_post(\n    post: PostCreate,\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; PostRead:\n    # Check rate limits based on user tier\n    await check_rate_limit(\n        resource=\"posts\", \n        user_id=current_user[\"id\"], \n        tier_id=current_user.get(\"tier_id\"),\n        db=db\n    )\n\n    # Create post with user association\n    post_internal = PostCreateInternal(\n        **post.model_dump(),\n        created_by_user_id=current_user[\"id\"]\n    )\n\n    created_post = await crud_posts.create(db=db, object=post_internal)\n    return created_post\n</code></pre> <p>Rate Limiting Implementation:</p> <pre><code>async def check_rate_limit(\n    resource: str, \n    user_id: int, \n    tier_id: int | None, \n    db: AsyncSession\n) -&gt; None:\n    # 1. Get user's tier information\n    if tier_id:\n        tier = await crud_tiers.get(db=db, id=tier_id)\n        limit = tier[\"rate_limit_posts\"] if tier else 10  # Default limit\n    else:\n        limit = 5  # Free tier limit\n\n    # 2. Count recent posts (last 24 hours)\n    recent_posts = await crud_posts.count(\n        db=db,\n        created_by_user_id=user_id,\n        created_at__gte=datetime.utcnow() - timedelta(hours=24)\n    )\n\n    # 3. Check if limit exceeded\n    if recent_posts &gt;= limit:\n        raise RateLimitException(f\"Daily {resource} limit exceeded ({limit})\")\n</code></pre> <p>Tier-Based Authorization Benefits:</p> <ul> <li>Business Model Support: Different features for different subscription levels  </li> <li>Resource Protection: Prevents abuse by limiting free tier usage</li> <li>Progressive Enhancement: Encourages upgrades by showing tier benefits</li> <li>Fair Usage: Ensures equitable resource distribution among users</li> </ul>"},{"location":"user-guide/authentication/permissions/#custom-permission-helpers","title":"Custom Permission Helpers","text":"<p>Custom permission functions provide reusable authorization logic for complex scenarios.</p> <pre><code># Permission helper functions\nasync def can_edit_post(user: dict, post_id: int, db: AsyncSession) -&gt; bool:\n    \"\"\"Check if user can edit a specific post.\"\"\"\n    post = await crud_posts.get(db=db, id=post_id)\n    if not post:\n        return False\n\n    # Superusers can edit any post\n    if user.get(\"is_superuser\", False):\n        return True\n\n    # Users can edit their own posts\n    if post[\"created_by_user_id\"] == user[\"id\"]:\n        return True\n\n    return False\n\nasync def can_access_admin_panel(user: dict) -&gt; bool:\n    \"\"\"Check if user can access admin panel.\"\"\"\n    return user.get(\"is_superuser\", False)\n\nasync def has_tier_feature(user: dict, feature: str, db: AsyncSession) -&gt; bool:\n    \"\"\"Check if user's tier includes a specific feature.\"\"\"\n    tier_id = user.get(\"tier_id\")\n    if not tier_id:\n        return False  # Free tier - no premium features\n\n    tier = await crud_tiers.get(db=db, id=tier_id)\n    if not tier:\n        return False\n\n    # Check tier features (example)\n    return tier.get(f\"allows_{feature}\", False)\n\n# Usage in endpoints\n@router.put(\"/posts/{post_id}\")\nasync def update_post(\n    post_id: int,\n    post_updates: PostUpdate,\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; PostRead:\n    # Use permission helper\n    if not await can_edit_post(current_user, post_id, db):\n        raise ForbiddenException(\"Cannot edit this post\")\n\n    updated_post = await crud_posts.update(\n        db=db, \n        object=post_updates, \n        id=post_id\n    )\n    return updated_post\n</code></pre> <p>Permission Helper Benefits:</p> <ul> <li>Reusability: Same logic used across multiple endpoints</li> <li>Consistency: Ensures uniform permission checking</li> <li>Maintainability: Changes to permissions only need updates in one place</li> <li>Testability: Permission logic can be unit tested separately</li> </ul>"},{"location":"user-guide/authentication/permissions/#authorization-dependencies","title":"Authorization Dependencies","text":""},{"location":"user-guide/authentication/permissions/#basic-authorization-dependencies","title":"Basic Authorization Dependencies","text":"<pre><code># Required authentication\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict:\n    \"\"\"Get currently authenticated user.\"\"\"\n    token_data = await verify_token(token, TokenType.ACCESS, db)\n    if not token_data:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    user = await crud_users.get(db=db, username=token_data.username_or_email)\n    if not user:\n        raise HTTPException(status_code=401, detail=\"User not found\")\n\n    return user\n\n# Optional authentication\nasync def get_optional_user(\n    token: str = Depends(optional_oauth2_scheme),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict | None:\n    \"\"\"Get currently authenticated user, or None if not authenticated.\"\"\"\n    if not token:\n        return None\n\n    try:\n        return await get_current_user(token=token, db=db)\n    except HTTPException:\n        return None\n\n# Superuser requirement\nasync def get_current_superuser(\n    current_user: dict = Depends(get_current_user)\n) -&gt; dict:\n    \"\"\"Get current user and ensure they are a superuser.\"\"\"\n    if not current_user.get(\"is_superuser\", False):\n        raise HTTPException(status_code=403, detail=\"Not enough permissions\")\n    return current_user\n</code></pre>"},{"location":"user-guide/authentication/permissions/#advanced-authorization-dependencies","title":"Advanced Authorization Dependencies","text":"<pre><code># Tier-based access control\ndef require_tier(minimum_tier: str):\n    \"\"\"Factory function for tier-based dependencies.\"\"\"\n    async def check_user_tier(\n        current_user: dict = Depends(get_current_user),\n        db: AsyncSession = Depends(async_get_db)\n    ) -&gt; dict:\n        tier_id = current_user.get(\"tier_id\")\n        if not tier_id:\n            raise HTTPException(status_code=403, detail=\"No subscription tier\")\n\n        tier = await crud_tiers.get(db=db, id=tier_id)\n        if not tier or tier[\"name\"] != minimum_tier:\n            raise HTTPException(\n                status_code=403, \n                detail=f\"Requires {minimum_tier} tier\"\n            )\n\n        return current_user\n\n    return check_user_tier\n\n# Resource ownership dependency\ndef require_resource_ownership(resource_type: str):\n    \"\"\"Factory function for resource ownership dependencies.\"\"\"\n    async def check_ownership(\n        resource_id: int,\n        current_user: dict = Depends(get_current_user),\n        db: AsyncSession = Depends(async_get_db)\n    ) -&gt; dict:\n        if resource_type == \"post\":\n            resource = await crud_posts.get(db=db, id=resource_id)\n            owner_field = \"created_by_user_id\"\n        else:\n            raise ValueError(f\"Unknown resource type: {resource_type}\")\n\n        if not resource:\n            raise HTTPException(status_code=404, detail=\"Resource not found\")\n\n        # Superusers can access any resource\n        if current_user.get(\"is_superuser\", False):\n            return current_user\n\n        # Check ownership\n        if resource[owner_field] != current_user[\"id\"]:\n            raise HTTPException(\n                status_code=403, \n                detail=\"You don't own this resource\"\n            )\n\n        return current_user\n\n    return check_ownership\n\n# Usage examples\n@router.get(\"/premium-feature\", dependencies=[Depends(require_tier(\"Premium\"))])\nasync def premium_feature():\n    return {\"message\": \"Premium feature accessed\"}\n\n@router.put(\"/posts/{post_id}\")\nasync def update_post(\n    post_id: int,\n    post_update: PostUpdate,\n    current_user: dict = Depends(require_resource_ownership(\"post\")),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; PostRead:\n    # User ownership already verified by dependency\n    updated_post = await crud_posts.update(db=db, object=post_update, id=post_id)\n    return updated_post\n</code></pre>"},{"location":"user-guide/authentication/permissions/#security-best-practices","title":"Security Best Practices","text":""},{"location":"user-guide/authentication/permissions/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<p>Always grant the minimum permissions necessary for users to complete their tasks.</p> <p>Implementation:</p> <ul> <li>Default Deny: Start with no permissions and explicitly grant what's needed</li> <li>Regular Review: Periodically audit user permissions and remove unnecessary access</li> <li>Role Segregation: Separate administrative and user-facing permissions</li> <li>Temporary Elevation: Use temporary permissions for one-time administrative tasks</li> </ul>"},{"location":"user-guide/authentication/permissions/#defense-in-depth","title":"Defense in Depth","text":"<p>Implement multiple layers of authorization checks throughout your application.</p> <p>Authorization Layers:</p> <ol> <li>API Gateway: Route-level permission checks</li> <li>Endpoint Dependencies: FastAPI dependency injection for common patterns</li> <li>Business Logic: Method-level permission validation</li> <li>Database: Row-level security where applicable</li> </ol>"},{"location":"user-guide/authentication/permissions/#input-validation-and-sanitization","title":"Input Validation and Sanitization","text":"<p>Always validate and sanitize user input, even from authorized users.</p> <pre><code>@router.post(\"/admin/users/{user_id}/tier\")\nasync def update_user_tier(\n    user_id: int,\n    tier_update: UserTierUpdate,\n    current_user: dict = Depends(get_current_superuser),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict[str, str]:\n    # 1. Validate tier exists\n    tier = await crud_tiers.get(db=db, id=tier_update.tier_id)\n    if not tier:\n        raise NotFoundException(\"Tier not found\")\n\n    # 2. Validate user exists\n    user = await crud_users.get(db=db, id=user_id)\n    if not user:\n        raise NotFoundException(\"User not found\")\n\n    # 3. Prevent self-demotion (optional business rule)\n    if user_id == current_user[\"id\"] and tier[\"name\"] == \"free\":\n        raise ForbiddenException(\"Cannot demote yourself to free tier\")\n\n    # 4. Update user tier\n    await crud_users.update(\n        db=db, \n        object={\"tier_id\": tier_update.tier_id}, \n        id=user_id\n    )\n\n    return {\"message\": f\"User tier updated to {tier['name']}\"}\n</code></pre>"},{"location":"user-guide/authentication/permissions/#audit-logging","title":"Audit Logging","text":"<p>Log all significant authorization decisions for security monitoring and compliance.</p> <pre><code>import logging\n\nsecurity_logger = logging.getLogger(\"security\")\n\nasync def log_authorization_event(\n    user_id: int,\n    action: str,\n    resource: str,\n    result: str,\n    details: dict = None\n):\n    \"\"\"Log authorization events for security auditing.\"\"\"\n    security_logger.info(\n        f\"Authorization {result}: User {user_id} attempted {action} on {resource}\",\n        extra={\n            \"user_id\": user_id,\n            \"action\": action,\n            \"resource\": resource,\n            \"result\": result,\n            \"details\": details or {}\n        }\n    )\n\n# Usage in permission checks\nasync def delete_user_account(user_id: int, current_user: dict, db: AsyncSession):\n    if current_user[\"id\"] != user_id and not current_user.get(\"is_superuser\"):\n        await log_authorization_event(\n            user_id=current_user[\"id\"],\n            action=\"delete_account\",\n            resource=f\"user:{user_id}\",\n            result=\"denied\",\n            details={\"reason\": \"insufficient_permissions\"}\n        )\n        raise ForbiddenException(\"Cannot delete other users' accounts\")\n\n    await log_authorization_event(\n        user_id=current_user[\"id\"],\n        action=\"delete_account\", \n        resource=f\"user:{user_id}\",\n        result=\"granted\"\n    )\n\n    # Proceed with deletion\n    await crud_users.delete(db=db, id=user_id)\n</code></pre>"},{"location":"user-guide/authentication/permissions/#common-authorization-patterns","title":"Common Authorization Patterns","text":""},{"location":"user-guide/authentication/permissions/#multi-tenant-authorization","title":"Multi-Tenant Authorization","text":"<p>For applications serving multiple organizations or tenants:</p> <pre><code>@router.get(\"/organizations/{org_id}/users/\")\nasync def get_organization_users(\n    org_id: int,\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db)\n) -&gt; list[UserRead]:\n    # Check if user belongs to organization\n    membership = await crud_org_members.get(\n        db=db,\n        organization_id=org_id,\n        user_id=current_user[\"id\"]\n    )\n\n    if not membership:\n        raise ForbiddenException(\"Not a member of this organization\")\n\n    # Check if user has admin role in organization\n    if membership.role not in [\"admin\", \"owner\"]:\n        raise ForbiddenException(\"Insufficient organization permissions\")\n\n    # Get organization users\n    users = await crud_users.get_multi(\n        db=db,\n        organization_id=org_id,\n        schema_to_select=UserRead,\n        return_as_model=True\n    )\n\n    return users.data\n</code></pre>"},{"location":"user-guide/authentication/permissions/#time-based-permissions","title":"Time-Based Permissions","text":"<p>For permissions that change based on time or schedule:</p> <pre><code>from datetime import datetime, time\n\nasync def check_business_hours_access(user: dict) -&gt; bool:\n    \"\"\"Check if user can access during business hours only.\"\"\"\n    now = datetime.now()\n    business_start = time(9, 0)  # 9 AM\n    business_end = time(17, 0)   # 5 PM\n\n    # Superusers can always access\n    if user.get(\"is_superuser\", False):\n        return True\n\n    # Regular users only during business hours\n    current_time = now.time()\n    return business_start &lt;= current_time &lt;= business_end\n\n# Usage in dependency\nasync def require_business_hours(\n    current_user: dict = Depends(get_current_user)\n) -&gt; dict:\n    \"\"\"Require access during business hours for non-admin users.\"\"\"\n    if not await check_business_hours_access(current_user):\n        raise ForbiddenException(\"Access only allowed during business hours\")\n    return current_user\n\n@router.post(\"/business-operation\", dependencies=[Depends(require_business_hours)])\nasync def business_operation():\n    return {\"message\": \"Business operation completed\"}\n</code></pre>"},{"location":"user-guide/authentication/permissions/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>For more complex permission systems:</p> <pre><code># Role definitions\nclass Role(str, Enum):\n    USER = \"user\"\n    MODERATOR = \"moderator\" \n    ADMIN = \"admin\"\n    SUPERUSER = \"superuser\"\n\n# Permission checking\ndef has_role(user: dict, required_role: Role) -&gt; bool:\n    \"\"\"Check if user has required role or higher.\"\"\"\n    role_hierarchy = {\n        Role.USER: 0,\n        Role.MODERATOR: 1,\n        Role.ADMIN: 2,\n        Role.SUPERUSER: 3\n    }\n\n    user_role = Role(user.get(\"role\", \"user\"))\n    return role_hierarchy[user_role] &gt;= role_hierarchy[required_role]\n\n# Role-based dependency\ndef require_role(minimum_role: Role):\n    \"\"\"Factory for role-based dependencies.\"\"\"\n    async def check_role(current_user: dict = Depends(get_current_user)) -&gt; dict:\n        if not has_role(current_user, minimum_role):\n            raise HTTPException(\n                status_code=403,\n                detail=f\"Requires {minimum_role.value} role or higher\"\n            )\n        return current_user\n\n    return check_role\n\n# Usage\n@router.delete(\"/posts/{post_id}\", dependencies=[Depends(require_role(Role.MODERATOR))])\nasync def moderate_delete_post(post_id: int, db: AsyncSession = Depends(async_get_db)):\n    await crud_posts.delete(db=db, id=post_id)\n    return {\"message\": \"Post deleted by moderator\"}\n</code></pre>"},{"location":"user-guide/authentication/permissions/#feature-flags-and-permissions","title":"Feature Flags and Permissions","text":"<p>For gradual feature rollouts:</p> <pre><code>async def has_feature_access(user: dict, feature: str, db: AsyncSession) -&gt; bool:\n    \"\"\"Check if user has access to a specific feature.\"\"\"\n    # Check feature flags\n    feature_flag = await crud_feature_flags.get(db=db, name=feature)\n    if not feature_flag or not feature_flag.enabled:\n        return False\n\n    # Check user tier permissions\n    if feature_flag.requires_tier:\n        tier_id = user.get(\"tier_id\")\n        if not tier_id:\n            return False\n\n        tier = await crud_tiers.get(db=db, id=tier_id)\n        if not tier or tier[\"level\"] &lt; feature_flag[\"minimum_tier_level\"]:\n            return False\n\n    # Check beta user status\n    if feature_flag.beta_only:\n        return user.get(\"is_beta_user\", False)\n\n    return True\n\n# Feature flag dependency\ndef require_feature(feature_name: str):\n    \"\"\"Factory for feature flag dependencies.\"\"\"\n    async def check_feature_access(\n        current_user: dict = Depends(get_current_user),\n        db: AsyncSession = Depends(async_get_db)\n    ) -&gt; dict:\n        if not await has_feature_access(current_user, feature_name, db):\n            raise HTTPException(\n                status_code=403,\n                detail=f\"Access to {feature_name} feature not available\"\n            )\n        return current_user\n\n    return check_feature_access\n\n@router.get(\"/beta-feature\", dependencies=[Depends(require_feature(\"beta_analytics\"))])\nasync def get_beta_analytics():\n    return {\"analytics\": \"beta_data\"}\n</code></pre> <p>This comprehensive permissions system provides flexible, secure authorization patterns that can be adapted to your specific application requirements while maintaining security best practices.</p>"},{"location":"user-guide/authentication/user-management/","title":"User Management","text":"<p>User management forms the core of any authentication system, handling everything from user registration and login to profile updates and account deletion. This section covers the complete user lifecycle with secure authentication flows and administrative operations.</p>"},{"location":"user-guide/authentication/user-management/#understanding-user-lifecycle","title":"Understanding User Lifecycle","text":"<p>The user lifecycle in the boilerplate follows a secure, well-defined process that protects user data while providing a smooth experience. Understanding this flow helps you customize the system for your specific needs.</p> <p>Registration \u2192 Authentication \u2192 Profile Management \u2192 Administrative Operations</p> <p>Each stage has specific security considerations and business logic that ensure data integrity and user safety.</p>"},{"location":"user-guide/authentication/user-management/#user-registration","title":"User Registration","text":"<p>User registration is the entry point to your application. The process must be secure, user-friendly, and prevent common issues like duplicate accounts or weak passwords.</p>"},{"location":"user-guide/authentication/user-management/#registration-process","title":"Registration Process","text":"<p>The registration endpoint performs several validation steps before creating a user account. This multi-step validation prevents common registration issues and ensures data quality.</p> <pre><code># User registration endpoint\n@router.post(\"/user\", response_model=UserRead, status_code=201)\nasync def write_user(\n    user: UserCreate, \n    db: AsyncSession\n) -&gt; UserRead:\n    # 1. Check if email exists\n    email_row = await crud_users.exists(db=db, email=user.email)\n    if email_row:\n        raise DuplicateValueException(\"Email is already registered\")\n\n    # 2. Check if username exists\n    username_row = await crud_users.exists(db=db, username=user.username)\n    if username_row:\n        raise DuplicateValueException(\"Username not available\")\n\n    # 3. Hash password\n    user_internal_dict = user.model_dump()\n    user_internal_dict[\"hashed_password\"] = get_password_hash(\n        password=user_internal_dict[\"password\"]\n    )\n    del user_internal_dict[\"password\"]\n\n    # 4. Create user\n    user_internal = UserCreateInternal(**user_internal_dict)\n    created_user = await crud_users.create(db=db, object=user_internal)\n\n    return created_user\n</code></pre> <p>Security Steps Explained:</p> <ol> <li>Email Uniqueness: Prevents multiple accounts with the same email, which could cause confusion and security issues</li> <li>Username Uniqueness: Ensures usernames are unique identifiers within your system</li> <li>Password Hashing: Converts plain text passwords into secure hashes before database storage</li> <li>Data Separation: Plain text passwords are immediately removed from memory after hashing</li> </ol>"},{"location":"user-guide/authentication/user-management/#registration-schema","title":"Registration Schema","text":"<p>The registration schema defines what data is required and how it's validated. This ensures consistent data quality and prevents malformed user accounts.</p> <pre><code># User registration input\nclass UserCreate(UserBase):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    password: Annotated[\n        str,\n        Field(\n            pattern=r\"^.{8,}|[0-9]+|[A-Z]+|[a-z]+|[^a-zA-Z0-9]+$\",\n            examples=[\"Str1ngst!\"]\n        )\n    ]\n\n# Internal schema for database storage\nclass UserCreateInternal(UserBase):\n    hashed_password: str\n</code></pre> <p>Schema Design Principles:</p> <ul> <li><code>extra=\"forbid\"</code>: Rejects unexpected fields, preventing injection of unauthorized data</li> <li>Password Patterns: Enforces minimum security requirements for passwords</li> <li>Separation of Concerns: External schema accepts passwords, internal schema stores hashes</li> </ul>"},{"location":"user-guide/authentication/user-management/#user-authentication","title":"User Authentication","text":"<p>Authentication verifies user identity using credentials. The process must be secure against common attacks while remaining user-friendly.</p>"},{"location":"user-guide/authentication/user-management/#authentication-process","title":"Authentication Process","text":"<pre><code>async def authenticate_user(username_or_email: str, password: str, db: AsyncSession) -&gt; dict | False:\n    # 1. Get user by email or username\n    if \"@\" in username_or_email:\n        db_user = await crud_users.get(db=db, email=username_or_email, is_deleted=False)\n    else:\n        db_user = await crud_users.get(db=db, username=username_or_email, is_deleted=False)\n\n    if not db_user:\n        return False\n\n    # 2. Verify password\n    if not await verify_password(password, db_user[\"hashed_password\"]):\n        return False\n\n    return db_user\n</code></pre> <p>Security Considerations:</p> <ul> <li>Flexible Login: Accepts both username and email for better user experience</li> <li>Soft Delete Check: <code>is_deleted=False</code> prevents deleted users from logging in</li> <li>Consistent Timing: Both user lookup and password verification take similar time</li> </ul>"},{"location":"user-guide/authentication/user-management/#password-security","title":"Password Security","text":"<p>Password security is critical for protecting user accounts. The system uses industry-standard bcrypt hashing with automatic salt generation.</p> <pre><code>import bcrypt\n\nasync def verify_password(plain_password: str, hashed_password: str) -&gt; bool:\n    \"\"\"Verify a plain password against its hash.\"\"\"\n    correct_password: bool = bcrypt.checkpw(\n        plain_password.encode(), \n        hashed_password.encode()\n    )\n    return correct_password\n\ndef get_password_hash(password: str) -&gt; str:\n    \"\"\"Generate password hash with salt.\"\"\"\n    hashed_password: str = bcrypt.hashpw(\n        password.encode(), \n        bcrypt.gensalt()\n    ).decode()\n    return hashed_password\n</code></pre> <p>Why bcrypt?</p> <ul> <li>Adaptive Hashing: Computationally expensive, making brute force attacks impractical</li> <li>Automatic Salt: Each password gets a unique salt, preventing rainbow table attacks</li> <li>Future-Proof: Can increase computational cost as hardware improves</li> </ul>"},{"location":"user-guide/authentication/user-management/#login-validation","title":"Login Validation","text":"<p>Client-side validation provides immediate feedback but should never be the only validation layer.</p> <pre><code># Password validation pattern\nPASSWORD_PATTERN = r\"^.{8,}|[0-9]+|[A-Z]+|[a-z]+|[^a-zA-Z0-9]+$\"\n\n# Frontend validation (example)\nfunction validatePassword(password) {\n    const minLength = password.length &gt;= 8;\n    const hasNumber = /[0-9]/.test(password);\n    const hasUpper = /[A-Z]/.test(password);\n    const hasLower = /[a-z]/.test(password);\n    const hasSpecial = /[^a-zA-Z0-9]/.test(password);\n\n    return minLength &amp;&amp; hasNumber &amp;&amp; hasUpper &amp;&amp; hasLower &amp;&amp; hasSpecial;\n}\n</code></pre> <p>Validation Strategy:</p> <ul> <li>Server-Side: Always validate on the server - client validation can be bypassed</li> <li>Client-Side: Provides immediate feedback for better user experience</li> <li>Progressive: Validate as user types to catch issues early</li> </ul>"},{"location":"user-guide/authentication/user-management/#profile-management","title":"Profile Management","text":"<p>Profile management allows users to update their information while maintaining security and data integrity.</p>"},{"location":"user-guide/authentication/user-management/#get-current-user-profile","title":"Get Current User Profile","text":"<p>Retrieving the current user's profile is a fundamental operation that should be fast and secure.</p> <pre><code>@router.get(\"/user/me/\", response_model=UserRead)\nasync def read_users_me(current_user: dict = Depends(get_current_user)) -&gt; dict:\n    return current_user\n\n# Frontend usage\nasync function getCurrentUser() {\n    const token = localStorage.getItem('access_token');\n    const response = await fetch('/api/v1/user/me/', {\n        headers: {\n            'Authorization': `Bearer ${token}`\n        }\n    });\n\n    if (response.ok) {\n        return await response.json();\n    }\n    throw new Error('Failed to get user profile');\n}\n</code></pre> <p>Design Decisions:</p> <ul> <li><code>/me</code> Endpoint: Common pattern that's intuitive for users and developers</li> <li>Current User Dependency: Automatically handles authentication and user lookup</li> <li>Minimal Data: Returns only safe, user-relevant information</li> </ul>"},{"location":"user-guide/authentication/user-management/#update-user-profile","title":"Update User Profile","text":"<p>Profile updates require careful validation to prevent unauthorized changes and maintain data integrity.</p> <pre><code>@router.patch(\"/user/{username}\")\nasync def patch_user(\n    values: UserUpdate,\n    username: str,\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db),\n) -&gt; dict[str, str]:\n    # 1. Get user from database\n    db_user = await crud_users.get(db=db, username=username, schema_to_select=UserRead)\n    if db_user is None:\n        raise NotFoundException(\"User not found\")\n\n    # 2. Check ownership (users can only update their own profile)\n    if db_user[\"username\"] != current_user[\"username\"]:\n        raise ForbiddenException(\"Cannot update other users\")\n\n    # 3. Validate unique constraints\n    if values.username and values.username != db_user[\"username\"]:\n        existing_username = await crud_users.exists(db=db, username=values.username)\n        if existing_username:\n            raise DuplicateValueException(\"Username not available\")\n\n    if values.email and values.email != db_user[\"email\"]:\n        existing_email = await crud_users.exists(db=db, email=values.email)\n        if existing_email:\n            raise DuplicateValueException(\"Email is already registered\")\n\n    # 4. Update user\n    await crud_users.update(db=db, object=values, username=username)\n    return {\"message\": \"User updated\"}\n</code></pre> <p>Security Measures:</p> <ol> <li>Ownership Verification: Users can only update their own profiles</li> <li>Uniqueness Checks: Prevents conflicts when changing username/email</li> <li>Partial Updates: Only provided fields are updated</li> <li>Input Validation: Pydantic schemas validate all input data</li> </ol>"},{"location":"user-guide/authentication/user-management/#user-deletion","title":"User Deletion","text":"<p>User deletion requires careful consideration of data retention, user rights, and system integrity.</p>"},{"location":"user-guide/authentication/user-management/#self-deletion","title":"Self-Deletion","text":"<p>Users should be able to delete their own accounts, but the process should be secure and potentially reversible.</p> <pre><code>@router.delete(\"/user/{username}\")\nasync def erase_user(\n    username: str,\n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db),\n    token: str = Depends(oauth2_scheme),\n) -&gt; dict[str, str]:\n    # 1. Get user from database\n    db_user = await crud_users.get(db=db, username=username, schema_to_select=UserRead)\n    if not db_user:\n        raise NotFoundException(\"User not found\")\n\n    # 2. Check ownership\n    if username != current_user[\"username\"]:\n        raise ForbiddenException()\n\n    # 3. Soft delete user\n    await crud_users.delete(db=db, username=username)\n\n    # 4. Blacklist current token\n    await blacklist_token(token=token, db=db)\n\n    return {\"message\": \"User deleted\"}\n</code></pre> <p>Soft Delete Benefits:</p> <ul> <li>Data Recovery: Users can be restored if needed</li> <li>Audit Trail: Maintain records for compliance</li> <li>Relationship Integrity: Related data (posts, comments) remain accessible</li> <li>Gradual Cleanup: Allow time for data migration or backup</li> </ul>"},{"location":"user-guide/authentication/user-management/#admin-deletion-hard-delete","title":"Admin Deletion (Hard Delete)","text":"<p>Administrators may need to permanently remove users in specific circumstances.</p> <pre><code>@router.delete(\"/db_user/{username}\", dependencies=[Depends(get_current_superuser)])\nasync def erase_db_user(\n    username: str,\n    db: AsyncSession = Depends(async_get_db),\n    token: str = Depends(oauth2_scheme),\n) -&gt; dict[str, str]:\n    # 1. Check if user exists\n    db_user = await crud_users.exists(db=db, username=username)\n    if not db_user:\n        raise NotFoundException(\"User not found\")\n\n    # 2. Hard delete from database\n    await crud_users.db_delete(db=db, username=username)\n\n    # 3. Blacklist current token\n    await blacklist_token(token=token, db=db)\n\n    return {\"message\": \"User deleted from the database\"}\n</code></pre> <p>When to Use Hard Delete:</p> <ul> <li>Legal Requirements: GDPR \"right to be forgotten\" requests</li> <li>Data Breach Response: Complete removal of compromised accounts</li> <li>Spam/Abuse: Permanent removal of malicious accounts</li> </ul>"},{"location":"user-guide/authentication/user-management/#administrative-operations","title":"Administrative Operations","text":""},{"location":"user-guide/authentication/user-management/#list-all-users","title":"List All Users","text":"<pre><code>@router.get(\"/users\", response_model=PaginatedListResponse[UserRead])\nasync def read_users(\n    db: AsyncSession = Depends(async_get_db), \n    page: int = 1, \n    items_per_page: int = 10\n) -&gt; dict:\n    users_data = await crud_users.get_multi(\n        db=db,\n        offset=compute_offset(page, items_per_page),\n        limit=items_per_page,\n        is_deleted=False,\n    )\n\n    response: dict[str, Any] = paginated_response(\n        crud_data=users_data, \n        page=page, \n        items_per_page=items_per_page\n    )\n    return response\n</code></pre>"},{"location":"user-guide/authentication/user-management/#get-user-by-username","title":"Get User by Username","text":"<pre><code>@router.get(\"/user/{username}\", response_model=UserRead)\nasync def read_user(\n    username: str, \n    db: AsyncSession = Depends(async_get_db)\n) -&gt; UserRead:\n    db_user = await crud_users.get(\n        db=db, \n        username=username, \n        is_deleted=False, \n        schema_to_select=UserRead\n    )\n    if db_user is None:\n        raise NotFoundException(\"User not found\")\n\n    return db_user\n</code></pre>"},{"location":"user-guide/authentication/user-management/#user-with-tier-information","title":"User with Tier Information","text":"<pre><code>@router.get(\"/user/{username}/tier\")\nasync def read_user_tier(\n    username: str, \n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict | None:\n    # 1. Get user\n    db_user = await crud_users.get(db=db, username=username, schema_to_select=UserRead)\n    if db_user is None:\n        raise NotFoundException(\"User not found\")\n\n    # 2. Return None if no tier assigned\n    if db_user[\"tier_id\"] is None:\n        return None\n\n    # 3. Get tier information\n    db_tier = await crud_tiers.get(db=db, id=db_user[\"tier_id\"], schema_to_select=TierRead)\n    if not db_tier:\n        raise NotFoundException(\"Tier not found\")\n\n    # 4. Combine user and tier data\n    user_dict = dict(db_user)  # Convert to dict if needed\n    tier_dict = dict(db_tier)  # Convert to dict if needed\n\n    for key, value in tier_dict.items():\n        user_dict[f\"tier_{key}\"] = value\n\n    return user_dict\n</code></pre>"},{"location":"user-guide/authentication/user-management/#user-tiers-and-permissions","title":"User Tiers and Permissions","text":""},{"location":"user-guide/authentication/user-management/#assign-user-tier","title":"Assign User Tier","text":"<pre><code>@router.patch(\"/user/{username}/tier\", dependencies=[Depends(get_current_superuser)])\nasync def patch_user_tier(\n    username: str, \n    values: UserTierUpdate, \n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict[str, str]:\n    # 1. Verify user exists\n    db_user = await crud_users.get(db=db, username=username, schema_to_select=UserRead)\n    if db_user is None:\n        raise NotFoundException(\"User not found\")\n\n    # 2. Verify tier exists\n    tier_exists = await crud_tiers.exists(db=db, id=values.tier_id)\n    if not tier_exists:\n        raise NotFoundException(\"Tier not found\")\n\n    # 3. Update user tier\n    await crud_users.update(db=db, object=values, username=username)\n    return {\"message\": \"User tier updated\"}\n\n# Tier update schema\nclass UserTierUpdate(BaseModel):\n    tier_id: int\n</code></pre>"},{"location":"user-guide/authentication/user-management/#user-rate-limits","title":"User Rate Limits","text":"<pre><code>@router.get(\"/user/{username}/rate_limits\", dependencies=[Depends(get_current_superuser)])\nasync def read_user_rate_limits(\n    username: str, \n    db: AsyncSession = Depends(async_get_db)\n) -&gt; dict[str, Any]:\n    # 1. Get user\n    db_user = await crud_users.get(db=db, username=username, schema_to_select=UserRead)\n    if db_user is None:\n        raise NotFoundException(\"User not found\")\n\n    user_dict = dict(db_user)  # Convert to dict if needed\n\n    # 2. No tier assigned\n    if db_user[\"tier_id\"] is None:\n        user_dict[\"tier_rate_limits\"] = []\n        return user_dict\n\n    # 3. Get tier and rate limits\n    db_tier = await crud_tiers.get(db=db, id=db_user[\"tier_id\"], schema_to_select=TierRead)\n    if db_tier is None:\n        raise NotFoundException(\"Tier not found\")\n\n    db_rate_limits = await crud_rate_limits.get_multi(db=db, tier_id=db_tier[\"id\"])\n    user_dict[\"tier_rate_limits\"] = db_rate_limits[\"data\"]\n\n    return user_dict\n</code></pre>"},{"location":"user-guide/authentication/user-management/#user-model-structure","title":"User Model Structure","text":""},{"location":"user-guide/authentication/user-management/#database-model","title":"Database Model","text":"<pre><code>class User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(30))\n    username: Mapped[str] = mapped_column(String(20), unique=True, index=True)\n    email: Mapped[str] = mapped_column(String(50), unique=True, index=True)\n    hashed_password: Mapped[str]\n    profile_image_url: Mapped[str] = mapped_column(default=\"https://www.profileimageurl.com\")\n    is_superuser: Mapped[bool] = mapped_column(default=False)\n    tier_id: Mapped[int | None] = mapped_column(ForeignKey(\"tier.id\"), default=None)\n\n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n    updated_at: Mapped[datetime | None] = mapped_column(default=None)\n\n    # Soft delete\n    is_deleted: Mapped[bool] = mapped_column(default=False)\n    deleted_at: Mapped[datetime | None] = mapped_column(default=None)\n\n    # Relationships\n    tier: Mapped[\"Tier\"] = relationship(back_populates=\"users\")\n    posts: Mapped[list[\"Post\"]] = relationship(back_populates=\"created_by_user\")\n</code></pre>"},{"location":"user-guide/authentication/user-management/#user-schemas","title":"User Schemas","text":"<pre><code># Base schema with common fields\nclass UserBase(BaseModel):\n    name: Annotated[str, Field(min_length=2, max_length=30)]\n    username: Annotated[str, Field(min_length=2, max_length=20, pattern=r\"^[a-z0-9]+$\")]\n    email: Annotated[EmailStr, Field(examples=[\"user@example.com\"])]\n\n# Reading user data (API responses)\nclass UserRead(BaseModel):\n    id: int\n    name: str\n    username: str\n    email: str\n    profile_image_url: str\n    tier_id: int | None\n\n# Full user data (internal use)\nclass User(TimestampSchema, UserBase, UUIDSchema, PersistentDeletion):\n    profile_image_url: str = \"https://www.profileimageurl.com\"\n    hashed_password: str\n    is_superuser: bool = False\n    tier_id: int | None = None\n</code></pre>"},{"location":"user-guide/authentication/user-management/#common-user-operations","title":"Common User Operations","text":""},{"location":"user-guide/authentication/user-management/#check-user-existence","title":"Check User Existence","text":"<pre><code># By email\nemail_exists = await crud_users.exists(db=db, email=\"user@example.com\")\n\n# By username\nusername_exists = await crud_users.exists(db=db, username=\"johndoe\")\n\n# By ID\nuser_exists = await crud_users.exists(db=db, id=123)\n</code></pre>"},{"location":"user-guide/authentication/user-management/#search-users","title":"Search Users","text":"<pre><code># Get active users only\nactive_users = await crud_users.get_multi(\n    db=db, \n    is_deleted=False,\n    limit=10\n)\n\n# Get users by tier\ntier_users = await crud_users.get_multi(\n    db=db,\n    tier_id=1,\n    is_deleted=False\n)\n\n# Get superusers\nsuperusers = await crud_users.get_multi(\n    db=db,\n    is_superuser=True,\n    is_deleted=False\n)\n</code></pre>"},{"location":"user-guide/authentication/user-management/#user-statistics","title":"User Statistics","text":"<pre><code>async def get_user_stats(db: AsyncSession) -&gt; dict:\n    # Total users\n    total_users = await crud_users.count(db=db, is_deleted=False)\n\n    # Active users (logged in recently)\n    # This would require tracking last_login_at\n\n    # Users by tier\n    tier_stats = {}\n    tiers = await crud_tiers.get_multi(db=db)\n    for tier in tiers[\"data\"]:\n        count = await crud_users.count(db=db, tier_id=tier[\"id\"], is_deleted=False)\n        tier_stats[tier[\"name\"]] = count\n\n    return {\n        \"total_users\": total_users,\n        \"tier_distribution\": tier_stats\n    }\n</code></pre>"},{"location":"user-guide/authentication/user-management/#frontend-integration","title":"Frontend Integration","text":""},{"location":"user-guide/authentication/user-management/#complete-user-management-component","title":"Complete User Management Component","text":"<pre><code>class UserManager {\n    constructor(baseUrl = '/api/v1') {\n        this.baseUrl = baseUrl;\n        this.token = localStorage.getItem('access_token');\n    }\n\n    async register(userData) {\n        const response = await fetch(`${this.baseUrl}/user`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(userData)\n        });\n\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.detail);\n        }\n\n        return await response.json();\n    }\n\n    async login(username, password) {\n        const response = await fetch(`${this.baseUrl}/login`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            body: new URLSearchParams({\n                username: username,\n                password: password\n            })\n        });\n\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.detail);\n        }\n\n        const tokens = await response.json();\n        localStorage.setItem('access_token', tokens.access_token);\n        this.token = tokens.access_token;\n\n        return tokens;\n    }\n\n    async getProfile() {\n        const response = await fetch(`${this.baseUrl}/user/me/`, {\n            headers: {\n                'Authorization': `Bearer ${this.token}`\n            }\n        });\n\n        if (!response.ok) {\n            throw new Error('Failed to get profile');\n        }\n\n        return await response.json();\n    }\n\n    async updateProfile(username, updates) {\n        const response = await fetch(`${this.baseUrl}/user/${username}`, {\n            method: 'PATCH',\n            headers: {\n                'Authorization': `Bearer ${this.token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(updates)\n        });\n\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.detail);\n        }\n\n        return await response.json();\n    }\n\n    async deleteAccount(username) {\n        const response = await fetch(`${this.baseUrl}/user/${username}`, {\n            method: 'DELETE',\n            headers: {\n                'Authorization': `Bearer ${this.token}`\n            }\n        });\n\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.detail);\n        }\n\n        // Clear local storage\n        localStorage.removeItem('access_token');\n        this.token = null;\n\n        return await response.json();\n    }\n\n    async logout() {\n        const response = await fetch(`${this.baseUrl}/logout`, {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${this.token}`\n            }\n        });\n\n        // Clear local storage regardless of response\n        localStorage.removeItem('access_token');\n        this.token = null;\n\n        if (response.ok) {\n            return await response.json();\n        }\n    }\n}\n\n// Usage\nconst userManager = new UserManager();\n\n// Register new user\ntry {\n    const user = await userManager.register({\n        name: \"John Doe\",\n        username: \"johndoe\",\n        email: \"john@example.com\",\n        password: \"SecurePass123!\"\n    });\n    console.log('User registered:', user);\n} catch (error) {\n    console.error('Registration failed:', error.message);\n}\n\n// Login\ntry {\n    const tokens = await userManager.login('johndoe', 'SecurePass123!');\n    console.log('Login successful');\n\n    // Get profile\n    const profile = await userManager.getProfile();\n    console.log('User profile:', profile);\n} catch (error) {\n    console.error('Login failed:', error.message);\n}\n</code></pre>"},{"location":"user-guide/authentication/user-management/#security-considerations","title":"Security Considerations","text":""},{"location":"user-guide/authentication/user-management/#input-validation","title":"Input Validation","text":"<pre><code># Server-side validation\nclass UserCreate(UserBase):\n    password: Annotated[\n        str,\n        Field(\n            min_length=8,\n            pattern=r\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]\",\n            description=\"Password must contain uppercase, lowercase, number, and special character\"\n        )\n    ]\n</code></pre>"},{"location":"user-guide/authentication/user-management/#rate-limiting","title":"Rate Limiting","text":"<pre><code># Protect registration endpoint\n@router.post(\"/user\", dependencies=[Depends(rate_limiter_dependency)])\nasync def write_user(user: UserCreate, db: AsyncSession):\n    # Registration logic\n    pass\n\n# Protect login endpoint\n@router.post(\"/login\", dependencies=[Depends(rate_limiter_dependency)])\nasync def login_for_access_token():\n    # Login logic\n    pass\n</code></pre>"},{"location":"user-guide/authentication/user-management/#data-sanitization","title":"Data Sanitization","text":"<pre><code>def sanitize_user_input(user_data: dict) -&gt; dict:\n    \"\"\"Sanitize user input to prevent XSS and injection.\"\"\"\n    import html\n\n    sanitized = {}\n    for key, value in user_data.items():\n        if isinstance(value, str):\n            # HTML escape\n            sanitized[key] = html.escape(value.strip())\n        else:\n            sanitized[key] = value\n\n    return sanitized\n</code></pre>"},{"location":"user-guide/authentication/user-management/#next-steps","title":"Next Steps","text":"<p>Now that you understand user management:</p> <ol> <li>Permissions - Learn about role-based access control and authorization</li> <li>Production Guide - Implement production-grade security measures</li> <li>JWT Tokens - Review token management if needed</li> </ol> <p>User management provides the core functionality for authentication systems. Master these patterns before implementing advanced permission systems.</p>"},{"location":"user-guide/authentication/user-management/#common-authentication-tasks","title":"Common Authentication Tasks","text":""},{"location":"user-guide/authentication/user-management/#protect-new-endpoints","title":"Protect New Endpoints","text":"<pre><code># Add authentication dependency to your router\n@router.get(\"/my-endpoint\")\nasync def my_endpoint(current_user: dict = Depends(get_current_user)):\n    # Endpoint now requires authentication\n    return {\"user_specific_data\": f\"Hello {current_user['username']}\"}\n\n# Optional authentication for public endpoints\n@router.get(\"/public-endpoint\") \nasync def public_endpoint(user: dict | None = Depends(get_optional_user)):\n    if user:\n        return {\"message\": f\"Hello {user['username']}\", \"premium_features\": True}\n    return {\"message\": \"Hello anonymous user\", \"premium_features\": False}\n</code></pre>"},{"location":"user-guide/authentication/user-management/#complete-authentication-flow","title":"Complete Authentication Flow","text":"<pre><code># 1. User registration\nuser_data = UserCreate(\n    name=\"John Doe\",\n    username=\"johndoe\", \n    email=\"john@example.com\",\n    password=\"SecurePassword123!\"\n)\nuser = await crud_users.create(db=db, object=user_data)\n\n# 2. User login\nform_data = {\"username\": \"johndoe\", \"password\": \"SecurePassword123!\"}\nuser = await authenticate_user(form_data[\"username\"], form_data[\"password\"], db)\n\n# 3. Token generation (handled in login endpoint)\naccess_token = await create_access_token(data={\"sub\": user[\"username\"]})\nrefresh_token = await create_refresh_token(data={\"sub\": user[\"username\"]})\n\n# 4. API access with token\nheaders = {\"Authorization\": f\"Bearer {access_token}\"}\nresponse = requests.get(\"/api/v1/users/me\", headers=headers)\n\n# 5. Token refresh when access token expires\nresponse = requests.post(\"/api/v1/refresh\")  # Uses refresh token cookie\nnew_access_token = response.json()[\"access_token\"]\n\n# 6. Secure logout (blacklists both tokens)  \nawait logout_user(access_token=access_token, refresh_token=refresh_token, db=db)\n</code></pre>"},{"location":"user-guide/authentication/user-management/#check-user-permissions","title":"Check User Permissions","text":"<pre><code>def check_user_permission(user: dict, required_tier: str = None):\n    \"\"\"Check if user has required permissions.\"\"\"\n    if not user.get(\"is_active\", True):\n        raise UnauthorizedException(\"User account is disabled\")\n\n    if required_tier and user.get(\"tier\", {}).get(\"name\") != required_tier:\n        raise ForbiddenException(f\"Requires {required_tier} tier\")\n\n# Usage in endpoint\n@router.get(\"/premium-feature\")\nasync def premium_feature(current_user: dict = Depends(get_current_user)):\n    check_user_permission(current_user, \"Pro\")\n    return {\"premium_data\": \"exclusive_content\"}\n</code></pre>"},{"location":"user-guide/authentication/user-management/#custom-authentication-logic","title":"Custom Authentication Logic","text":"<pre><code>async def get_user_with_posts(current_user: dict = Depends(get_current_user)):\n    \"\"\"Custom dependency that adds user's posts.\"\"\"\n    posts = await crud_posts.get_multi(db=db, created_by_user_id=current_user[\"id\"])\n    current_user[\"posts\"] = posts\n    return current_user\n\n# Usage\n@router.get(\"/dashboard\")\nasync def get_dashboard(user_with_posts: dict = Depends(get_user_with_posts)):\n    return {\n        \"user\": user_with_posts,\n        \"post_count\": len(user_with_posts[\"posts\"])\n    }\n</code></pre>"},{"location":"user-guide/background-tasks/","title":"Background Tasks","text":"<p>The boilerplate includes a robust background task system built on ARQ (Async Redis Queue) for handling long-running operations asynchronously. This enables your API to remain responsive while processing intensive tasks in the background.</p>"},{"location":"user-guide/background-tasks/#overview","title":"Overview","text":"<p>Background tasks are essential for operations that:</p> <ul> <li>Take longer than 2 seconds to complete</li> <li>Don't block user interactions in your frontend</li> <li>Can be processed asynchronously without immediate user feedback</li> <li>Require intensive computation or external API calls</li> </ul>"},{"location":"user-guide/background-tasks/#quick-example","title":"Quick Example","text":"<pre><code># Define a background task\nasync def send_welcome_email(ctx: Worker, user_id: int, email: str) -&gt; str:\n    # Send email logic here\n    await send_email_service(email, \"Welcome!\")\n    return f\"Welcome email sent to {email}\"\n\n# Enqueue the task from an API endpoint\n@router.post(\"/users/\", response_model=UserRead)\nasync def create_user(user_data: UserCreate):\n    # Create user in database\n    user = await crud_users.create(db=db, object=user_data)\n\n    # Queue welcome email in background\n    await queue.pool.enqueue_job(\"send_welcome_email\", user[\"id\"], user[\"email\"])\n\n    return user\n</code></pre>"},{"location":"user-guide/background-tasks/#architecture","title":"Architecture","text":""},{"location":"user-guide/background-tasks/#arq-worker-system","title":"ARQ Worker System","text":"<ul> <li>Redis-Based: Uses Redis as the message broker for job queues</li> <li>Async Processing: Fully asynchronous task execution  </li> <li>Worker Pool: Multiple workers can process tasks concurrently</li> <li>Job Persistence: Tasks survive application restarts</li> </ul>"},{"location":"user-guide/background-tasks/#task-lifecycle","title":"Task Lifecycle","text":"<ol> <li>Enqueue: Tasks are added to Redis queue from API endpoints</li> <li>Processing: ARQ workers pick up and execute tasks</li> <li>Results: Task results are stored and can be retrieved</li> <li>Monitoring: Track task status and execution history</li> </ol>"},{"location":"user-guide/background-tasks/#key-features","title":"Key Features","text":"<p>Scalable Processing - Multiple worker instances for high throughput - Automatic load balancing across workers - Configurable concurrency per worker</p> <p>Reliable Execution - Task retry mechanisms for failed jobs - Dead letter queues for problematic tasks - Graceful shutdown and task cleanup</p> <p>Database Integration - Shared database sessions with main application - CRUD operations available in background tasks - Transaction management and error handling</p>"},{"location":"user-guide/background-tasks/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Email Processing: Welcome emails, notifications, newsletters</li> <li>File Operations: Image processing, PDF generation, file uploads</li> <li>External APIs: Third-party integrations, webhooks, data sync</li> <li>Data Processing: Report generation, analytics, batch operations</li> <li>ML/AI Tasks: Model inference, data analysis, predictions</li> </ul>"},{"location":"user-guide/background-tasks/#getting-started","title":"Getting Started","text":"<p>The boilerplate provides everything needed to start using background tasks immediately. Simply define your task functions, register them in the worker settings, and enqueue them from your API endpoints.</p>"},{"location":"user-guide/background-tasks/#configuration","title":"Configuration","text":"<p>Basic Redis queue configuration:</p> <pre><code># Redis Queue Settings  \nREDIS_QUEUE_HOST=localhost\nREDIS_QUEUE_PORT=6379\n</code></pre> <p>The system automatically handles Redis connection pooling and worker lifecycle management.</p>"},{"location":"user-guide/background-tasks/#next-steps","title":"Next Steps","text":"<p>Check the ARQ documentation for advanced usage patterns and refer to the boilerplate's example implementation in <code>src/app/core/worker/</code> and <code>src/app/api/v1/tasks.py</code>. </p>"},{"location":"user-guide/caching/","title":"Caching","text":"<p>The boilerplate includes a comprehensive caching system built on Redis that improves performance through server-side caching and client-side cache control. This section covers the complete caching implementation.</p>"},{"location":"user-guide/caching/#overview","title":"Overview","text":"<p>The caching system provides multiple layers of optimization:</p> <ul> <li>Server-Side Caching: Redis-based caching with automatic invalidation</li> <li>Client-Side Caching: HTTP cache headers for browser optimization  </li> <li>Cache Invalidation: Smart invalidation strategies for data consistency</li> </ul>"},{"location":"user-guide/caching/#quick-example","title":"Quick Example","text":"<pre><code>from app.core.utils.cache import cache\n\n@router.get(\"/posts/{post_id}\")\n@cache(key_prefix=\"post_cache\", expiration=3600)\nasync def get_post(request: Request, post_id: int):\n    # Cached for 1 hour, automatic invalidation on updates\n    return await crud_posts.get(db=db, id=post_id)\n</code></pre>"},{"location":"user-guide/caching/#architecture","title":"Architecture","text":""},{"location":"user-guide/caching/#server-side-caching","title":"Server-Side Caching","text":"<ul> <li>Redis Integration: Connection pooling and async operations</li> <li>Decorator-Based: Simple <code>@cache</code> decorator for endpoints</li> <li>Smart Invalidation: Automatic cache clearing on data changes</li> <li>Pattern Matching: Bulk invalidation using Redis patterns</li> </ul>"},{"location":"user-guide/caching/#client-side-caching","title":"Client-Side Caching","text":"<ul> <li>HTTP Headers: Cache-Control headers for browser caching</li> <li>Middleware: Automatic header injection</li> <li>Configurable TTL: Customizable cache duration</li> </ul>"},{"location":"user-guide/caching/#key-features","title":"Key Features","text":"<p>Automatic Cache Management - Caches GET requests automatically - Invalidates cache on PUT/POST/DELETE operations - Supports complex invalidation patterns</p> <p>Flexible Configuration - Per-endpoint expiration times - Custom cache key generation - Environment-specific Redis settings</p> <p>Performance Optimization - Connection pooling for Redis - Efficient key pattern matching - Minimal overhead for cache operations</p>"},{"location":"user-guide/caching/#getting-started","title":"Getting Started","text":"<ol> <li>Redis Cache - Server-side caching with Redis</li> <li>Client Cache - Browser caching with HTTP headers  </li> <li>Cache Strategies - Invalidation patterns and best practices</li> </ol> <p>Each section provides detailed implementation examples and configuration options for building a robust caching layer.</p>"},{"location":"user-guide/caching/#configuration","title":"Configuration","text":"<p>Basic Redis configuration in your environment:</p> <pre><code># Redis Cache Settings\nREDIS_CACHE_HOST=localhost\nREDIS_CACHE_PORT=6379\n</code></pre> <p>The caching system automatically handles connection pooling and provides efficient cache operations for your FastAPI endpoints.</p>"},{"location":"user-guide/caching/#next-steps","title":"Next Steps","text":"<p>Start with Redis Cache to understand the core server-side caching implementation, then explore client-side caching and advanced invalidation strategies. </p>"},{"location":"user-guide/caching/cache-strategies/","title":"Cache Strategies","text":"<p>Effective cache strategies balance performance gains with data consistency. This section covers invalidation patterns, cache warming, and optimization techniques for building robust caching systems.</p>"},{"location":"user-guide/caching/cache-strategies/#cache-invalidation-strategies","title":"Cache Invalidation Strategies","text":"<p>Cache invalidation is one of the hardest problems in computer science. The boilerplate provides several strategies to handle different scenarios while maintaining data consistency.</p>"},{"location":"user-guide/caching/cache-strategies/#understanding-cache-invalidation","title":"Understanding Cache Invalidation","text":"<p>Cache invalidation ensures that cached data doesn't become stale when the underlying data changes. Poor invalidation leads to users seeing outdated information, while over-aggressive invalidation negates caching benefits.</p>"},{"location":"user-guide/caching/cache-strategies/#basic-invalidation-patterns","title":"Basic Invalidation Patterns","text":""},{"location":"user-guide/caching/cache-strategies/#time-based-expiration-ttl","title":"Time-Based Expiration (TTL)","text":"<p>The simplest strategy relies on cache expiration times:</p> <pre><code># Set different TTL based on data characteristics\n@cache(key_prefix=\"user_profile\", expiration=3600)  # 1 hour for profiles\n@cache(key_prefix=\"post_content\", expiration=1800)  # 30 min for posts\n@cache(key_prefix=\"live_stats\", expiration=60)      # 1 min for live data\n</code></pre> <p>Pros:</p> <ul> <li>Simple to implement and understand</li> <li>Guarantees cache freshness within TTL period</li> <li>Works well for data with predictable change patterns</li> </ul> <p>Cons:</p> <ul> <li>May serve stale data until TTL expires</li> <li>Difficult to optimize TTL for all scenarios</li> <li>Cache miss storms when many keys expire simultaneously</li> </ul>"},{"location":"user-guide/caching/cache-strategies/#write-through-invalidation","title":"Write-Through Invalidation","text":"<p>Automatically invalidate cache when data is modified:</p> <pre><code>@router.put(\"/posts/{post_id}\")\n@cache(\n    key_prefix=\"post_cache\",\n    resource_id_name=\"post_id\",\n    to_invalidate_extra={\n        \"user_posts\": \"{user_id}\",           # User's post list\n        \"category_posts\": \"{category_id}\",   # Category post list\n        \"recent_posts\": \"global\"             # Global recent posts\n    }\n)\nasync def update_post(\n    request: Request,\n    post_id: int,\n    post_data: PostUpdate,\n    user_id: int,\n    category_id: int\n):\n    # Update triggers automatic cache invalidation\n    updated_post = await crud_posts.update(db=db, id=post_id, object=post_data)\n    return updated_post\n</code></pre> <p>Pros:</p> <ul> <li>Immediate consistency when data changes</li> <li>No stale data served to users</li> <li>Precise control over what gets invalidated</li> </ul> <p>Cons:</p> <ul> <li>More complex implementation</li> <li>Can impact write performance</li> <li>Risk of over-invalidation</li> </ul>"},{"location":"user-guide/caching/cache-strategies/#advanced-invalidation-patterns","title":"Advanced Invalidation Patterns","text":""},{"location":"user-guide/caching/cache-strategies/#pattern-based-invalidation","title":"Pattern-Based Invalidation","text":"<p>Use Redis pattern matching for bulk invalidation:</p> <pre><code>@router.put(\"/users/{user_id}/profile\")\n@cache(\n    key_prefix=\"user_profile\",\n    resource_id_name=\"user_id\",\n    pattern_to_invalidate_extra=[\n        \"user_{user_id}_*\",          # All user-related caches\n        \"*_user_{user_id}_*\",        # Caches containing this user\n        \"leaderboard_*\",             # Leaderboards might change\n        \"search_users_*\"             # User search results\n    ]\n)\nasync def update_user_profile(request: Request, user_id: int, profile_data: ProfileUpdate):\n    await crud_users.update(db=db, id=user_id, object=profile_data)\n    return {\"message\": \"Profile updated\"}\n</code></pre> <p>Pattern Examples: <pre><code># User-specific patterns\n\"user_{user_id}_posts_*\"        # All paginated post lists for user\n\"user_{user_id}_*_cache\"        # All cached data for user\n\"*_following_{user_id}\"          # All caches tracking this user's followers\n\n# Content patterns  \n\"posts_category_{category_id}_*\" # All posts in category\n\"comments_post_{post_id}_*\"      # All comments for post\n\"search_*_{query}\"               # All search results for query\n\n# Time-based patterns\n\"daily_stats_*\"                  # All daily statistics\n\"hourly_*\"                       # All hourly data\n\"temp_*\"                         # Temporary cache entries\n</code></pre></p>"},{"location":"user-guide/caching/cache-strategies/#cache-warming-strategies","title":"Cache Warming Strategies","text":"<p>Cache warming proactively loads data into cache to avoid cache misses during peak usage.</p>"},{"location":"user-guide/caching/cache-strategies/#application-startup-warming","title":"Application Startup Warming","text":"<pre><code># core/startup.py\nasync def warm_critical_caches():\n    \"\"\"Warm up critical caches during application startup.\"\"\"\n\n    logger.info(\"Starting cache warming...\")\n\n    # Warm up reference data\n    await warm_reference_data()\n\n    # Warm up popular content\n    await warm_popular_content()\n\n    # Warm up user session data for active users\n    await warm_active_user_data()\n\n    logger.info(\"Cache warming completed\")\n\nasync def warm_reference_data():\n    \"\"\"Warm up reference data that rarely changes.\"\"\"\n\n    # Countries, currencies, timezones, etc.\n    reference_data = await crud_reference.get_all_countries()\n    for country in reference_data:\n        cache_key = f\"country:{country['code']}\"\n        await cache.client.set(cache_key, json.dumps(country), ex=86400)  # 24 hours\n\n    # Categories\n    categories = await crud_categories.get_all()\n    await cache.client.set(\"all_categories\", json.dumps(categories), ex=3600)\n\nasync def warm_popular_content():\n    \"\"\"Warm up frequently accessed content.\"\"\"\n\n    # Most viewed posts\n    popular_posts = await crud_posts.get_popular(limit=100)\n    for post in popular_posts:\n        cache_key = f\"post_cache:{post['id']}\"\n        await cache.client.set(cache_key, json.dumps(post), ex=1800)\n\n    # Trending topics\n    trending = await crud_posts.get_trending_topics(limit=50)\n    await cache.client.set(\"trending_topics\", json.dumps(trending), ex=600)\n\nasync def warm_active_user_data():\n    \"\"\"Warm up data for recently active users.\"\"\"\n\n    # Get users active in last 24 hours\n    active_users = await crud_users.get_recently_active(hours=24)\n\n    for user in active_users:\n        # Warm user profile\n        profile_key = f\"user_profile:{user['id']}\"\n        await cache.client.set(profile_key, json.dumps(user), ex=3600)\n\n        # Warm user's recent posts\n        user_posts = await crud_posts.get_user_posts(user['id'], limit=10)\n        posts_key = f\"user_{user['id']}_posts:page_1\"\n        await cache.client.set(posts_key, json.dumps(user_posts), ex=1800)\n\n# Add to startup events\n@app.on_event(\"startup\")\nasync def startup_event():\n    await create_redis_cache_pool()\n    await warm_critical_caches()\n</code></pre> <p>These cache strategies provide a comprehensive approach to building performant, consistent caching systems that scale with your application's needs while maintaining data integrity. </p>"},{"location":"user-guide/caching/client-cache/","title":"Client Cache","text":"<p>Client-side caching leverages HTTP cache headers to instruct browsers and CDNs to cache responses locally. This reduces server load and improves user experience by serving cached content directly from the client.</p>"},{"location":"user-guide/caching/client-cache/#understanding-client-caching","title":"Understanding Client Caching","text":"<p>Client caching works by setting HTTP headers that tell browsers, proxies, and CDNs how long they should cache responses. When implemented correctly, subsequent requests for the same resource are served instantly from the local cache.</p>"},{"location":"user-guide/caching/client-cache/#benefits-of-client-caching","title":"Benefits of Client Caching","text":"<p>Reduced Latency: Instant response from local cache eliminates network round trips Lower Server Load: Fewer requests reach your server infrastructure Bandwidth Savings: Cached responses don't consume network bandwidth Better User Experience: Faster page loads and improved responsiveness Cost Reduction: Lower server resource usage and bandwidth costs  </p>"},{"location":"user-guide/caching/client-cache/#cache-control-headers","title":"Cache-Control Headers","text":"<p>The <code>Cache-Control</code> header is the primary mechanism for controlling client-side caching behavior.</p>"},{"location":"user-guide/caching/client-cache/#header-components","title":"Header Components","text":"<pre><code>Cache-Control: public, max-age=3600, s-maxage=7200, must-revalidate\n</code></pre> <p>Directive Breakdown:</p> <ul> <li><code>public</code>: Response can be cached by any cache (browsers, CDNs, proxies)</li> <li><code>private</code>: Response can only be cached by browsers, not shared caches</li> <li><code>max-age=3600</code>: Cache for 3600 seconds (1 hour) in browsers</li> <li><code>s-maxage=7200</code>: Cache for 7200 seconds (2 hours) in shared caches (CDNs)</li> <li><code>must-revalidate</code>: Must check with server when cache expires</li> <li><code>no-cache</code>: Must revalidate with server before using cached response</li> <li><code>no-store</code>: Must not store any part of the response</li> </ul>"},{"location":"user-guide/caching/client-cache/#common-cache-patterns","title":"Common Cache Patterns","text":"<pre><code># Static assets (images, CSS, JS)\n\"Cache-Control: public, max-age=31536000, immutable\"  # 1 year\n\n# API data that changes rarely\n\"Cache-Control: public, max-age=3600\"  # 1 hour\n\n# User-specific data\n\"Cache-Control: private, max-age=1800\"  # 30 minutes, browser only\n\n# Real-time data\n\"Cache-Control: no-cache, must-revalidate\"  # Always validate\n\n# Sensitive data\n\"Cache-Control: no-store, no-cache, must-revalidate\"  # Never cache\n</code></pre>"},{"location":"user-guide/caching/client-cache/#middleware-implementation","title":"Middleware Implementation","text":"<p>The boilerplate includes middleware that automatically adds cache headers to responses.</p>"},{"location":"user-guide/caching/client-cache/#clientcachemiddleware","title":"ClientCacheMiddleware","text":"<pre><code># middleware/client_cache_middleware.py\nfrom fastapi import FastAPI, Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint\n\nclass ClientCacheMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware to set Cache-Control headers for client-side caching.\"\"\"\n\n    def __init__(self, app: FastAPI, max_age: int = 60) -&gt; None:\n        super().__init__(app)\n        self.max_age = max_age\n\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -&gt; Response:\n        response: Response = await call_next(request)\n        response.headers[\"Cache-Control\"] = f\"public, max-age={self.max_age}\"\n        return response\n</code></pre>"},{"location":"user-guide/caching/client-cache/#adding-middleware-to-application","title":"Adding Middleware to Application","text":"<pre><code># main.py\nfrom fastapi import FastAPI\nfrom app.middleware.client_cache_middleware import ClientCacheMiddleware\n\napp = FastAPI()\n\n# Add client caching middleware\napp.add_middleware(\n    ClientCacheMiddleware,\n    max_age=300  # 5 minutes default cache\n)\n</code></pre>"},{"location":"user-guide/caching/client-cache/#custom-middleware-configuration","title":"Custom Middleware Configuration","text":"<pre><code>class AdvancedClientCacheMiddleware(BaseHTTPMiddleware):\n    \"\"\"Advanced client cache middleware with path-specific configurations.\"\"\"\n\n    def __init__(\n        self, \n        app: FastAPI, \n        default_max_age: int = 300,\n        path_configs: dict[str, dict] = None\n    ):\n        super().__init__(app)\n        self.default_max_age = default_max_age\n        self.path_configs = path_configs or {}\n\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -&gt; Response:\n        response = await call_next(request)\n\n        # Get path-specific configuration\n        cache_config = self._get_cache_config(request.url.path)\n\n        # Set cache headers based on configuration\n        if cache_config.get(\"no_cache\", False):\n            response.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\"\n            response.headers[\"Pragma\"] = \"no-cache\"\n            response.headers[\"Expires\"] = \"0\"\n        else:\n            max_age = cache_config.get(\"max_age\", self.default_max_age)\n            visibility = \"private\" if cache_config.get(\"private\", False) else \"public\"\n\n            cache_control = f\"{visibility}, max-age={max_age}\"\n\n            if cache_config.get(\"must_revalidate\", False):\n                cache_control += \", must-revalidate\"\n\n            if cache_config.get(\"immutable\", False):\n                cache_control += \", immutable\"\n\n            response.headers[\"Cache-Control\"] = cache_control\n\n        return response\n\n    def _get_cache_config(self, path: str) -&gt; dict:\n        \"\"\"Get cache configuration for a specific path.\"\"\"\n        for pattern, config in self.path_configs.items():\n            if path.startswith(pattern):\n                return config\n        return {}\n\n# Usage with path-specific configurations\napp.add_middleware(\n    AdvancedClientCacheMiddleware,\n    default_max_age=300,\n    path_configs={\n        \"/api/v1/static/\": {\"max_age\": 31536000, \"immutable\": True},  # 1 year for static assets\n        \"/api/v1/auth/\": {\"no_cache\": True},                          # No cache for auth endpoints\n        \"/api/v1/users/me\": {\"private\": True, \"max_age\": 900},        # 15 min private cache for user data\n        \"/api/v1/public/\": {\"max_age\": 1800},                         # 30 min for public data\n    }\n)\n</code></pre>"},{"location":"user-guide/caching/client-cache/#manual-cache-control","title":"Manual Cache Control","text":"<p>Set cache headers manually in specific endpoints for fine-grained control.</p>"},{"location":"user-guide/caching/client-cache/#response-header-manipulation","title":"Response Header Manipulation","text":"<pre><code>from fastapi import APIRouter, Response\n\nrouter = APIRouter()\n\n@router.get(\"/api/v1/static-data\")\nasync def get_static_data(response: Response):\n    \"\"\"Endpoint with long-term caching for static data.\"\"\"\n    # Set cache headers for static data\n    response.headers[\"Cache-Control\"] = \"public, max-age=86400, immutable\"  # 24 hours\n    response.headers[\"Last-Modified\"] = \"Wed, 21 Oct 2023 07:28:00 GMT\"\n    response.headers[\"ETag\"] = '\"abc123\"'\n\n    return {\"data\": \"static content that rarely changes\"}\n\n@router.get(\"/api/v1/user-data\")\nasync def get_user_data(response: Response, current_user: dict = Depends(get_current_user)):\n    \"\"\"Endpoint with private caching for user-specific data.\"\"\"\n    # Private cache for user-specific data\n    response.headers[\"Cache-Control\"] = \"private, max-age=1800\"  # 30 minutes\n    response.headers[\"Vary\"] = \"Authorization\"  # Cache varies by auth header\n\n    return {\"user_id\": current_user[\"id\"], \"preferences\": \"user data\"}\n\n@router.get(\"/api/v1/real-time-data\")\nasync def get_real_time_data(response: Response):\n    \"\"\"Endpoint that should not be cached.\"\"\"\n    # Prevent caching for real-time data\n    response.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\"\n    response.headers[\"Pragma\"] = \"no-cache\"\n    response.headers[\"Expires\"] = \"0\"\n\n    return {\"timestamp\": datetime.utcnow(), \"live_data\": \"current status\"}\n</code></pre>"},{"location":"user-guide/caching/client-cache/#conditional-caching","title":"Conditional Caching","text":"<p>Implement conditional caching based on request parameters:</p> <pre><code>@router.get(\"/api/v1/posts\")\nasync def get_posts(\n    response: Response,\n    page: int = 1,\n    per_page: int = 10,\n    category: str = None\n):\n    \"\"\"Conditional caching based on parameters.\"\"\"\n\n    # Different cache strategies based on parameters\n    if category:\n        # Category-specific data changes less frequently\n        response.headers[\"Cache-Control\"] = \"public, max-age=1800\"  # 30 minutes\n    elif page == 1:\n        # First page cached more aggressively\n        response.headers[\"Cache-Control\"] = \"public, max-age=600\"   # 10 minutes\n    else:\n        # Other pages cached for shorter duration\n        response.headers[\"Cache-Control\"] = \"public, max-age=300\"   # 5 minutes\n\n    # Add ETag for efficient revalidation\n    content_hash = hashlib.md5(f\"{page}{per_page}{category}\".encode()).hexdigest()\n    response.headers[\"ETag\"] = f'\"{content_hash}\"'\n\n    posts = await crud_posts.get_multi(\n        db=db,\n        offset=(page - 1) * per_page,\n        limit=per_page,\n        category=category\n    )\n\n    return {\"posts\": posts, \"page\": page, \"per_page\": per_page}\n</code></pre>"},{"location":"user-guide/caching/client-cache/#etag-implementation","title":"ETag Implementation","text":"<p>ETags enable efficient cache validation by allowing clients to check if content has changed.</p>"},{"location":"user-guide/caching/client-cache/#etag-generation","title":"ETag Generation","text":"<pre><code>import hashlib\nfrom typing import Any\n\ndef generate_etag(data: Any) -&gt; str:\n    \"\"\"Generate ETag from data content.\"\"\"\n    content = json.dumps(data, sort_keys=True, default=str)\n    return hashlib.md5(content.encode()).hexdigest()\n\n@router.get(\"/api/v1/users/{user_id}\")\nasync def get_user(\n    request: Request,\n    response: Response,\n    user_id: int\n):\n    \"\"\"Endpoint with ETag support for efficient caching.\"\"\"\n\n    user = await crud_users.get(db=db, id=user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    # Generate ETag from user data\n    etag = generate_etag(user)\n\n    # Check if client has current version\n    if_none_match = request.headers.get(\"If-None-Match\")\n    if if_none_match == f'\"{etag}\"':\n        # Content hasn't changed, return 304 Not Modified\n        response.status_code = 304\n        return Response(status_code=304)\n\n    # Set ETag and cache headers\n    response.headers[\"ETag\"] = f'\"{etag}\"'\n    response.headers[\"Cache-Control\"] = \"private, max-age=1800, must-revalidate\"\n\n    return user\n</code></pre>"},{"location":"user-guide/caching/client-cache/#last-modified-headers","title":"Last-Modified Headers","text":"<p>Use Last-Modified headers for time-based cache validation:</p> <pre><code>@router.get(\"/api/v1/posts/{post_id}\")\nasync def get_post(\n    request: Request,\n    response: Response,\n    post_id: int\n):\n    \"\"\"Endpoint with Last-Modified header support.\"\"\"\n\n    post = await crud_posts.get(db=db, id=post_id)\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Use post's updated_at timestamp\n    last_modified = post[\"updated_at\"]\n\n    # Check If-Modified-Since header\n    if_modified_since = request.headers.get(\"If-Modified-Since\")\n    if if_modified_since:\n        client_time = datetime.strptime(if_modified_since, \"%a, %d %b %Y %H:%M:%S GMT\")\n        if last_modified &lt;= client_time:\n            response.status_code = 304\n            return Response(status_code=304)\n\n    # Set Last-Modified header\n    response.headers[\"Last-Modified\"] = last_modified.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n    response.headers[\"Cache-Control\"] = \"public, max-age=3600, must-revalidate\"\n\n    return post\n</code></pre>"},{"location":"user-guide/caching/client-cache/#cache-strategy-by-content-type","title":"Cache Strategy by Content Type","text":"<p>Different types of content require different caching strategies.</p>"},{"location":"user-guide/caching/client-cache/#static-assets","title":"Static Assets","text":"<pre><code>@router.get(\"/static/{file_path:path}\")\nasync def serve_static(response: Response, file_path: str):\n    \"\"\"Serve static files with aggressive caching.\"\"\"\n\n    # Static assets can be cached for a long time\n    response.headers[\"Cache-Control\"] = \"public, max-age=31536000, immutable\"  # 1 year\n    response.headers[\"Vary\"] = \"Accept-Encoding\"  # Vary by compression\n\n    # Add file-specific ETag based on file modification time\n    file_stat = os.stat(f\"static/{file_path}\")\n    etag = hashlib.md5(f\"{file_path}{file_stat.st_mtime}\".encode()).hexdigest()\n    response.headers[\"ETag\"] = f'\"{etag}\"'\n\n    return FileResponse(f\"static/{file_path}\")\n</code></pre>"},{"location":"user-guide/caching/client-cache/#api-responses","title":"API Responses","text":"<pre><code># Reference data (rarely changes)\n@router.get(\"/api/v1/countries\")\nasync def get_countries(response: Response, db: AsyncSession = Depends(async_get_db)):\n    response.headers[\"Cache-Control\"] = \"public, max-age=86400\"  # 24 hours\n    return await crud_countries.get_all(db=db)\n\n# User-generated content (moderate changes)\n@router.get(\"/api/v1/posts\")\nasync def get_posts(response: Response, db: AsyncSession = Depends(async_get_db)):\n    response.headers[\"Cache-Control\"] = \"public, max-age=1800\"  # 30 minutes\n    return await crud_posts.get_multi(db=db, is_deleted=False)\n\n# Personal data (private caching only)\n@router.get(\"/api/v1/users/me/notifications\")\nasync def get_notifications(\n    response: Response, \n    current_user: dict = Depends(get_current_user),\n    db: AsyncSession = Depends(async_get_db)\n):\n    response.headers[\"Cache-Control\"] = \"private, max-age=300\"  # 5 minutes\n    response.headers[\"Vary\"] = \"Authorization\"\n    return await crud_notifications.get_user_notifications(db=db, user_id=current_user[\"id\"])\n\n# Real-time data (no caching)\n@router.get(\"/api/v1/system/status\")\nasync def get_system_status(response: Response):\n    response.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\"\n    return {\"status\": \"online\", \"timestamp\": datetime.utcnow()}\n</code></pre>"},{"location":"user-guide/caching/client-cache/#vary-header-usage","title":"Vary Header Usage","text":"<p>The <code>Vary</code> header tells caches which request headers affect the response, enabling proper cache key generation.</p>"},{"location":"user-guide/caching/client-cache/#common-vary-patterns","title":"Common Vary Patterns","text":"<pre><code># Cache varies by authorization (user-specific content)\nresponse.headers[\"Vary\"] = \"Authorization\"\n\n# Cache varies by accepted language\nresponse.headers[\"Vary\"] = \"Accept-Language\"\n\n# Cache varies by compression support\nresponse.headers[\"Vary\"] = \"Accept-Encoding\"\n\n# Multiple varying headers\nresponse.headers[\"Vary\"] = \"Authorization, Accept-Language, Accept-Encoding\"\n\n# Example implementation\n@router.get(\"/api/v1/dashboard\")\nasync def get_dashboard(\n    request: Request,\n    response: Response,\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Dashboard content that varies by user and language.\"\"\"\n\n    # Content varies by user (Authorization) and language preference\n    response.headers[\"Vary\"] = \"Authorization, Accept-Language\"\n    response.headers[\"Cache-Control\"] = \"private, max-age=900\"  # 15 minutes\n\n    language = request.headers.get(\"Accept-Language\", \"en\")\n\n    dashboard_data = await generate_dashboard(\n        user_id=current_user[\"id\"],\n        language=language\n    )\n\n    return dashboard_data\n</code></pre>"},{"location":"user-guide/caching/client-cache/#cdn-integration","title":"CDN Integration","text":"<p>Configure cache headers for optimal CDN performance.</p>"},{"location":"user-guide/caching/client-cache/#cdn-specific-headers","title":"CDN-Specific Headers","text":"<pre><code>@router.get(\"/api/v1/public-content\")\nasync def get_public_content(response: Response):\n    \"\"\"Content optimized for CDN caching.\"\"\"\n\n    # Different cache times for browser vs CDN\n    response.headers[\"Cache-Control\"] = \"public, max-age=300, s-maxage=3600\"  # 5 min browser, 1 hour CDN\n\n    # CDN-specific headers (CloudFlare example)\n    response.headers[\"CF-Cache-Tag\"] = \"public-content,api-v1\"  # Cache tags for purging\n    response.headers[\"CF-Edge-Cache\"] = \"max-age=86400\"         # Edge cache for 24 hours\n\n    return await get_public_content_data()\n</code></pre>"},{"location":"user-guide/caching/client-cache/#cache-purging","title":"Cache Purging","text":"<p>Implement cache purging for content updates:</p> <pre><code>@router.put(\"/api/v1/posts/{post_id}\")\nasync def update_post(\n    response: Response,\n    post_id: int,\n    post_data: PostUpdate,\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Update post and invalidate related caches.\"\"\"\n\n    # Update the post\n    updated_post = await crud_posts.update(db=db, id=post_id, object=post_data)\n\n    # Set headers to indicate cache invalidation is needed\n    response.headers[\"Cache-Control\"] = \"no-cache\"\n    response.headers[\"X-Cache-Purge\"] = f\"post-{post_id},user-{current_user['id']}-posts\"\n\n    # In production, trigger CDN purge here\n    # await purge_cdn_cache([f\"post-{post_id}\", f\"user-{current_user['id']}-posts\"])\n\n    return updated_post\n</code></pre>"},{"location":"user-guide/caching/client-cache/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/caching/client-cache/#cache-duration-guidelines","title":"Cache Duration Guidelines","text":"<pre><code># Choose appropriate cache durations based on content characteristics:\n\n# Static assets (CSS, JS, images with versioning)\nmax_age = 31536000  # 1 year\n\n# API reference data (countries, categories)\nmax_age = 86400     # 24 hours\n\n# User-generated content (posts, comments)\nmax_age = 1800      # 30 minutes\n\n# User-specific data (profiles, preferences)\nmax_age = 900       # 15 minutes\n\n# Search results\nmax_age = 600       # 10 minutes\n\n# Real-time data (live scores, chat)\nmax_age = 0         # No caching\n</code></pre>"},{"location":"user-guide/caching/client-cache/#security-considerations","title":"Security Considerations","text":"<pre><code># Never cache sensitive data\n@router.get(\"/api/v1/admin/secrets\")\nasync def get_secrets(response: Response):\n    response.headers[\"Cache-Control\"] = \"no-store, no-cache, must-revalidate, private\"\n    response.headers[\"Pragma\"] = \"no-cache\"\n    response.headers[\"Expires\"] = \"0\"\n    return {\"secret\": \"sensitive_data\"}\n\n# Use private caching for user-specific content\n@router.get(\"/api/v1/users/me/private-data\")\nasync def get_private_data(response: Response):\n    response.headers[\"Cache-Control\"] = \"private, max-age=300, must-revalidate\"\n    response.headers[\"Vary\"] = \"Authorization\"\n    return {\"private\": \"user_data\"}\n</code></pre> <p>Client-side caching, when properly implemented, provides significant performance improvements while maintaining security and data freshness through intelligent cache control strategies. </p>"},{"location":"user-guide/caching/redis-cache/","title":"Redis Cache","text":"<p>Redis-based server-side caching provides fast, in-memory storage for API responses. The boilerplate includes a sophisticated caching decorator that automatically handles cache storage, retrieval, and invalidation.</p>"},{"location":"user-guide/caching/redis-cache/#understanding-redis-caching","title":"Understanding Redis Caching","text":"<p>Redis serves as a high-performance cache layer between your API and database. When properly implemented, it can reduce response times from hundreds of milliseconds to single-digit milliseconds by serving data directly from memory.</p>"},{"location":"user-guide/caching/redis-cache/#why-redis","title":"Why Redis?","text":"<p>Performance: In-memory storage provides sub-millisecond data access Scalability: Handles thousands of concurrent connections efficiently Persistence: Optional data persistence for cache warm-up after restarts Atomic Operations: Thread-safe operations for concurrent applications Pattern Matching: Advanced key pattern operations for bulk cache invalidation</p>"},{"location":"user-guide/caching/redis-cache/#cache-decorator","title":"Cache Decorator","text":"<p>The <code>@cache</code> decorator provides a simple interface for adding caching to any FastAPI endpoint.</p>"},{"location":"user-guide/caching/redis-cache/#basic-usage","title":"Basic Usage","text":"<pre><code>from fastapi import APIRouter, Request\nfrom app.core.utils.cache import cache\n\nrouter = APIRouter()\n\n@router.get(\"/posts/{post_id}\")\n@cache(key_prefix=\"post_cache\", expiration=3600)\nasync def get_post(request: Request, post_id: int):\n    # This function's result will be cached for 1 hour\n    post = await crud_posts.get(db=db, id=post_id)\n    return post\n</code></pre> <p>How It Works:</p> <ol> <li>Cache Check: On GET requests, checks Redis for existing cached data</li> <li>Cache Miss: If no cache exists, executes the function and stores the result</li> <li>Cache Hit: Returns cached data directly, bypassing function execution</li> <li>Invalidation: Automatically removes cache on non-GET requests (POST, PUT, DELETE)</li> </ol>"},{"location":"user-guide/caching/redis-cache/#decorator-parameters","title":"Decorator Parameters","text":"<pre><code>@cache(\n    key_prefix: str,                                    # Cache key prefix\n    resource_id_name: str = None,                       # Explicit resource ID parameter\n    expiration: int = 3600,                             # Cache TTL in seconds\n    resource_id_type: type | tuple[type, ...] = int,    # Expected ID type\n    to_invalidate_extra: dict[str, str] = None,         # Additional keys to invalidate\n    pattern_to_invalidate_extra: list[str] = None       # Pattern-based invalidation\n)\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#key-prefix","title":"Key Prefix","text":"<p>The key prefix creates unique cache identifiers:</p> <pre><code># Simple prefix\n@cache(key_prefix=\"user_data\")\n# Generates keys like: \"user_data:123\"\n\n# Dynamic prefix with placeholders\n@cache(key_prefix=\"{username}_posts\")  \n# Generates keys like: \"johndoe_posts:456\"\n\n# Complex prefix with multiple parameters\n@cache(key_prefix=\"user_{user_id}_posts_page_{page}\")\n# Generates keys like: \"user_123_posts_page_2:789\"\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#resource-id-handling","title":"Resource ID Handling","text":"<pre><code># Automatic ID inference (looks for 'id' parameter)\n@cache(key_prefix=\"post_cache\")\nasync def get_post(request: Request, post_id: int):\n    # Uses post_id automatically\n\n# Explicit ID parameter\n@cache(key_prefix=\"user_cache\", resource_id_name=\"username\")\nasync def get_user(request: Request, username: str):\n    # Uses username instead of looking for 'id'\n\n# Multiple ID types\n@cache(key_prefix=\"search\", resource_id_type=(int, str))\nasync def search(request: Request, query: str, page: int):\n    # Accepts either string or int as resource ID\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#advanced-caching-patterns","title":"Advanced Caching Patterns","text":""},{"location":"user-guide/caching/redis-cache/#paginated-data-caching","title":"Paginated Data Caching","text":"<pre><code>@router.get(\"/users/{username}/posts\")\n@cache(\n    key_prefix=\"{username}_posts:page_{page}:items_per_page_{items_per_page}\",\n    resource_id_name=\"username\",\n    expiration=300  # 5 minutes for paginated data\n)\nasync def get_user_posts(\n    request: Request,\n    username: str,\n    page: int = 1,\n    items_per_page: int = 10\n):\n    offset = compute_offset(page, items_per_page)\n    posts = await crud_posts.get_multi(\n        db=db,\n        offset=offset,\n        limit=items_per_page,\n        created_by_user_id=user_id\n    )\n    return paginated_response(posts, page, items_per_page)\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#hierarchical-data-caching","title":"Hierarchical Data Caching","text":"<pre><code>@router.get(\"/organizations/{org_id}/departments/{dept_id}/employees\")\n@cache(\n    key_prefix=\"org_{org_id}_dept_{dept_id}_employees\",\n    resource_id_name=\"dept_id\",\n    expiration=1800  # 30 minutes\n)\nasync def get_department_employees(\n    request: Request,\n    org_id: int,\n    dept_id: int\n):\n    employees = await crud_employees.get_multi(\n        db=db,\n        department_id=dept_id,\n        organization_id=org_id\n    )\n    return employees\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#cache-invalidation","title":"Cache Invalidation","text":"<p>Cache invalidation ensures data consistency when the underlying data changes.</p>"},{"location":"user-guide/caching/redis-cache/#automatic-invalidation","title":"Automatic Invalidation","text":"<p>The cache decorator automatically invalidates cache entries on non-GET requests:</p> <pre><code>@router.put(\"/posts/{post_id}\")\n@cache(key_prefix=\"post_cache\", resource_id_name=\"post_id\")\nasync def update_post(request: Request, post_id: int, data: PostUpdate):\n    # Automatically invalidates \"post_cache:123\" when called with PUT/POST/DELETE\n    await crud_posts.update(db=db, id=post_id, object=data)\n    return {\"message\": \"Post updated\"}\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#extra-key-invalidation","title":"Extra Key Invalidation","text":"<p>Invalidate related cache entries when data changes:</p> <pre><code>@router.post(\"/posts\")\n@cache(\n    key_prefix=\"new_post\",\n    resource_id_name=\"user_id\", \n    to_invalidate_extra={\n        \"user_posts\": \"{user_id}\",           # Invalidate user's post list\n        \"latest_posts\": \"global\",            # Invalidate global latest posts\n        \"user_stats\": \"{user_id}\"            # Invalidate user statistics\n    }\n)\nasync def create_post(request: Request, post: PostCreate, user_id: int):\n    # Creating a post invalidates related cached data\n    new_post = await crud_posts.create(db=db, object=post)\n    return new_post\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#pattern-based-invalidation","title":"Pattern-Based Invalidation","text":"<p>Use Redis pattern matching for bulk invalidation:</p> <pre><code>@router.put(\"/users/{user_id}/profile\")\n@cache(\n    key_prefix=\"user_profile\",\n    resource_id_name=\"user_id\",\n    pattern_to_invalidate_extra=[\n        \"user_{user_id}_*\",          # All user-related caches\n        \"*_user_{user_id}_*\",        # Caches that include this user\n        \"search_results_*\"           # All search result caches\n    ]\n)\nasync def update_user_profile(request: Request, user_id: int, data: UserUpdate):\n    # Invalidates all matching cache patterns\n    await crud_users.update(db=db, id=user_id, object=data)\n    return {\"message\": \"Profile updated\"}\n</code></pre> <p>Pattern Examples:</p> <ul> <li><code>user_*</code> - All keys starting with \"user_\"</li> <li><code>*_posts</code> - All keys ending with \"_posts\"  </li> <li><code>user_*_posts_*</code> - Complex patterns with wildcards</li> <li><code>temp_*</code> - Temporary cache entries</li> </ul>"},{"location":"user-guide/caching/redis-cache/#configuration","title":"Configuration","text":""},{"location":"user-guide/caching/redis-cache/#redis-settings","title":"Redis Settings","text":"<p>Configure Redis connection in your environment settings:</p> <pre><code># core/config.py\nclass RedisCacheSettings(BaseSettings):\n    REDIS_CACHE_HOST: str = config(\"REDIS_CACHE_HOST\", default=\"localhost\")\n    REDIS_CACHE_PORT: int = config(\"REDIS_CACHE_PORT\", default=6379) \n    REDIS_CACHE_PASSWORD: str = config(\"REDIS_CACHE_PASSWORD\", default=\"\")\n    REDIS_CACHE_DB: int = config(\"REDIS_CACHE_DB\", default=0)\n    REDIS_CACHE_URL: str = f\"redis://:{REDIS_CACHE_PASSWORD}@{REDIS_CACHE_HOST}:{REDIS_CACHE_PORT}/{REDIS_CACHE_DB}\"\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#environment-variables","title":"Environment Variables","text":"<pre><code># Basic Configuration\nREDIS_CACHE_HOST=localhost\nREDIS_CACHE_PORT=6379\n\n# Production Configuration  \nREDIS_CACHE_HOST=redis.production.com\nREDIS_CACHE_PORT=6379\nREDIS_CACHE_PASSWORD=your-secure-password\nREDIS_CACHE_DB=0\n\n# Docker Compose\nREDIS_CACHE_HOST=redis\nREDIS_CACHE_PORT=6379\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#connection-pool-setup","title":"Connection Pool Setup","text":"<p>The boilerplate automatically configures Redis connection pooling:</p> <pre><code># core/setup.py\nasync def create_redis_cache_pool() -&gt; None:\n    \"\"\"Initialize Redis connection pool for caching.\"\"\"\n    cache.pool = redis.ConnectionPool.from_url(\n        settings.REDIS_CACHE_URL,\n        max_connections=20,      # Maximum connections in pool\n        retry_on_timeout=True,   # Retry on connection timeout\n        socket_timeout=5.0,      # Socket timeout in seconds\n        health_check_interval=30 # Health check frequency\n    )\n    cache.client = redis.Redis.from_pool(cache.pool)\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#cache-client-usage","title":"Cache Client Usage","text":"<p>Direct Redis client access for custom caching logic:</p> <pre><code>from app.core.utils.cache import client\n\nasync def custom_cache_operation():\n    if client is None:\n        raise MissingClientError(\"Redis client not initialized\")\n\n    # Set custom cache entry\n    await client.set(\"custom_key\", \"custom_value\", ex=3600)\n\n    # Get cached value\n    cached_value = await client.get(\"custom_key\")\n\n    # Delete cache entry\n    await client.delete(\"custom_key\")\n\n    # Bulk operations\n    pipe = client.pipeline()\n    pipe.set(\"key1\", \"value1\")\n    pipe.set(\"key2\", \"value2\") \n    pipe.expire(\"key1\", 3600)\n    await pipe.execute()\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user-guide/caching/redis-cache/#connection-pooling","title":"Connection Pooling","text":"<p>Connection pooling prevents the overhead of creating new Redis connections for each request:</p> <pre><code># Benefits of connection pooling:\n# - Reuses existing connections\n# - Handles connection failures gracefully\n# - Provides connection health checks\n# - Supports concurrent operations\n\n# Pool configuration\nredis.ConnectionPool.from_url(\n    settings.REDIS_CACHE_URL,\n    max_connections=20,        # Adjust based on expected load\n    retry_on_timeout=True,     # Handle network issues\n    socket_keepalive=True,     # Keep connections alive\n    socket_keepalive_options={}\n)\n</code></pre>"},{"location":"user-guide/caching/redis-cache/#cache-key-generation","title":"Cache Key Generation","text":"<p>The cache decorator automatically generates keys using this pattern:</p> <pre><code># Decorator generates: \"{formatted_key_prefix}:{resource_id}\"\n@cache(key_prefix=\"post_cache\", resource_id_name=\"post_id\")\n# Generates: \"post_cache:123\"\n\n@cache(key_prefix=\"{username}_posts:page_{page}\")\n# Generates: \"johndoe_posts:page_1:456\" (where 456 is the resource_id)\n\n# The system handles key formatting automatically - you just provide the prefix template\n</code></pre> <p>What you control: - <code>key_prefix</code> template with placeholders like <code>{username}</code>, <code>{page}</code> - <code>resource_id_name</code> to specify which parameter to use as the ID - The decorator handles the rest</p> <p>Generated key examples from the boilerplate: <pre><code># From posts.py\n\"{username}_posts:page_{page}:items_per_page_{items_per_page}\" \u2192 \"john_posts:page_1:items_per_page_10:789\"\n\"{username}_post_cache\" \u2192 \"john_post_cache:123\"\n</code></pre></p>"},{"location":"user-guide/caching/redis-cache/#expiration-strategies","title":"Expiration Strategies","text":"<p>Choose appropriate expiration times based on data characteristics:</p> <pre><code># Static reference data (rarely changes)\n@cache(key_prefix=\"countries\", expiration=86400)  # 24 hours\n\n# User-generated content (changes moderately)\n@cache(key_prefix=\"user_posts\", expiration=1800)  # 30 minutes\n\n# Real-time data (changes frequently)\n@cache(key_prefix=\"live_stats\", expiration=60)    # 1 minute\n\n# Search results (can be stale)\n@cache(key_prefix=\"search\", expiration=3600)      # 1 hour\n</code></pre> <p>This comprehensive Redis caching system provides high-performance data access while maintaining data consistency through intelligent invalidation strategies. </p>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Learn how to configure your FastAPI Boilerplate application for different environments and use cases. Everything is configured through environment variables and Python settings classes.</p>"},{"location":"user-guide/configuration/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Environment Variables - Configure through <code>.env</code> files</li> <li>Settings Classes - Python-based configuration management</li> <li>Docker Setup - Container and service configuration</li> <li>Environment-Specific - Development, staging, and production configs</li> </ul>"},{"location":"user-guide/configuration/#quick-start","title":"Quick Start","text":"<p>The boilerplate uses environment variables as the primary configuration method:</p> <pre><code># Copy the example file\ncp src/.env.example src/.env\n\n# Edit with your values\nnano src/.env\n</code></pre> <p>Essential variables to set:</p> <pre><code># Application\nAPP_NAME=\"My FastAPI App\"\nSECRET_KEY=\"your-super-secret-key-here\"\n\n# Database\nPOSTGRES_USER=\"your_user\"\nPOSTGRES_PASSWORD=\"your_password\"\nPOSTGRES_DB=\"your_database\"\n\n# Admin Account\nADMIN_EMAIL=\"admin@example.com\"\nADMIN_PASSWORD=\"secure_password\"\n</code></pre>"},{"location":"user-guide/configuration/#configuration-architecture","title":"Configuration Architecture","text":"<p>The configuration system has three layers:</p> <pre><code>Environment Variables (.env files)\n         \u2193\nSettings Classes (Python validation)\n         \u2193\nApplication Configuration (Runtime)\n</code></pre>"},{"location":"user-guide/configuration/#layer-1-environment-variables","title":"Layer 1: Environment Variables","text":"<p>Primary configuration through <code>.env</code> files: <pre><code>POSTGRES_USER=\"myuser\"\nPOSTGRES_PASSWORD=\"mypassword\"\nREDIS_CACHE_HOST=\"localhost\"\nSECRET_KEY=\"your-secret-key\"\n</code></pre></p>"},{"location":"user-guide/configuration/#layer-2-settings-classes","title":"Layer 2: Settings Classes","text":"<p>Python classes that validate and structure configuration: <pre><code>class PostgresSettings(BaseSettings):\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str = Field(min_length=8)\n    POSTGRES_SERVER: str = \"localhost\"\n    POSTGRES_PORT: int = 5432\n    POSTGRES_DB: str\n</code></pre></p>"},{"location":"user-guide/configuration/#layer-3-application-use","title":"Layer 3: Application Use","text":"<p>Configuration injected throughout the application: <pre><code>from app.core.config import settings\n\n# Use anywhere in your code\nDATABASE_URL = f\"postgresql+asyncpg://{settings.POSTGRES_USER}:{settings.POSTGRES_PASSWORD}@{settings.POSTGRES_SERVER}:{settings.POSTGRES_PORT}/{settings.POSTGRES_DB}\"\n</code></pre></p>"},{"location":"user-guide/configuration/#key-configuration-areas","title":"Key Configuration Areas","text":""},{"location":"user-guide/configuration/#security-settings","title":"Security Settings","text":"<pre><code>SECRET_KEY=\"your-super-secret-key-here\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n</code></pre>"},{"location":"user-guide/configuration/#database-configuration","title":"Database Configuration","text":"<pre><code>POSTGRES_USER=\"your_user\"\nPOSTGRES_PASSWORD=\"your_password\"\nPOSTGRES_SERVER=\"localhost\"\nPOSTGRES_PORT=5432\nPOSTGRES_DB=\"your_database\"\n</code></pre>"},{"location":"user-guide/configuration/#redis-services","title":"Redis Services","text":"<pre><code># Cache\nREDIS_CACHE_HOST=\"localhost\"\nREDIS_CACHE_PORT=6379\n\n# Background jobs\nREDIS_QUEUE_HOST=\"localhost\"\nREDIS_QUEUE_PORT=6379\n\n# Rate limiting  \nREDIS_RATE_LIMIT_HOST=\"localhost\"\nREDIS_RATE_LIMIT_PORT=6379\n</code></pre>"},{"location":"user-guide/configuration/#application-settings","title":"Application Settings","text":"<pre><code>APP_NAME=\"Your App Name\"\nAPP_VERSION=\"1.0.0\"\nENVIRONMENT=\"local\"  # local, staging, production\nDEBUG=true\n</code></pre>"},{"location":"user-guide/configuration/#rate-limiting","title":"Rate Limiting","text":"<pre><code>DEFAULT_RATE_LIMIT_LIMIT=100\nDEFAULT_RATE_LIMIT_PERIOD=3600  # 1 hour in seconds\n</code></pre>"},{"location":"user-guide/configuration/#admin-user","title":"Admin User","text":"<pre><code>ADMIN_NAME=\"Admin User\"\nADMIN_EMAIL=\"admin@example.com\"\nADMIN_USERNAME=\"admin\"\nADMIN_PASSWORD=\"secure_password\"\n</code></pre>"},{"location":"user-guide/configuration/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"user-guide/configuration/#development","title":"Development","text":"<pre><code>ENVIRONMENT=\"local\"\nDEBUG=true\nPOSTGRES_SERVER=\"localhost\"\nREDIS_CACHE_HOST=\"localhost\"\nACCESS_TOKEN_EXPIRE_MINUTES=60  # Longer for development\n</code></pre>"},{"location":"user-guide/configuration/#staging","title":"Staging","text":"<pre><code>ENVIRONMENT=\"staging\"\nDEBUG=false\nPOSTGRES_SERVER=\"staging-db.example.com\"\nREDIS_CACHE_HOST=\"staging-redis.example.com\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre>"},{"location":"user-guide/configuration/#production","title":"Production","text":"<pre><code>ENVIRONMENT=\"production\"\nDEBUG=false\nPOSTGRES_SERVER=\"prod-db.example.com\"\nREDIS_CACHE_HOST=\"prod-redis.example.com\"\nACCESS_TOKEN_EXPIRE_MINUTES=15\n# Use custom ports for security\nPOSTGRES_PORT=5433\nREDIS_CACHE_PORT=6380\n</code></pre>"},{"location":"user-guide/configuration/#docker-configuration","title":"Docker Configuration","text":""},{"location":"user-guide/configuration/#basic-setup","title":"Basic Setup","text":"<p>Docker Compose automatically loads your <code>.env</code> file:</p> <pre><code>services:\n  web:\n    env_file:\n      - ./src/.env\n    environment:\n      - DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}\n</code></pre>"},{"location":"user-guide/configuration/#service-overview","title":"Service Overview","text":"<pre><code>services:\n  web:          # FastAPI application\n  db:           # PostgreSQL database  \n  redis:        # Redis for caching/queues\n  worker:       # Background task worker\n</code></pre>"},{"location":"user-guide/configuration/#common-configuration-patterns","title":"Common Configuration Patterns","text":""},{"location":"user-guide/configuration/#feature-flags","title":"Feature Flags","text":"<pre><code># In settings class\nclass FeatureSettings(BaseSettings):\n    ENABLE_CACHING: bool = True\n    ENABLE_ANALYTICS: bool = False\n    ENABLE_BACKGROUND_JOBS: bool = True\n\n# Use in code\nif settings.ENABLE_CACHING:\n    cache_result = await get_from_cache(key)\n</code></pre>"},{"location":"user-guide/configuration/#environment-detection","title":"Environment Detection","text":"<pre><code>@app.get(\"/docs\", include_in_schema=False)\nasync def custom_swagger_ui():\n    if settings.ENVIRONMENT == \"production\":\n        raise HTTPException(404, \"Documentation not available\")\n    return get_swagger_ui_html(openapi_url=\"/openapi.json\")\n</code></pre>"},{"location":"user-guide/configuration/#health-checks","title":"Health Checks","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    return {\n        \"status\": \"healthy\",\n        \"environment\": settings.ENVIRONMENT,\n        \"version\": settings.APP_VERSION,\n        \"database\": await check_database_health(),\n        \"redis\": await check_redis_health()\n    }\n</code></pre>"},{"location":"user-guide/configuration/#quick-configuration-tasks","title":"Quick Configuration Tasks","text":""},{"location":"user-guide/configuration/#generate-secret-key","title":"Generate Secret Key","text":"<pre><code># Generate a secure secret key\nopenssl rand -hex 32\n</code></pre>"},{"location":"user-guide/configuration/#test-configuration","title":"Test Configuration","text":"<pre><code># test_config.py\nfrom app.core.config import settings\n\nprint(f\"App: {settings.APP_NAME}\")\nprint(f\"Environment: {settings.ENVIRONMENT}\")\nprint(f\"Database: {settings.POSTGRES_DB}\")\n</code></pre>"},{"location":"user-guide/configuration/#environment-file-templates","title":"Environment File Templates","text":"<pre><code># Development\ncp src/.env.example src/.env.development\n\n# Staging  \ncp src/.env.example src/.env.staging\n\n# Production\ncp src/.env.example src/.env.production\n</code></pre>"},{"location":"user-guide/configuration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/#security","title":"Security","text":"<ul> <li>Never commit <code>.env</code> files to version control</li> <li>Use different secret keys for each environment</li> <li>Disable debug mode in production</li> <li>Use secure passwords and keys</li> </ul>"},{"location":"user-guide/configuration/#performance","title":"Performance","text":"<ul> <li>Configure appropriate connection pool sizes</li> <li>Set reasonable token expiration times</li> <li>Use Redis for caching in production</li> <li>Configure proper rate limits</li> </ul>"},{"location":"user-guide/configuration/#maintenance","title":"Maintenance","text":"<ul> <li>Document all custom environment variables</li> <li>Use validation in settings classes</li> <li>Test configurations in staging first</li> <li>Monitor configuration changes</li> </ul>"},{"location":"user-guide/configuration/#testing","title":"Testing","text":"<ul> <li>Use separate test environment variables</li> <li>Mock external services in tests</li> <li>Validate configuration on startup</li> <li>Test with different environment combinations</li> </ul>"},{"location":"user-guide/configuration/#getting-started","title":"Getting Started","text":"<p>Follow this path to configure your application:</p>"},{"location":"user-guide/configuration/#1-environment-variables-start-here","title":"1. Environment Variables - Start here","text":"<p>Learn about all available environment variables, their purposes, and recommended values for different environments.</p>"},{"location":"user-guide/configuration/#2-settings-classes-validation-layer","title":"2. Settings Classes - Validation layer","text":"<p>Understand how Python settings classes validate and structure your configuration with type hints and validation rules.</p>"},{"location":"user-guide/configuration/#3-docker-setup-container-configuration","title":"3. Docker Setup - Container configuration","text":"<p>Configure Docker Compose services, networking, and environment-specific overrides.</p>"},{"location":"user-guide/configuration/#4-environment-specific-deployment-configs","title":"4. Environment-Specific - Deployment configs","text":"<p>Set up configuration for development, staging, and production environments with best practices.</p>"},{"location":"user-guide/configuration/#whats-next","title":"What's Next","text":"<p>Each guide provides practical examples and copy-paste configurations:</p> <ol> <li>Environment Variables - Complete reference and examples</li> <li>Settings Classes - Custom validation and organization</li> <li>Docker Setup - Service configuration and overrides</li> <li>Environment-Specific - Production-ready configurations</li> </ol> <p>The boilerplate provides sensible defaults - just customize what you need! </p>"},{"location":"user-guide/configuration/docker-setup/","title":"Docker Setup","text":"<p>Learn how to configure and run the FastAPI Boilerplate using Docker Compose. The project includes a complete containerized setup with PostgreSQL, Redis, background workers, and optional services.</p>"},{"location":"user-guide/configuration/docker-setup/#docker-compose-architecture","title":"Docker Compose Architecture","text":"<p>The boilerplate includes these core services:</p> <pre><code>services:\n  web:          # FastAPI application (uvicorn or gunicorn)\n  worker:       # ARQ background task worker  \n  db:           # PostgreSQL 13 database\n  redis:        # Redis Alpine for caching/queues\n  # Optional services (commented out by default):\n  # pgadmin:    # Database administration\n  # nginx:      # Reverse proxy\n  # create_superuser: # One-time superuser creation\n  # create_tier:      # One-time tier creation\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#basic-docker-compose","title":"Basic Docker Compose","text":""},{"location":"user-guide/configuration/docker-setup/#main-configuration","title":"Main Configuration","text":"<p>The main <code>docker-compose.yml</code> includes:</p> <pre><code>version: '3.8'\n\nservices:\n  web:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    # Development mode (reload enabled)\n    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n    # Production mode (uncomment for production)\n    # command: gunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000\n    env_file:\n      - ./src/.env\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./src/app:/code/app\n      - ./src/.env:/code/.env\n\n  worker:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    command: arq app.core.worker.settings.WorkerSettings\n    env_file:\n      - ./src/.env\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./src/app:/code/app\n      - ./src/.env:/code/.env\n\n  db:\n    image: postgres:13\n    env_file:\n      - ./src/.env\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    expose:\n      - \"5432\"\n\n  redis:\n    image: redis:alpine\n    volumes:\n      - redis-data:/data\n    expose:\n      - \"6379\"\n\nvolumes:\n  postgres-data:\n  redis-data:\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#environment-file-loading","title":"Environment File Loading","text":"<p>All services automatically load environment variables from <code>./src/.env</code>:</p> <pre><code>env_file:\n  - ./src/.env\n</code></pre> <p>The Docker services use these environment variables:</p> <ul> <li><code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_DB</code> for database</li> <li><code>REDIS_*_HOST</code> variables automatically resolve to service names</li> <li>All application settings from your <code>.env</code> file</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#service-details","title":"Service Details","text":""},{"location":"user-guide/configuration/docker-setup/#web-service-fastapi-application","title":"Web Service (FastAPI Application)","text":"<p>The web service runs your FastAPI application:</p> <pre><code>web:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  # Development: uvicorn with reload\n  command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n  # Production: gunicorn with multiple workers (commented out)\n  # command: gunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000\n  env_file:\n    - ./src/.env\n  ports:\n    - \"8000:8000\"  # Direct access in development\n  volumes:\n    - ./src/app:/code/app  # Live code reloading\n    - ./src/.env:/code/.env\n</code></pre> <p>Key Features:</p> <ul> <li>Development mode: Uses uvicorn with <code>--reload</code> for automatic code reloading</li> <li>Production mode: Switch to gunicorn with multiple workers (commented out)</li> <li>Live reloading: Source code mounted as volume for development</li> <li>Port exposure: Direct access on port 8000 (can be disabled for nginx)</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#worker-service-background-tasks","title":"Worker Service (Background Tasks)","text":"<p>Handles background job processing with ARQ:</p> <pre><code>worker:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  command: arq app.core.worker.settings.WorkerSettings\n  env_file:\n    - ./src/.env\n  depends_on:\n    - db\n    - redis\n  volumes:\n    - ./src/app:/code/app\n    - ./src/.env:/code/.env\n</code></pre> <p>Features: - Runs ARQ worker for background job processing - Shares the same codebase and environment as web service - Automatically connects to Redis for job queues - Live code reloading in development</p>"},{"location":"user-guide/configuration/docker-setup/#database-service-postgresql-13","title":"Database Service (PostgreSQL 13)","text":"<pre><code>db:\n  image: postgres:13\n  env_file:\n    - ./src/.env\n  volumes:\n    - postgres-data:/var/lib/postgresql/data\n  expose:\n    - \"5432\"  # Internal network only\n</code></pre> <p>Configuration: - Uses environment variables: <code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_DB</code> - Data persisted in named volume <code>postgres-data</code> - Only exposed to internal Docker network (no external port) - To enable external access, uncomment the ports section</p>"},{"location":"user-guide/configuration/docker-setup/#redis-service","title":"Redis Service","text":"<pre><code>redis:\n  image: redis:alpine\n  volumes:\n    - redis-data:/data\n  expose:\n    - \"6379\"  # Internal network only\n</code></pre> <p>Features: - Lightweight Alpine Linux image - Data persistence with named volume - Used for caching, job queues, and rate limiting - Internal network access only</p>"},{"location":"user-guide/configuration/docker-setup/#optional-services","title":"Optional Services","text":""},{"location":"user-guide/configuration/docker-setup/#database-administration-pgadmin","title":"Database Administration (pgAdmin)","text":"<p>Uncomment to enable web-based database management:</p> <pre><code>pgadmin:\n  container_name: pgadmin4\n  image: dpage/pgadmin4:latest\n  restart: always\n  ports:\n    - \"5050:80\"\n  volumes:\n    - pgadmin-data:/var/lib/pgadmin\n  env_file:\n    - ./src/.env\n  depends_on:\n    - db\n</code></pre> <p>Usage: - Access at <code>http://localhost:5050</code> - Requires <code>PGADMIN_DEFAULT_EMAIL</code> and <code>PGADMIN_DEFAULT_PASSWORD</code> in <code>.env</code> - Connect to database using service name <code>db</code> and port <code>5432</code></p>"},{"location":"user-guide/configuration/docker-setup/#reverse-proxy-nginx","title":"Reverse Proxy (Nginx)","text":"<p>Uncomment for production-style reverse proxy:</p> <pre><code>nginx:\n  image: nginx:latest\n  ports:\n    - \"80:80\"\n  volumes:\n    - ./default.conf:/etc/nginx/conf.d/default.conf\n  depends_on:\n    - web\n</code></pre> <p>Configuration: The included <code>default.conf</code> provides:</p> <pre><code>server {\n    listen 80;\n\n    location / {\n        proxy_pass http://web:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre> <p>When using nginx:</p> <ol> <li>Uncomment the nginx service</li> <li>Comment out the <code>ports</code> section in the web service</li> <li>Uncomment <code>expose: [\"8000\"]</code> in the web service</li> </ol>"},{"location":"user-guide/configuration/docker-setup/#initialization-services","title":"Initialization Services","text":""},{"location":"user-guide/configuration/docker-setup/#create-first-superuser","title":"Create First Superuser","text":"<pre><code>create_superuser:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  env_file:\n    - ./src/.env\n  depends_on:\n    - db\n    - web\n  command: python -m src.scripts.create_first_superuser\n  volumes:\n    - ./src:/code/src\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#create-first-tier","title":"Create First Tier","text":"<pre><code>create_tier:\n  build:\n    context: .\n    dockerfile: Dockerfile\n  env_file:\n    - ./src/.env\n  depends_on:\n    - db\n    - web\n  command: python -m src.scripts.create_first_tier\n  volumes:\n    - ./src:/code/src\n</code></pre> <p>Usage:</p> <ul> <li>These are one-time setup services</li> <li>Uncomment when you need to initialize data</li> <li>Run once, then comment out again</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#dockerfile-details","title":"Dockerfile Details","text":"<p>The project uses a multi-stage Dockerfile with <code>uv</code> for fast Python package management:</p>"},{"location":"user-guide/configuration/docker-setup/#builder-stage","title":"Builder Stage","text":"<pre><code>FROM ghcr.io/astral-sh/uv:python3.11-bookworm-slim AS builder\n\nENV UV_COMPILE_BYTECODE=1\nENV UV_LINK_MODE=copy\n\nWORKDIR /app\n\n# Install dependencies (cached layer)\nRUN --mount=type=cache,target=/root/.cache/uv \\\n    --mount=type=bind,source=uv.lock,target=uv.lock \\\n    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \\\n    uv sync --locked --no-install-project\n\n# Copy and install project\nCOPY . /app\nRUN --mount=type=cache,target=/root/.cache/uv \\\n    uv sync --locked --no-editable\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#final-stage","title":"Final Stage","text":"<pre><code>FROM python:3.11-slim-bookworm\n\n# Create non-root user for security\nRUN groupadd --gid 1000 app \\\n    &amp;&amp; useradd --uid 1000 --gid app --shell /bin/bash --create-home app\n\n# Copy virtual environment from builder\nCOPY --from=builder --chown=app:app /app/.venv /app/.venv\n\nENV PATH=\"/app/.venv/bin:$PATH\"\nUSER app\nWORKDIR /code\n\n# Default command (can be overridden)\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--reload\"]\n</code></pre> <p>Security Features:</p> <ul> <li>Non-root user execution</li> <li>Multi-stage build for smaller final image</li> <li>Cached dependency installation</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#common-docker-commands","title":"Common Docker Commands","text":""},{"location":"user-guide/configuration/docker-setup/#development-workflow","title":"Development Workflow","text":"<pre><code># Start all services\ndocker compose up\n\n# Start in background\ndocker compose up -d\n\n# Rebuild and start (after code changes)\ndocker compose up --build\n\n# View logs\ndocker compose logs -f web\ndocker compose logs -f worker\n\n# Stop services\ndocker compose down\n\n# Stop and remove volumes (reset data)\ndocker compose down -v\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#service-management","title":"Service Management","text":"<pre><code># Start specific services\ndocker compose up web db redis\n\n# Scale workers\ndocker compose up --scale worker=3\n\n# Execute commands in running containers\ndocker compose exec web bash\ndocker compose exec db psql -U postgres\ndocker compose exec redis redis-cli\n\n# View service status\ndocker compose ps\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#production-mode","title":"Production Mode","text":"<p>To switch to production mode:</p> <ol> <li> <p>Enable Gunicorn: <pre><code># Comment out uvicorn line\n# command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n# Uncomment gunicorn line\ncommand: gunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000\n</code></pre></p> </li> <li> <p>Enable Nginx (optional):    <pre><code># Uncomment nginx service\nnginx:\n  image: nginx:latest\n  ports:\n    - \"80:80\"\n\n# In web service, comment out ports and uncomment expose\n# ports:\n#   - \"8000:8000\"\nexpose:\n  - \"8000\"\n</code></pre></p> </li> <li> <p>Remove development volumes: <pre><code># Remove or comment out for production\n# volumes:\n#   - ./src/app:/code/app\n#   - ./src/.env:/code/.env\n</code></pre></p> </li> </ol>"},{"location":"user-guide/configuration/docker-setup/#environment-configuration","title":"Environment Configuration","text":""},{"location":"user-guide/configuration/docker-setup/#service-communication","title":"Service Communication","text":"<p>Services communicate using service names:</p> <pre><code># In your .env file for Docker\nPOSTGRES_SERVER=db      # Not localhost\nREDIS_CACHE_HOST=redis  # Not localhost\nREDIS_QUEUE_HOST=redis\nREDIS_RATE_LIMIT_HOST=redis\n</code></pre>"},{"location":"user-guide/configuration/docker-setup/#port-management","title":"Port Management","text":"<p>Development (default): - Web: <code>localhost:8000</code> (direct access) - Database: <code>localhost:5432</code> (uncomment ports to enable) - Redis: <code>localhost:6379</code> (uncomment ports to enable) - pgAdmin: <code>localhost:5050</code> (if enabled)</p> <p>Production with Nginx: - Web: <code>localhost:80</code> (through nginx) - Database: Internal only - Redis: Internal only</p>"},{"location":"user-guide/configuration/docker-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/configuration/docker-setup/#common-issues","title":"Common Issues","text":"<p>Container won't start: <pre><code># Check logs\ndocker compose logs web\n\n# Rebuild image\ndocker compose build --no-cache web\n\n# Check environment file\ndocker compose exec web env | grep POSTGRES\n</code></pre></p> <p>Database connection issues: <pre><code># Check if db service is running\ndocker compose ps db\n\n# Test connection from web container\ndocker compose exec web ping db\n\n# Check database logs\ndocker compose logs db\n</code></pre></p> <p>Port conflicts: <pre><code># Check what's using the port\nlsof -i :8000\n\n# Use different ports\nports:\n  - \"8001:8000\"  # Use port 8001 instead\n</code></pre></p>"},{"location":"user-guide/configuration/docker-setup/#development-vs-production","title":"Development vs Production","text":"<p>Development features:</p> <ul> <li>Live code reloading with volume mounts</li> <li>Direct port access</li> <li>uvicorn with <code>--reload</code></li> <li>Exposed database/redis ports for debugging</li> </ul> <p>Production optimizations:</p> <ul> <li>No volume mounts (code baked into image)</li> <li>Nginx reverse proxy</li> <li>Gunicorn with multiple workers</li> <li>Internal service networking only</li> <li>Resource limits and health checks</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/docker-setup/#development","title":"Development","text":"<ul> <li>Use volume mounts for live code reloading</li> <li>Enable direct port access for debugging</li> <li>Use uvicorn with reload for fast development</li> <li>Enable optional services (pgAdmin) as needed</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#production","title":"Production","text":"<ul> <li>Switch to gunicorn with multiple workers</li> <li>Use nginx for reverse proxy and load balancing</li> <li>Remove volume mounts and bake code into images</li> <li>Use internal networking only</li> <li>Set resource limits and health checks</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#security","title":"Security","text":"<ul> <li>Containers run as non-root user</li> <li>Use internal networking for service communication</li> <li>Don't expose database/redis ports externally</li> <li>Use Docker secrets for sensitive data in production</li> </ul>"},{"location":"user-guide/configuration/docker-setup/#monitoring","title":"Monitoring","text":"<ul> <li>Use <code>docker compose logs</code> to monitor services</li> <li>Set up health checks for all services</li> <li>Monitor resource usage with <code>docker stats</code></li> <li>Use structured logging for better observability</li> </ul> <p>The Docker setup provides everything you need for both development and production. Start with the default configuration and customize as your needs grow! </p>"},{"location":"user-guide/configuration/environment-specific/","title":"Environment-Specific Configuration","text":"<p>Learn how to configure your FastAPI application for different environments (development, staging, production) with appropriate security, performance, and monitoring settings.</p>"},{"location":"user-guide/configuration/environment-specific/#environment-types","title":"Environment Types","text":"<p>The boilerplate supports three environment types:</p> <ul> <li><code>local</code> - Development environment with full debugging</li> <li><code>staging</code> - Pre-production testing environment  </li> <li><code>production</code> - Production environment with security hardening</li> </ul> <p>Set the environment type with:</p> <pre><code>ENVIRONMENT=\"local\"  # or \"staging\" or \"production\"\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#development-environment","title":"Development Environment","text":""},{"location":"user-guide/configuration/environment-specific/#local-development-settings","title":"Local Development Settings","text":"<p>Create <code>src/.env.development</code>:</p> <pre><code># ------------- environment -------------\nENVIRONMENT=\"local\"\nDEBUG=true\n\n# ------------- app settings -------------\nAPP_NAME=\"MyApp (Development)\"\nAPP_VERSION=\"0.1.0-dev\"\n\n# ------------- database -------------\nPOSTGRES_USER=\"dev_user\"\nPOSTGRES_PASSWORD=\"dev_password\"\nPOSTGRES_SERVER=\"localhost\"\nPOSTGRES_PORT=5432\nPOSTGRES_DB=\"myapp_dev\"\n\n# ------------- crypt -------------\nSECRET_KEY=\"dev-secret-key-not-for-production-use\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=60  # Longer for development\nREFRESH_TOKEN_EXPIRE_DAYS=30     # Longer for development\n\n# ------------- redis -------------\nREDIS_CACHE_HOST=\"localhost\"\nREDIS_CACHE_PORT=6379\nREDIS_QUEUE_HOST=\"localhost\"\nREDIS_QUEUE_PORT=6379\nREDIS_RATE_LIMIT_HOST=\"localhost\"\nREDIS_RATE_LIMIT_PORT=6379\n\n# ------------- caching -------------\nCLIENT_CACHE_MAX_AGE=0  # Disable caching for development\n\n# ------------- rate limiting -------------\nDEFAULT_RATE_LIMIT_LIMIT=1000   # Higher limits for development\nDEFAULT_RATE_LIMIT_PERIOD=3600\n\n# ------------- admin -------------\nADMIN_NAME=\"Dev Admin\"\nADMIN_EMAIL=\"admin@localhost\"\nADMIN_USERNAME=\"admin\"\nADMIN_PASSWORD=\"admin123\"\n\n# ------------- tier -------------\nTIER_NAME=\"dev_tier\"\n\n# ------------- logging -------------\nDATABASE_ECHO=true  # Log all SQL queries\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#development-features","title":"Development Features","text":"<pre><code># Development-specific features\nif settings.ENVIRONMENT == \"local\":\n    # Enable detailed error pages\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],  # Allow all origins in development\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\n    # Enable API documentation\n    app.openapi_url = \"/openapi.json\"\n    app.docs_url = \"/docs\"\n    app.redoc_url = \"/redoc\"\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#docker-development-override","title":"Docker Development Override","text":"<p><code>docker-compose.override.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  web:\n    environment:\n      - ENVIRONMENT=local\n      - DEBUG=true\n      - DATABASE_ECHO=true\n    volumes:\n      - ./src:/code/src:cached\n    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n    ports:\n      - \"8000:8000\"\n\n  db:\n    environment:\n      - POSTGRES_DB=myapp_dev\n    ports:\n      - \"5432:5432\"\n\n  redis:\n    ports:\n      - \"6379:6379\"\n\n  # Development tools\n  adminer:\n    image: adminer\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - db\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#staging-environment","title":"Staging Environment","text":""},{"location":"user-guide/configuration/environment-specific/#staging-settings","title":"Staging Settings","text":"<p>Create <code>src/.env.staging</code>:</p> <pre><code># ------------- environment -------------\nENVIRONMENT=\"staging\"\nDEBUG=false\n\n# ------------- app settings -------------\nAPP_NAME=\"MyApp (Staging)\"\nAPP_VERSION=\"0.1.0-staging\"\n\n# ------------- database -------------\nPOSTGRES_USER=\"staging_user\"\nPOSTGRES_PASSWORD=\"complex_staging_password_123!\"\nPOSTGRES_SERVER=\"staging-db.example.com\"\nPOSTGRES_PORT=5432\nPOSTGRES_DB=\"myapp_staging\"\n\n# ------------- crypt -------------\nSECRET_KEY=\"staging-secret-key-different-from-production\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n\n# ------------- redis -------------\nREDIS_CACHE_HOST=\"staging-redis.example.com\"\nREDIS_CACHE_PORT=6379\nREDIS_QUEUE_HOST=\"staging-redis.example.com\"\nREDIS_QUEUE_PORT=6379\nREDIS_RATE_LIMIT_HOST=\"staging-redis.example.com\"\nREDIS_RATE_LIMIT_PORT=6379\n\n# ------------- caching -------------\nCLIENT_CACHE_MAX_AGE=300  # 5 minutes\n\n# ------------- rate limiting -------------\nDEFAULT_RATE_LIMIT_LIMIT=100\nDEFAULT_RATE_LIMIT_PERIOD=3600\n\n# ------------- admin -------------\nADMIN_NAME=\"Staging Admin\"\nADMIN_EMAIL=\"admin@staging.example.com\"\nADMIN_USERNAME=\"staging_admin\"\nADMIN_PASSWORD=\"secure_staging_password_456!\"\n\n# ------------- tier -------------\nTIER_NAME=\"staging_tier\"\n\n# ------------- logging -------------\nDATABASE_ECHO=false\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#staging-features","title":"Staging Features","text":"<pre><code># Staging-specific features\nif settings.ENVIRONMENT == \"staging\":\n    # Restricted CORS\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"https://staging.example.com\"],\n        allow_credentials=True,\n        allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n        allow_headers=[\"*\"],\n    )\n\n    # API docs available to superusers only\n    @app.get(\"/docs\", include_in_schema=False)\n    async def custom_swagger_ui(current_user: User = Depends(get_current_superuser)):\n        return get_swagger_ui_html(openapi_url=\"/openapi.json\")\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#docker-staging-configuration","title":"Docker Staging Configuration","text":"<p><code>docker-compose.staging.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  web:\n    environment:\n      - ENVIRONMENT=staging\n      - DEBUG=false\n    deploy:\n      replicas: 2\n      resources:\n        limits:\n          memory: 1G\n        reservations:\n          memory: 512M\n    restart: always\n\n  db:\n    environment:\n      - POSTGRES_DB=myapp_staging\n    volumes:\n      - postgres_staging_data:/var/lib/postgresql/data\n    restart: always\n\n  redis:\n    restart: always\n\n  worker:\n    deploy:\n      replicas: 2\n    restart: always\n\nvolumes:\n  postgres_staging_data:\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#production-environment","title":"Production Environment","text":""},{"location":"user-guide/configuration/environment-specific/#production-settings","title":"Production Settings","text":"<p>Create <code>src/.env.production</code>:</p> <pre><code># ------------- environment -------------\nENVIRONMENT=\"production\"\nDEBUG=false\n\n# ------------- app settings -------------\nAPP_NAME=\"MyApp\"\nAPP_VERSION=\"1.0.0\"\nCONTACT_NAME=\"Support Team\"\nCONTACT_EMAIL=\"support@example.com\"\n\n# ------------- database -------------\nPOSTGRES_USER=\"prod_user\"\nPOSTGRES_PASSWORD=\"ultra_secure_production_password_789!\"\nPOSTGRES_SERVER=\"prod-db.example.com\"\nPOSTGRES_PORT=5433  # Custom port for security\nPOSTGRES_DB=\"myapp_production\"\n\n# ------------- crypt -------------\nSECRET_KEY=\"ultra-secure-production-key-generated-with-openssl-rand-hex-32\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=15  # Shorter for security\nREFRESH_TOKEN_EXPIRE_DAYS=3     # Shorter for security\n\n# ------------- redis -------------\nREDIS_CACHE_HOST=\"prod-redis.example.com\"\nREDIS_CACHE_PORT=6380  # Custom port for security\nREDIS_QUEUE_HOST=\"prod-redis.example.com\"\nREDIS_QUEUE_PORT=6380\nREDIS_RATE_LIMIT_HOST=\"prod-redis.example.com\"\nREDIS_RATE_LIMIT_PORT=6380\n\n# ------------- caching -------------\nCLIENT_CACHE_MAX_AGE=3600  # 1 hour\n\n# ------------- rate limiting -------------\nDEFAULT_RATE_LIMIT_LIMIT=100\nDEFAULT_RATE_LIMIT_PERIOD=3600\n\n# ------------- admin -------------\nADMIN_NAME=\"System Administrator\"\nADMIN_EMAIL=\"admin@example.com\"\nADMIN_USERNAME=\"sysadmin\"\nADMIN_PASSWORD=\"extremely_secure_admin_password_with_symbols_#$%!\"\n\n# ------------- tier -------------\nTIER_NAME=\"production_tier\"\n\n# ------------- logging -------------\nDATABASE_ECHO=false\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#production-security-features","title":"Production Security Features","text":"<pre><code># Production-specific features\nif settings.ENVIRONMENT == \"production\":\n    # Strict CORS\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"https://example.com\", \"https://www.example.com\"],\n        allow_credentials=True,\n        allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n        allow_headers=[\"Authorization\", \"Content-Type\"],\n    )\n\n    # Disable API documentation\n    app.openapi_url = None\n    app.docs_url = None\n    app.redoc_url = None\n\n    # Add security headers\n    @app.middleware(\"http\")\n    async def add_security_headers(request: Request, call_next):\n        response = await call_next(request)\n        response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n        response.headers[\"X-Frame-Options\"] = \"DENY\"\n        response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n        response.headers[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains\"\n        return response\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#docker-production-configuration","title":"Docker Production Configuration","text":"<p><code>docker-compose.prod.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  web:\n    environment:\n      - ENVIRONMENT=production\n      - DEBUG=false\n    deploy:\n      replicas: 3\n      resources:\n        limits:\n          memory: 2G\n          cpus: '1'\n        reservations:\n          memory: 1G\n          cpus: '0.5'\n    restart: always\n    ports: []  # No direct exposure\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf\n      - ./nginx/ssl:/etc/nginx/ssl\n      - ./nginx/htpasswd:/etc/nginx/htpasswd\n    depends_on:\n      - web\n    restart: always\n\n  db:\n    environment:\n      - POSTGRES_DB=myapp_production\n    volumes:\n      - postgres_prod_data:/var/lib/postgresql/data\n    ports: []  # No external access\n    deploy:\n      resources:\n        limits:\n          memory: 4G\n        reservations:\n          memory: 2G\n    restart: always\n\n  redis:\n    volumes:\n      - redis_prod_data:/data\n    ports: []  # No external access\n    deploy:\n      resources:\n        limits:\n          memory: 1G\n        reservations:\n          memory: 512M\n    restart: always\n\n  worker:\n    deploy:\n      replicas: 2\n      resources:\n        limits:\n          memory: 1G\n        reservations:\n          memory: 512M\n    restart: always\n\nvolumes:\n  postgres_prod_data:\n  redis_prod_data:\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#environment-detection","title":"Environment Detection","text":""},{"location":"user-guide/configuration/environment-specific/#runtime-environment-checks","title":"Runtime Environment Checks","text":"<pre><code># src/app/core/config.py\nclass Settings(BaseSettings):\n    @computed_field\n    @property\n    def IS_DEVELOPMENT(self) -&gt; bool:\n        return self.ENVIRONMENT == \"local\"\n\n    @computed_field\n    @property\n    def IS_PRODUCTION(self) -&gt; bool:\n        return self.ENVIRONMENT == \"production\"\n\n    @computed_field\n    @property\n    def IS_STAGING(self) -&gt; bool:\n        return self.ENVIRONMENT == \"staging\"\n\n# Use in application\nif settings.IS_DEVELOPMENT:\n    # Development-only code\n    pass\n\nif settings.IS_PRODUCTION:\n    # Production-only code\n    pass\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#environment-specific-validation","title":"Environment-Specific Validation","text":"<pre><code>@model_validator(mode=\"after\")\ndef validate_environment_config(self) -&gt; \"Settings\":\n    if self.ENVIRONMENT == \"production\":\n        # Production validation\n        if self.DEBUG:\n            raise ValueError(\"DEBUG must be False in production\")\n        if len(self.SECRET_KEY) &lt; 32:\n            raise ValueError(\"SECRET_KEY must be at least 32 characters in production\")\n        if \"dev\" in self.SECRET_KEY.lower():\n            raise ValueError(\"Production SECRET_KEY cannot contain 'dev'\")\n\n    if self.ENVIRONMENT == \"local\":\n        # Development warnings\n        if not self.DEBUG:\n            logger.warning(\"DEBUG is False in development environment\")\n\n    return self\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#configuration-management","title":"Configuration Management","text":""},{"location":"user-guide/configuration/environment-specific/#environment-file-templates","title":"Environment File Templates","text":"<p>Create template files for each environment:</p> <pre><code># Create environment templates\ncp src/.env.example src/.env.development\ncp src/.env.example src/.env.staging\ncp src/.env.example src/.env.production\n\n# Use environment-specific files\nln -sf .env.development src/.env  # For development\nln -sf .env.staging src/.env      # For staging\nln -sf .env.production src/.env   # For production\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#configuration-validation","title":"Configuration Validation","text":"<pre><code># src/scripts/validate_config.py\nimport asyncio\nfrom src.app.core.config import settings\nfrom src.app.core.db.database import async_get_db\n\nasync def validate_configuration():\n    \"\"\"Validate configuration for current environment.\"\"\"\n    print(f\"Validating configuration for {settings.ENVIRONMENT} environment...\")\n\n    # Basic settings validation\n    assert settings.APP_NAME, \"APP_NAME is required\"\n    assert settings.SECRET_KEY, \"SECRET_KEY is required\"\n    assert len(settings.SECRET_KEY) &gt;= 32, \"SECRET_KEY must be at least 32 characters\"\n\n    # Environment-specific validation\n    if settings.ENVIRONMENT == \"production\":\n        assert not settings.DEBUG, \"DEBUG must be False in production\"\n        assert \"dev\" not in settings.SECRET_KEY.lower(), \"Production SECRET_KEY invalid\"\n        assert settings.POSTGRES_PORT != 5432, \"Use custom PostgreSQL port in production\"\n\n    # Test database connection\n    try:\n        db = await anext(async_get_db())\n        print(\"\u2713 Database connection successful\")\n        await db.close()\n    except Exception as e:\n        print(f\"\u2717 Database connection failed: {e}\")\n        return False\n\n    print(\"\u2713 Configuration validation passed\")\n    return True\n\nif __name__ == \"__main__\":\n    asyncio.run(validate_configuration())\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#environment-switching","title":"Environment Switching","text":"<pre><code>#!/bin/bash\n# scripts/switch_env.sh\n\nENV=$1\n\nif [ -z \"$ENV\" ]; then\n    echo \"Usage: $0 &lt;development|staging|production&gt;\"\n    exit 1\nfi\n\ncase $ENV in\n    development)\n        ln -sf .env.development src/.env\n        echo \"Switched to development environment\"\n        ;;\n    staging)\n        ln -sf .env.staging src/.env\n        echo \"Switched to staging environment\"\n        ;;\n    production)\n        ln -sf .env.production src/.env\n        echo \"Switched to production environment\"\n        echo \"WARNING: Make sure to review all settings before deployment!\"\n        ;;\n    *)\n        echo \"Invalid environment: $ENV\"\n        echo \"Valid options: development, staging, production\"\n        exit 1\n        ;;\nesac\n\n# Validate configuration\npython -c \"from src.app.core.config import settings; print(f'Current environment: {settings.ENVIRONMENT}')\"\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#security-best-practices","title":"Security Best Practices","text":""},{"location":"user-guide/configuration/environment-specific/#environment-specific-security","title":"Environment-Specific Security","text":"<pre><code># Different security levels per environment\nSECURITY_CONFIGS = {\n    \"local\": {\n        \"token_expire_minutes\": 60,\n        \"enable_cors_origins\": [\"*\"],\n        \"enable_docs\": True,\n        \"log_level\": \"DEBUG\",\n    },\n    \"staging\": {\n        \"token_expire_minutes\": 30,\n        \"enable_cors_origins\": [\"https://staging.example.com\"],\n        \"enable_docs\": True,  # For testing\n        \"log_level\": \"INFO\",\n    },\n    \"production\": {\n        \"token_expire_minutes\": 15,\n        \"enable_cors_origins\": [\"https://example.com\"],\n        \"enable_docs\": False,\n        \"log_level\": \"WARNING\",\n    }\n}\n\nconfig = SECURITY_CONFIGS[settings.ENVIRONMENT]\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#secrets-management","title":"Secrets Management","text":"<pre><code># Use secrets management in production\n# Instead of plain text environment variables\nPOSTGRES_PASSWORD_FILE=\"/run/secrets/postgres_password\"\nSECRET_KEY_FILE=\"/run/secrets/jwt_secret\"\n\n# Docker secrets\nservices:\n  web:\n    secrets:\n      - postgres_password\n      - jwt_secret\n    environment:\n      - POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password\n      - SECRET_KEY_FILE=/run/secrets/jwt_secret\n\nsecrets:\n  postgres_password:\n    external: true\n  jwt_secret:\n    external: true\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"user-guide/configuration/environment-specific/#environment-specific-logging","title":"Environment-Specific Logging","text":"<pre><code>LOGGING_CONFIG = {\n    \"local\": {\n        \"level\": \"DEBUG\",\n        \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        \"handlers\": [\"console\"],\n    },\n    \"staging\": {\n        \"level\": \"INFO\", \n        \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        \"handlers\": [\"console\", \"file\"],\n    },\n    \"production\": {\n        \"level\": \"WARNING\",\n        \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s\",\n        \"handlers\": [\"file\", \"syslog\"],\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#health-checks-by-environment","title":"Health Checks by Environment","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    health_info = {\n        \"status\": \"healthy\",\n        \"environment\": settings.ENVIRONMENT,\n        \"version\": settings.APP_VERSION,\n    }\n\n    # Add detailed info in non-production\n    if not settings.IS_PRODUCTION:\n        health_info.update({\n            \"database\": await check_database_health(),\n            \"redis\": await check_redis_health(),\n            \"worker_queue\": await check_worker_health(),\n        })\n\n    return health_info\n</code></pre>"},{"location":"user-guide/configuration/environment-specific/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/environment-specific/#security","title":"Security","text":"<ul> <li>Use different secret keys for each environment</li> <li>Disable debug mode in staging and production</li> <li>Use custom ports in production</li> <li>Implement proper CORS policies</li> <li>Remove API documentation in production</li> </ul>"},{"location":"user-guide/configuration/environment-specific/#performance","title":"Performance","text":"<ul> <li>Configure appropriate resource limits per environment</li> <li>Use caching in staging and production</li> <li>Set shorter token expiration in production</li> <li>Use connection pooling in production</li> </ul>"},{"location":"user-guide/configuration/environment-specific/#configuration","title":"Configuration","text":"<ul> <li>Keep environment files in version control (except production)</li> <li>Use validation to prevent misconfiguration</li> <li>Document all environment-specific settings</li> <li>Test configuration changes in staging first</li> </ul>"},{"location":"user-guide/configuration/environment-specific/#monitoring","title":"Monitoring","text":"<ul> <li>Use appropriate log levels per environment</li> <li>Monitor different metrics in each environment</li> <li>Set up alerts for production only</li> <li>Use health checks for all environments</li> </ul> <p>Environment-specific configuration ensures your application runs securely and efficiently in each deployment stage. Start with development settings and progressively harden for production! </p>"},{"location":"user-guide/configuration/environment-variables/","title":"Configuration Guide","text":"<p>This guide covers all configuration options available in the FastAPI Boilerplate, including environment variables, settings classes, and advanced deployment configurations.</p>"},{"location":"user-guide/configuration/environment-variables/#configuration-overview","title":"Configuration Overview","text":"<p>The boilerplate uses a layered configuration approach:</p> <ul> <li>Environment Variables (<code>.env</code> file) - Primary configuration method</li> <li>Settings Classes (<code>src/app/core/config.py</code>) - Python-based configuration</li> <li>Docker Configuration (<code>docker-compose.yml</code>) - Container orchestration</li> <li>Database Configuration (<code>alembic.ini</code>) - Database migrations</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#environment-variables-reference","title":"Environment Variables Reference","text":"<p>All configuration is managed through environment variables defined in the <code>.env</code> file located in the <code>src/</code> directory.</p>"},{"location":"user-guide/configuration/environment-variables/#application-settings","title":"Application Settings","text":"<p>Basic application metadata displayed in API documentation:</p> <pre><code># ------------- app settings -------------\nAPP_NAME=\"Your App Name\"\nAPP_DESCRIPTION=\"Your app description here\"\nAPP_VERSION=\"0.1.0\"\nCONTACT_NAME=\"Your Name\"\nCONTACT_EMAIL=\"your.email@example.com\"\nLICENSE_NAME=\"MIT\"\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>APP_NAME</code>: Displayed in API documentation and responses</li> <li><code>APP_DESCRIPTION</code>: Shown in OpenAPI documentation</li> <li><code>APP_VERSION</code>: API version for documentation and headers</li> <li><code>CONTACT_NAME</code>: Contact information for API documentation</li> <li><code>CONTACT_EMAIL</code>: Support email for API users</li> <li><code>LICENSE_NAME</code>: License type for the API</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#database-configuration","title":"Database Configuration","text":"<p>PostgreSQL database connection settings:</p> <pre><code># ------------- database -------------\nPOSTGRES_USER=\"your_postgres_user\"\nPOSTGRES_PASSWORD=\"your_secure_password\"\nPOSTGRES_SERVER=\"localhost\"\nPOSTGRES_PORT=5432\nPOSTGRES_DB=\"your_database_name\"\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>POSTGRES_USER</code>: Database user with appropriate permissions</li> <li><code>POSTGRES_PASSWORD</code>: Strong password for database access</li> <li><code>POSTGRES_SERVER</code>: Hostname or IP of PostgreSQL server</li> <li><code>POSTGRES_PORT</code>: PostgreSQL port (default: 5432)</li> <li><code>POSTGRES_DB</code>: Name of the database to connect to</li> </ul> <p>Environment-Specific Values:</p> <pre><code># Local development\nPOSTGRES_SERVER=\"localhost\"\n\n# Docker Compose\nPOSTGRES_SERVER=\"db\"\n\n# Production\nPOSTGRES_SERVER=\"your-prod-db-host.com\"\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#security-authentication","title":"Security &amp; Authentication","text":"<p>JWT and password security configuration:</p> <pre><code># ------------- crypt -------------\nSECRET_KEY=\"your-super-secret-key-here\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nREFRESH_TOKEN_EXPIRE_DAYS=7\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>SECRET_KEY</code>: Used for JWT token signing (generate with <code>openssl rand -hex 32</code>)</li> <li><code>ALGORITHM</code>: JWT signing algorithm (HS256 recommended)</li> <li><code>ACCESS_TOKEN_EXPIRE_MINUTES</code>: How long access tokens remain valid</li> <li><code>REFRESH_TOKEN_EXPIRE_DAYS</code>: How long refresh tokens remain valid</li> </ul> <p>Security Warning</p> <p>Never use default values in production. Generate a strong secret key: <pre><code>openssl rand -hex 32\n</code></pre></p>"},{"location":"user-guide/configuration/environment-variables/#redis-configuration","title":"Redis Configuration","text":"<p>Redis is used for caching, job queues, and rate limiting:</p> <pre><code># ------------- redis cache -------------\nREDIS_CACHE_HOST=\"localhost\"  # Use \"redis\" for Docker Compose\nREDIS_CACHE_PORT=6379\n\n# ------------- redis queue -------------\nREDIS_QUEUE_HOST=\"localhost\"  # Use \"redis\" for Docker Compose  \nREDIS_QUEUE_PORT=6379\n\n# ------------- redis rate limit -------------\nREDIS_RATE_LIMIT_HOST=\"localhost\"  # Use \"redis\" for Docker Compose\nREDIS_RATE_LIMIT_PORT=6379\n</code></pre> <p>Best Practices:</p> <ul> <li>Development: Use the same Redis instance for all services</li> <li>Production: Use separate Redis instances for better isolation</li> </ul> <pre><code># Production example with separate instances\nREDIS_CACHE_HOST=\"cache.redis.example.com\"\nREDIS_QUEUE_HOST=\"queue.redis.example.com\"\nREDIS_RATE_LIMIT_HOST=\"ratelimit.redis.example.com\"\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#caching-settings","title":"Caching Settings","text":"<p>Client-side and server-side caching configuration:</p> <pre><code># ------------- redis client-side cache -------------\nCLIENT_CACHE_MAX_AGE=30  # seconds\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>CLIENT_CACHE_MAX_AGE</code>: How long browsers should cache responses</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#rate-limiting","title":"Rate Limiting","text":"<p>Default rate limiting configuration:</p> <pre><code># ------------- default rate limit settings -------------\nDEFAULT_RATE_LIMIT_LIMIT=10      # requests per period\nDEFAULT_RATE_LIMIT_PERIOD=3600   # period in seconds (1 hour)\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>DEFAULT_RATE_LIMIT_LIMIT</code>: Number of requests allowed per period</li> <li><code>DEFAULT_RATE_LIMIT_PERIOD</code>: Time window in seconds</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#admin-user","title":"Admin User","text":"<p>First superuser account configuration:</p> <pre><code># ------------- admin -------------\nADMIN_NAME=\"Admin User\"\nADMIN_EMAIL=\"admin@example.com\"\nADMIN_USERNAME=\"admin\"\nADMIN_PASSWORD=\"secure_admin_password\"\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>ADMIN_NAME</code>: Display name for the admin user</li> <li><code>ADMIN_EMAIL</code>: Email address for the admin account</li> <li><code>ADMIN_USERNAME</code>: Username for admin login</li> <li><code>ADMIN_PASSWORD</code>: Initial password (change after first login)</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#user-tiers","title":"User Tiers","text":"<p>Initial tier configuration:</p> <pre><code># ------------- first tier -------------\nTIER_NAME=\"free\"\n</code></pre> <p>Variables Explained:</p> <ul> <li><code>TIER_NAME</code>: Name of the default user tier</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#environment-type","title":"Environment Type","text":"<p>Controls API documentation visibility and behavior:</p> <pre><code># ------------- environment -------------\nENVIRONMENT=\"local\"  # local, staging, or production\n</code></pre> <p>Environment Types:</p> <ul> <li>local: Full API docs available publicly at <code>/docs</code></li> <li>staging: API docs available to superusers only</li> <li>production: API docs completely disabled</li> </ul>"},{"location":"user-guide/configuration/environment-variables/#docker-compose-configuration","title":"Docker Compose Configuration","text":""},{"location":"user-guide/configuration/environment-variables/#basic-setup","title":"Basic Setup","text":"<p>Docker Compose automatically loads the <code>.env</code> file:</p> <pre><code># In docker-compose.yml\nservices:\n  web:\n    env_file:\n      - ./src/.env\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#development-overrides","title":"Development Overrides","text":"<p>Create <code>docker-compose.override.yml</code> for local customizations:</p> <pre><code>version: '3.8'\nservices:\n  web:\n    ports:\n      - \"8001:8000\"  # Use different port\n    environment:\n      - DEBUG=true\n    volumes:\n      - ./custom-logs:/code/logs\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#service-configuration","title":"Service Configuration","text":"<p>Understanding each Docker service:</p> <pre><code>services:\n  web:          # FastAPI application\n  db:           # PostgreSQL database\n  redis:        # Redis for caching/queues\n  worker:       # ARQ background task worker\n  nginx:        # Reverse proxy (optional)\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#python-settings-classes","title":"Python Settings Classes","text":"<p>Advanced configuration is handled in <code>src/app/core/config.py</code>:</p>"},{"location":"user-guide/configuration/environment-variables/#settings-composition","title":"Settings Composition","text":"<p>The main <code>Settings</code> class inherits from multiple setting groups:</p> <pre><code>class Settings(\n    AppSettings,\n    PostgresSettings, \n    CryptSettings,\n    FirstUserSettings,\n    RedisCacheSettings,\n    ClientSideCacheSettings,\n    RedisQueueSettings,\n    RedisRateLimiterSettings,\n    DefaultRateLimitSettings,\n    EnvironmentSettings,\n):\n    pass\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#adding-custom-settings","title":"Adding Custom Settings","text":"<p>Create your own settings group:</p> <pre><code>class CustomSettings(BaseSettings):\n    CUSTOM_API_KEY: str = \"\"\n    CUSTOM_TIMEOUT: int = 30\n    ENABLE_FEATURE_X: bool = False\n\n# Add to main Settings class\nclass Settings(\n    AppSettings,\n    # ... other settings ...\n    CustomSettings,\n):\n    pass\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#opting-out-of-services","title":"Opting Out of Services","text":"<p>Remove unused services by excluding their settings:</p> <pre><code># Minimal setup without Redis services\nclass Settings(\n    AppSettings,\n    PostgresSettings,\n    CryptSettings,\n    FirstUserSettings,\n    # Removed: RedisCacheSettings\n    # Removed: RedisQueueSettings  \n    # Removed: RedisRateLimiterSettings\n    EnvironmentSettings,\n):\n    pass\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#database-configuration_1","title":"Database Configuration","text":""},{"location":"user-guide/configuration/environment-variables/#alembic-configuration","title":"Alembic Configuration","text":"<p>Database migrations are configured in <code>src/alembic.ini</code>:</p> <pre><code>[alembic]\nscript_location = migrations\nsqlalchemy.url = postgresql://%(POSTGRES_USER)s:%(POSTGRES_PASSWORD)s@%(POSTGRES_SERVER)s:%(POSTGRES_PORT)s/%(POSTGRES_DB)s\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#connection-pooling","title":"Connection Pooling","text":"<p>SQLAlchemy connection pool settings in <code>src/app/core/db/database.py</code>:</p> <pre><code>engine = create_async_engine(\n    DATABASE_URL,\n    pool_size=20,          # Number of connections to maintain\n    max_overflow=30,       # Additional connections allowed\n    pool_timeout=30,       # Seconds to wait for connection\n    pool_recycle=1800,     # Seconds before connection refresh\n)\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#database-best-practices","title":"Database Best Practices","text":"<p>Connection Pool Sizing: - Start with <code>pool_size=20</code>, <code>max_overflow=30</code> - Monitor connection usage and adjust based on load - Use connection pooling monitoring tools</p> <p>Migration Strategy: - Always backup database before running migrations - Test migrations on staging environment first - Use <code>alembic revision --autogenerate</code> for model changes</p>"},{"location":"user-guide/configuration/environment-variables/#security-configuration","title":"Security Configuration","text":""},{"location":"user-guide/configuration/environment-variables/#jwt-token-configuration","title":"JWT Token Configuration","text":"<p>Customize JWT behavior in <code>src/app/core/security.py</code>:</p> <pre><code>def create_access_token(data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(\n            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n        )\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#cors-configuration","title":"CORS Configuration","text":"<p>Configure Cross-Origin Resource Sharing in <code>src/app/main.py</code>:</p> <pre><code>app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\"],  # Specify allowed origins\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\"],           # Specify allowed methods\n    allow_headers=[\"*\"],\n)\n</code></pre> <p>Production CORS Settings:</p> <pre><code># Never use wildcard (*) in production\nallow_origins=[\n    \"https://yourapp.com\",\n    \"https://www.yourapp.com\"\n],\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#security-headers","title":"Security Headers","text":"<p>Add security headers middleware:</p> <pre><code>from starlette.middleware.base import BaseHTTPMiddleware\n\nclass SecurityHeadersMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        response = await call_next(request)\n        response.headers[\"X-Frame-Options\"] = \"DENY\"\n        response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n        response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n        return response\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#logging-configuration","title":"Logging Configuration","text":""},{"location":"user-guide/configuration/environment-variables/#basic-logging-setup","title":"Basic Logging Setup","text":"<p>Configure logging in <code>src/app/core/logger.py</code>:</p> <pre><code>import logging\nfrom logging.handlers import RotatingFileHandler\n\n# Set log level\nLOGGING_LEVEL = logging.INFO\n\n# Configure file rotation\nfile_handler = RotatingFileHandler(\n    'logs/app.log', \n    maxBytes=10485760,  # 10MB\n    backupCount=5       # Keep 5 backup files\n)\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#structured-logging","title":"Structured Logging","text":"<p>Use structured logging for better observability:</p> <pre><code>import structlog\n\nstructlog.configure(\n    processors=[\n        structlog.stdlib.filter_by_level,\n        structlog.stdlib.add_logger_name,\n        structlog.stdlib.add_log_level,\n        structlog.processors.JSONRenderer()\n    ],\n    logger_factory=structlog.stdlib.LoggerFactory(),\n)\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#log-levels-by-environment","title":"Log Levels by Environment","text":"<pre><code># Environment-specific log levels\nLOG_LEVELS = {\n    \"local\": logging.DEBUG,\n    \"staging\": logging.INFO,\n    \"production\": logging.WARNING\n}\n\nLOGGING_LEVEL = LOG_LEVELS.get(settings.ENVIRONMENT, logging.INFO)\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#environment-specific-configurations","title":"Environment-Specific Configurations","text":""},{"location":"user-guide/configuration/environment-variables/#development-envdevelopment","title":"Development (.env.development)","text":"<pre><code>ENVIRONMENT=\"local\"\nPOSTGRES_SERVER=\"localhost\"\nREDIS_CACHE_HOST=\"localhost\"\nSECRET_KEY=\"dev-secret-key-not-for-production\"\nACCESS_TOKEN_EXPIRE_MINUTES=60  # Longer for development\nDEBUG=true\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#staging-envstaging","title":"Staging (.env.staging)","text":"<pre><code>ENVIRONMENT=\"staging\"\nPOSTGRES_SERVER=\"staging-db.example.com\"\nREDIS_CACHE_HOST=\"staging-redis.example.com\"\nSECRET_KEY=\"staging-secret-key-different-from-prod\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\nDEBUG=false\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#production-envproduction","title":"Production (.env.production)","text":"<pre><code>ENVIRONMENT=\"production\"\nPOSTGRES_SERVER=\"prod-db.example.com\"\nREDIS_CACHE_HOST=\"prod-redis.example.com\"\nSECRET_KEY=\"ultra-secure-production-key-generated-with-openssl\"\nACCESS_TOKEN_EXPIRE_MINUTES=15\nDEBUG=false\nREDIS_CACHE_PORT=6380  # Custom port for security\nPOSTGRES_PORT=5433     # Custom port for security\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"user-guide/configuration/environment-variables/#custom-middleware","title":"Custom Middleware","text":"<p>Add custom middleware in <code>src/app/core/setup.py</code>:</p> <pre><code>def create_application(router, settings, **kwargs):\n    app = FastAPI(...)\n\n    # Add custom middleware\n    app.add_middleware(CustomMiddleware, setting=value)\n    app.add_middleware(TimingMiddleware)\n    app.add_middleware(RequestIDMiddleware)\n\n    return app\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#feature-toggles","title":"Feature Toggles","text":"<p>Implement feature flags:</p> <pre><code>class FeatureSettings(BaseSettings):\n    ENABLE_ADVANCED_CACHING: bool = False\n    ENABLE_ANALYTICS: bool = True  \n    ENABLE_EXPERIMENTAL_FEATURES: bool = False\n    ENABLE_API_VERSIONING: bool = True\n\n# Use in endpoints\nif settings.ENABLE_ADVANCED_CACHING:\n    # Advanced caching logic\n    pass\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#health-checks","title":"Health Checks","text":"<p>Configure health check endpoints:</p> <pre><code>@app.get(\"/health\")\nasync def health_check():\n    return {\n        \"status\": \"healthy\",\n        \"database\": await check_database_health(),\n        \"redis\": await check_redis_health(),\n        \"version\": settings.APP_VERSION\n    }\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#configuration-validation","title":"Configuration Validation","text":""},{"location":"user-guide/configuration/environment-variables/#environment-validation","title":"Environment Validation","text":"<p>Add validation to prevent misconfiguration:</p> <pre><code>def validate_settings():\n    if not settings.SECRET_KEY:\n        raise ValueError(\"SECRET_KEY must be set\")\n\n    if settings.ENVIRONMENT == \"production\":\n        if settings.SECRET_KEY == \"dev-secret-key\":\n            raise ValueError(\"Production must use secure SECRET_KEY\")\n\n        if settings.DEBUG:\n            raise ValueError(\"DEBUG must be False in production\")\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#runtime-checks","title":"Runtime Checks","text":"<p>Add validation to application startup:</p> <pre><code>@app.on_event(\"startup\")\nasync def startup_event():\n    validate_settings()\n    await check_database_connection()\n    await check_redis_connection()\n    logger.info(f\"Application started in {settings.ENVIRONMENT} mode\")\n</code></pre>"},{"location":"user-guide/configuration/environment-variables/#configuration-troubleshooting","title":"Configuration Troubleshooting","text":""},{"location":"user-guide/configuration/environment-variables/#common-issues","title":"Common Issues","text":"<p>Environment Variables Not Loading: <pre><code># Check file location and permissions\nls -la src/.env\n\n# Check file format (no spaces around =)\ncat src/.env | grep \"=\" | head -5\n\n# Verify environment loading in Python\npython -c \"from src.app.core.config import settings; print(settings.APP_NAME)\"\n</code></pre></p> <p>Database Connection Failed: <pre><code># Test connection manually\npsql -h localhost -U postgres -d myapp\n\n# Check if PostgreSQL is running\nsystemctl status postgresql\n# or on macOS\nbrew services list | grep postgresql\n</code></pre></p> <p>Redis Connection Failed: <pre><code># Test Redis connection\nredis-cli -h localhost -p 6379 ping\n\n# Check Redis status\nsystemctl status redis\n# or on macOS  \nbrew services list | grep redis\n</code></pre></p>"},{"location":"user-guide/configuration/environment-variables/#configuration-testing","title":"Configuration Testing","text":"<p>Test your configuration with a simple script:</p> <pre><code># test_config.py\nimport asyncio\nfrom src.app.core.config import settings\nfrom src.app.core.db.database import async_get_db\n\nasync def test_config():\n    print(f\"App: {settings.APP_NAME}\")\n    print(f\"Environment: {settings.ENVIRONMENT}\")\n\n    # Test database\n    try:\n        db = await anext(async_get_db())\n        print(\"\u2713 Database connection successful\")\n        await db.close()\n    except Exception as e:\n        print(f\"\u2717 Database connection failed: {e}\")\n\n    # Test Redis (if enabled)\n    try:\n        from src.app.core.utils.cache import redis_client\n        await redis_client.ping()\n        print(\"\u2713 Redis connection successful\")\n    except Exception as e:\n        print(f\"\u2717 Redis connection failed: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(test_config())\n</code></pre> <p>Run with: <pre><code>uv run python test_config.py\n</code></pre></p>"},{"location":"user-guide/configuration/settings-classes/","title":"Settings Classes","text":"<p>Learn how Python settings classes validate, structure, and organize your application configuration. The boilerplate uses Pydantic's <code>BaseSettings</code> for type-safe configuration management.</p>"},{"location":"user-guide/configuration/settings-classes/#settings-architecture","title":"Settings Architecture","text":"<p>The main <code>Settings</code> class inherits from multiple specialized setting groups:</p> <pre><code># src/app/core/config.py\nclass Settings(\n    AppSettings,\n    PostgresSettings, \n    CryptSettings,\n    FirstUserSettings,\n    RedisCacheSettings,\n    ClientSideCacheSettings,\n    RedisQueueSettings,\n    RedisRateLimiterSettings,\n    DefaultRateLimitSettings,\n    EnvironmentSettings,\n):\n    pass\n\n# Single instance used throughout the app\nsettings = Settings()\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#built-in-settings-groups","title":"Built-in Settings Groups","text":""},{"location":"user-guide/configuration/settings-classes/#application-settings","title":"Application Settings","text":"<p>Basic app metadata and configuration:</p> <pre><code>class AppSettings(BaseSettings):\n    APP_NAME: str = \"FastAPI\"\n    APP_DESCRIPTION: str = \"A FastAPI project\"\n    APP_VERSION: str = \"0.1.0\"\n    CONTACT_NAME: str = \"Your Name\"\n    CONTACT_EMAIL: str = \"your.email@example.com\"\n    LICENSE_NAME: str = \"MIT\"\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#database-settings","title":"Database Settings","text":"<p>PostgreSQL connection configuration:</p> <pre><code>class PostgresSettings(BaseSettings):\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str\n    POSTGRES_SERVER: str = \"localhost\"\n    POSTGRES_PORT: int = 5432\n    POSTGRES_DB: str\n\n    @computed_field\n    @property\n    def DATABASE_URL(self) -&gt; str:\n        return (\n            f\"postgresql+asyncpg://{self.POSTGRES_USER}:\"\n            f\"{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}:\"\n            f\"{self.POSTGRES_PORT}/{self.POSTGRES_DB}\"\n        )\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#security-settings","title":"Security Settings","text":"<p>JWT and authentication configuration:</p> <pre><code>class CryptSettings(BaseSettings):\n    SECRET_KEY: str\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    REFRESH_TOKEN_EXPIRE_DAYS: int = 7\n\n    @field_validator(\"SECRET_KEY\")\n    @classmethod\n    def validate_secret_key(cls, v: str) -&gt; str:\n        if len(v) &lt; 32:\n            raise ValueError(\"SECRET_KEY must be at least 32 characters\")\n        return v\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#redis-settings","title":"Redis Settings","text":"<p>Separate Redis instances for different services:</p> <pre><code>class RedisCacheSettings(BaseSettings):\n    REDIS_CACHE_HOST: str = \"localhost\"\n    REDIS_CACHE_PORT: int = 6379\n\nclass RedisQueueSettings(BaseSettings):\n    REDIS_QUEUE_HOST: str = \"localhost\"\n    REDIS_QUEUE_PORT: int = 6379\n\nclass RedisRateLimiterSettings(BaseSettings):\n    REDIS_RATE_LIMIT_HOST: str = \"localhost\"\n    REDIS_RATE_LIMIT_PORT: int = 6379\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#rate-limiting-settings","title":"Rate Limiting Settings","text":"<p>Default rate limiting configuration:</p> <pre><code>class DefaultRateLimitSettings(BaseSettings):\n    DEFAULT_RATE_LIMIT_LIMIT: int = 10\n    DEFAULT_RATE_LIMIT_PERIOD: int = 3600  # 1 hour\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#admin-user-settings","title":"Admin User Settings","text":"<p>First superuser account creation:</p> <pre><code>class FirstUserSettings(BaseSettings):\n    ADMIN_NAME: str = \"Admin\"\n    ADMIN_EMAIL: str\n    ADMIN_USERNAME: str = \"admin\"\n    ADMIN_PASSWORD: str\n\n    @field_validator(\"ADMIN_EMAIL\")\n    @classmethod\n    def validate_admin_email(cls, v: str) -&gt; str:\n        if \"@\" not in v:\n            raise ValueError(\"ADMIN_EMAIL must be a valid email\")\n        return v\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#creating-custom-settings","title":"Creating Custom Settings","text":""},{"location":"user-guide/configuration/settings-classes/#basic-custom-settings","title":"Basic Custom Settings","text":"<p>Add your own settings group:</p> <pre><code>class CustomSettings(BaseSettings):\n    CUSTOM_API_KEY: str = \"\"\n    CUSTOM_TIMEOUT: int = 30\n    ENABLE_FEATURE_X: bool = False\n    MAX_UPLOAD_SIZE: int = 10485760  # 10MB\n\n    @field_validator(\"MAX_UPLOAD_SIZE\")\n    @classmethod\n    def validate_upload_size(cls, v: int) -&gt; int:\n        if v &lt; 1024:  # 1KB minimum\n            raise ValueError(\"MAX_UPLOAD_SIZE must be at least 1KB\")\n        if v &gt; 104857600:  # 100MB maximum\n            raise ValueError(\"MAX_UPLOAD_SIZE cannot exceed 100MB\")\n        return v\n\n# Add to main Settings class\nclass Settings(\n    AppSettings,\n    PostgresSettings,\n    # ... other settings ...\n    CustomSettings,  # Add your custom settings\n):\n    pass\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#advanced-custom-settings","title":"Advanced Custom Settings","text":"<p>Settings with complex validation and computed fields:</p> <pre><code>class EmailSettings(BaseSettings):\n    SMTP_HOST: str = \"\"\n    SMTP_PORT: int = 587\n    SMTP_USERNAME: str = \"\"\n    SMTP_PASSWORD: str = \"\"\n    SMTP_USE_TLS: bool = True\n    EMAIL_FROM: str = \"\"\n    EMAIL_FROM_NAME: str = \"\"\n\n    @computed_field\n    @property\n    def EMAIL_ENABLED(self) -&gt; bool:\n        return bool(self.SMTP_HOST and self.SMTP_USERNAME)\n\n    @model_validator(mode=\"after\")\n    def validate_email_config(self) -&gt; \"EmailSettings\":\n        if self.SMTP_HOST and not self.EMAIL_FROM:\n            raise ValueError(\"EMAIL_FROM required when SMTP_HOST is set\")\n        if self.SMTP_USERNAME and not self.SMTP_PASSWORD:\n            raise ValueError(\"SMTP_PASSWORD required when SMTP_USERNAME is set\")\n        return self\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#feature-flag-settings","title":"Feature Flag Settings","text":"<p>Organize feature toggles:</p> <pre><code>class FeatureSettings(BaseSettings):\n    # Core features\n    ENABLE_CACHING: bool = True\n    ENABLE_RATE_LIMITING: bool = True\n    ENABLE_BACKGROUND_JOBS: bool = True\n\n    # Optional features\n    ENABLE_ANALYTICS: bool = False\n    ENABLE_EMAIL_NOTIFICATIONS: bool = False\n    ENABLE_FILE_UPLOADS: bool = False\n\n    # Experimental features\n    ENABLE_EXPERIMENTAL_API: bool = False\n    ENABLE_BETA_FEATURES: bool = False\n\n    @model_validator(mode=\"after\")\n    def validate_feature_dependencies(self) -&gt; \"FeatureSettings\":\n        if self.ENABLE_EMAIL_NOTIFICATIONS and not self.ENABLE_BACKGROUND_JOBS:\n            raise ValueError(\"Email notifications require background jobs\")\n        return self\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#settings-validation","title":"Settings Validation","text":""},{"location":"user-guide/configuration/settings-classes/#field-validation","title":"Field Validation","text":"<p>Validate individual fields:</p> <pre><code>class DatabaseSettings(BaseSettings):\n    DB_POOL_SIZE: int = 20\n    DB_MAX_OVERFLOW: int = 30\n    DB_TIMEOUT: int = 30\n\n    @field_validator(\"DB_POOL_SIZE\")\n    @classmethod\n    def validate_pool_size(cls, v: int) -&gt; int:\n        if v &lt; 1:\n            raise ValueError(\"Pool size must be at least 1\")\n        if v &gt; 100:\n            raise ValueError(\"Pool size should not exceed 100\")\n        return v\n\n    @field_validator(\"DB_TIMEOUT\")\n    @classmethod\n    def validate_timeout(cls, v: int) -&gt; int:\n        if v &lt; 5:\n            raise ValueError(\"Timeout must be at least 5 seconds\")\n        return v\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#model-validation","title":"Model Validation","text":"<p>Validate across multiple fields:</p> <pre><code>class SecuritySettings(BaseSettings):\n    ENABLE_HTTPS: bool = False\n    SSL_CERT_PATH: str = \"\"\n    SSL_KEY_PATH: str = \"\"\n    FORCE_SSL: bool = False\n\n    @model_validator(mode=\"after\")\n    def validate_ssl_config(self) -&gt; \"SecuritySettings\":\n        if self.ENABLE_HTTPS:\n            if not self.SSL_CERT_PATH:\n                raise ValueError(\"SSL_CERT_PATH required when HTTPS enabled\")\n            if not self.SSL_KEY_PATH:\n                raise ValueError(\"SSL_KEY_PATH required when HTTPS enabled\")\n\n        if self.FORCE_SSL and not self.ENABLE_HTTPS:\n            raise ValueError(\"Cannot force SSL without enabling HTTPS\")\n\n        return self\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#environment-specific-validation","title":"Environment-Specific Validation","text":"<p>Different validation rules per environment:</p> <pre><code>class EnvironmentSettings(BaseSettings):\n    ENVIRONMENT: str = \"local\"\n    DEBUG: bool = True\n\n    @model_validator(mode=\"after\")\n    def validate_environment_config(self) -&gt; \"EnvironmentSettings\":\n        if self.ENVIRONMENT == \"production\":\n            if self.DEBUG:\n                raise ValueError(\"DEBUG must be False in production\")\n\n        if self.ENVIRONMENT not in [\"local\", \"staging\", \"production\"]:\n            raise ValueError(\"ENVIRONMENT must be local, staging, or production\")\n\n        return self\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#computed-properties","title":"Computed Properties","text":""},{"location":"user-guide/configuration/settings-classes/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Create computed values from other settings:</p> <pre><code>class StorageSettings(BaseSettings):\n    STORAGE_TYPE: str = \"local\"  # local, s3, gcs\n\n    # Local storage\n    LOCAL_STORAGE_PATH: str = \"./uploads\"\n\n    # S3 settings\n    AWS_ACCESS_KEY_ID: str = \"\"\n    AWS_SECRET_ACCESS_KEY: str = \"\"\n    AWS_BUCKET_NAME: str = \"\"\n    AWS_REGION: str = \"us-east-1\"\n\n    @computed_field\n    @property\n    def STORAGE_ENABLED(self) -&gt; bool:\n        if self.STORAGE_TYPE == \"local\":\n            return bool(self.LOCAL_STORAGE_PATH)\n        elif self.STORAGE_TYPE == \"s3\":\n            return bool(self.AWS_ACCESS_KEY_ID and self.AWS_SECRET_ACCESS_KEY and self.AWS_BUCKET_NAME)\n        return False\n\n    @computed_field\n    @property\n    def STORAGE_CONFIG(self) -&gt; dict:\n        if self.STORAGE_TYPE == \"local\":\n            return {\"path\": self.LOCAL_STORAGE_PATH}\n        elif self.STORAGE_TYPE == \"s3\":\n            return {\n                \"bucket\": self.AWS_BUCKET_NAME,\n                \"region\": self.AWS_REGION,\n                \"credentials\": {\n                    \"access_key\": self.AWS_ACCESS_KEY_ID,\n                    \"secret_key\": self.AWS_SECRET_ACCESS_KEY,\n                }\n            }\n        return {}\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#organizing-settings","title":"Organizing Settings","text":""},{"location":"user-guide/configuration/settings-classes/#service-based-organization","title":"Service-Based Organization","text":"<p>Group settings by service or domain:</p> <pre><code># Authentication service settings\nclass AuthSettings(BaseSettings):\n    JWT_SECRET_KEY: str\n    JWT_ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE: int = 30\n    REFRESH_TOKEN_EXPIRE: int = 7200\n    PASSWORD_MIN_LENGTH: int = 8\n\n# Notification service settings  \nclass NotificationSettings(BaseSettings):\n    EMAIL_ENABLED: bool = False\n    SMS_ENABLED: bool = False\n    PUSH_ENABLED: bool = False\n\n    # Email settings\n    SMTP_HOST: str = \"\"\n    SMTP_PORT: int = 587\n\n    # SMS settings (example with Twilio)\n    TWILIO_ACCOUNT_SID: str = \"\"\n    TWILIO_AUTH_TOKEN: str = \"\"\n\n# Main settings\nclass Settings(\n    AppSettings,\n    AuthSettings,\n    NotificationSettings,\n    # ... other settings\n):\n    pass\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#conditional-settings-loading","title":"Conditional Settings Loading","text":"<p>Load different settings based on environment:</p> <pre><code>class BaseAppSettings(BaseSettings):\n    APP_NAME: str = \"FastAPI App\"\n    DEBUG: bool = False\n\nclass DevelopmentSettings(BaseAppSettings):\n    DEBUG: bool = True\n    LOG_LEVEL: str = \"DEBUG\"\n    DATABASE_ECHO: bool = True\n\nclass ProductionSettings(BaseAppSettings):\n    DEBUG: bool = False\n    LOG_LEVEL: str = \"WARNING\"\n    DATABASE_ECHO: bool = False\n\ndef get_settings() -&gt; BaseAppSettings:\n    environment = os.getenv(\"ENVIRONMENT\", \"local\")\n\n    if environment == \"production\":\n        return ProductionSettings()\n    else:\n        return DevelopmentSettings()\n\nsettings = get_settings()\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#removing-unused-services","title":"Removing Unused Services","text":""},{"location":"user-guide/configuration/settings-classes/#minimal-configuration","title":"Minimal Configuration","text":"<p>Remove services you don't need:</p> <pre><code># Minimal setup without Redis services\nclass MinimalSettings(\n    AppSettings,\n    PostgresSettings,\n    CryptSettings,\n    FirstUserSettings,\n    # Removed: RedisCacheSettings\n    # Removed: RedisQueueSettings  \n    # Removed: RedisRateLimiterSettings\n    EnvironmentSettings,\n):\n    pass\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#service-feature-flags","title":"Service Feature Flags","text":"<p>Use feature flags to conditionally enable services:</p> <pre><code>class ServiceSettings(BaseSettings):\n    ENABLE_REDIS: bool = True\n    ENABLE_CELERY: bool = True\n    ENABLE_MONITORING: bool = False\n\nclass ConditionalSettings(\n    AppSettings,\n    PostgresSettings,\n    CryptSettings,\n    ServiceSettings,\n):\n    # Add Redis settings only if enabled\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        if self.ENABLE_REDIS:\n            # Dynamically add Redis settings\n            self.__class__ = type(\n                \"ConditionalSettings\",\n                (self.__class__, RedisCacheSettings),\n                {}\n            )\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#testing-settings","title":"Testing Settings","text":""},{"location":"user-guide/configuration/settings-classes/#test-configuration","title":"Test Configuration","text":"<p>Create separate settings for testing:</p> <pre><code>class TestSettings(BaseSettings):\n    # Override database for testing\n    POSTGRES_DB: str = \"test_database\"\n\n    # Disable external services\n    ENABLE_REDIS: bool = False\n    ENABLE_EMAIL: bool = False\n\n    # Speed up tests\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 5\n\n    # Test-specific settings\n    TEST_USER_EMAIL: str = \"test@example.com\"\n    TEST_USER_PASSWORD: str = \"testpassword123\"\n\n# Use in tests\n@pytest.fixture\ndef test_settings():\n    return TestSettings()\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#settings-validation-testing","title":"Settings Validation Testing","text":"<p>Test your custom settings:</p> <pre><code>def test_custom_settings_validation():\n    # Test valid configuration\n    settings = CustomSettings(\n        CUSTOM_API_KEY=\"test-key\",\n        CUSTOM_TIMEOUT=60,\n        MAX_UPLOAD_SIZE=5242880  # 5MB\n    )\n    assert settings.CUSTOM_TIMEOUT == 60\n\n    # Test validation error\n    with pytest.raises(ValueError, match=\"MAX_UPLOAD_SIZE cannot exceed 100MB\"):\n        CustomSettings(MAX_UPLOAD_SIZE=209715200)  # 200MB\n\ndef test_settings_computed_fields():\n    settings = StorageSettings(\n        STORAGE_TYPE=\"s3\",\n        AWS_ACCESS_KEY_ID=\"test-key\",\n        AWS_SECRET_ACCESS_KEY=\"test-secret\",\n        AWS_BUCKET_NAME=\"test-bucket\"\n    )\n\n    assert settings.STORAGE_ENABLED is True\n    assert settings.STORAGE_CONFIG[\"bucket\"] == \"test-bucket\"\n</code></pre>"},{"location":"user-guide/configuration/settings-classes/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/settings-classes/#organization","title":"Organization","text":"<ul> <li>Group related settings in dedicated classes</li> <li>Use descriptive names for settings groups</li> <li>Keep validation logic close to the settings</li> <li>Document complex validation rules</li> </ul>"},{"location":"user-guide/configuration/settings-classes/#security","title":"Security","text":"<ul> <li>Validate sensitive settings like secret keys</li> <li>Never set default values for secrets in production</li> <li>Use computed fields to derive connection strings</li> <li>Separate test and production configurations</li> </ul>"},{"location":"user-guide/configuration/settings-classes/#performance","title":"Performance","text":"<ul> <li>Use <code>@computed_field</code> for expensive calculations</li> <li>Cache settings instances appropriately</li> <li>Avoid complex validation in hot paths</li> <li>Use model validators for cross-field validation</li> </ul>"},{"location":"user-guide/configuration/settings-classes/#testing","title":"Testing","text":"<ul> <li>Create separate test settings classes</li> <li>Test all validation rules</li> <li>Mock external service settings in tests</li> <li>Use dependency injection for settings in tests</li> </ul> <p>The settings system provides type safety, validation, and organization for your application configuration. Start with the built-in settings and extend them as your application grows! </p>"},{"location":"user-guide/database/","title":"Database Layer","text":"<p>Learn how to work with the database layer in the FastAPI Boilerplate. This section covers everything you need to store and retrieve data effectively.</p>"},{"location":"user-guide/database/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Models - Define database tables with SQLAlchemy models</li> <li>Schemas - Validate and serialize data with Pydantic schemas  </li> <li>CRUD Operations - Perform database operations with FastCRUD</li> <li>Migrations - Manage database schema changes with Alembic</li> </ul>"},{"location":"user-guide/database/#quick-overview","title":"Quick Overview","text":"<p>The boilerplate uses a layered architecture that separates concerns:</p> <pre><code># API Endpoint\n@router.post(\"/\", response_model=UserRead)\nasync def create_user(user_data: UserCreate, db: AsyncSession):\n    return await crud_users.create(db=db, object=user_data)\n\n# The layers work together:\n# 1. UserCreate schema validates the input\n# 2. crud_users handles the database operation  \n# 3. User model defines the database table\n# 4. UserRead schema formats the response\n</code></pre>"},{"location":"user-guide/database/#architecture","title":"Architecture","text":"<p>The database layer follows a clear separation:</p> <pre><code>API Request\n    \u2193\nPydantic Schema (validation &amp; serialization)\n    \u2193\nCRUD Layer (business logic &amp; database operations)\n    \u2193\nSQLAlchemy Model (database table definition)\n    \u2193\nPostgreSQL Database\n</code></pre>"},{"location":"user-guide/database/#key-features","title":"Key Features","text":""},{"location":"user-guide/database/#sqlalchemy-20-models","title":"\ud83d\uddc4\ufe0f SQLAlchemy 2.0 Models","text":"<p>Modern async SQLAlchemy with type hints: <pre><code>class User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    username: Mapped[str] = mapped_column(String(50), unique=True)\n    email: Mapped[str] = mapped_column(String(100), unique=True)\n    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)\n</code></pre></p>"},{"location":"user-guide/database/#pydantic-schemas","title":"\u2705 Pydantic Schemas","text":"<p>Automatic validation and serialization: <pre><code>class UserCreate(BaseModel):\n    username: str = Field(min_length=2, max_length=50)\n    email: EmailStr\n    password: str = Field(min_length=8)\n\nclass UserRead(BaseModel):\n    id: int\n    username: str\n    email: str\n    created_at: datetime\n    # Note: no password field in read schema\n</code></pre></p>"},{"location":"user-guide/database/#fastcrud-operations","title":"\ud83d\udd27 FastCRUD Operations","text":"<p>Consistent database operations: <pre><code># Create\nuser = await crud_users.create(db=db, object=user_create)\n\n# Read\nuser = await crud_users.get(db=db, id=user_id)\nusers = await crud_users.get_multi(db=db, offset=0, limit=10)\n\n# Update  \nuser = await crud_users.update(db=db, object=user_update, id=user_id)\n\n# Delete (soft delete)\nawait crud_users.delete(db=db, id=user_id)\n</code></pre></p>"},{"location":"user-guide/database/#database-migrations","title":"\ud83d\udd04 Database Migrations","text":"<p>Track schema changes with Alembic: <pre><code># Generate migration\nalembic revision --autogenerate -m \"Add user table\"\n\n# Apply migrations\nalembic upgrade head\n\n# Rollback if needed\nalembic downgrade -1\n</code></pre></p>"},{"location":"user-guide/database/#database-setup","title":"Database Setup","text":"<p>The boilerplate is configured for PostgreSQL with async support:</p>"},{"location":"user-guide/database/#environment-configuration","title":"Environment Configuration","text":"<pre><code># .env file\nPOSTGRES_USER=your_user\nPOSTGRES_PASSWORD=your_password\nPOSTGRES_SERVER=localhost\nPOSTGRES_PORT=5432\nPOSTGRES_DB=your_database\n</code></pre>"},{"location":"user-guide/database/#connection-management","title":"Connection Management","text":"<pre><code># Database session dependency\nasync def async_get_db() -&gt; AsyncIterator[AsyncSession]:\n    async with async_session_maker() as session:\n        yield session\n\n# Use in endpoints\n@router.get(\"/users/\")\nasync def get_users(db: Annotated[AsyncSession, Depends(async_get_db)]):\n    return await crud_users.get_multi(db=db)\n</code></pre>"},{"location":"user-guide/database/#included-models","title":"Included Models","text":"<p>The boilerplate includes four example models:</p>"},{"location":"user-guide/database/#user-model-authentication-user-management","title":"User Model - Authentication &amp; user management","text":"<ul> <li>Username, email, password (hashed)</li> <li>Soft delete support</li> <li>Tier-based access control</li> </ul>"},{"location":"user-guide/database/#post-model-content-with-user-relationships","title":"Post Model - Content with user relationships","text":"<ul> <li>Title, content, creation metadata</li> <li>Foreign key to user (no SQLAlchemy relationships)</li> <li>Soft delete built-in</li> </ul>"},{"location":"user-guide/database/#tier-model-user-subscription-levels","title":"Tier Model - User subscription levels","text":"<ul> <li>Name-based tiers (free, premium, etc.)</li> <li>Links to rate limiting system</li> </ul>"},{"location":"user-guide/database/#rate-limit-model-api-access-control","title":"Rate Limit Model - API access control","text":"<ul> <li>Path-specific rate limits per tier</li> <li>Configurable limits and time periods</li> </ul>"},{"location":"user-guide/database/#directory-structure","title":"Directory Structure","text":"<pre><code>src/app/\n\u251c\u2500\u2500 models/                 # SQLAlchemy models (database tables)\n\u2502   \u251c\u2500\u2500 __init__.py        \n\u2502   \u251c\u2500\u2500 user.py           # User table definition\n\u2502   \u251c\u2500\u2500 post.py           # Post table definition\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 schemas/                # Pydantic schemas (validation)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 user.py           # User validation schemas\n\u2502   \u251c\u2500\u2500 post.py           # Post validation schemas  \n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 crud/                   # Database operations\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 crud_users.py     # User CRUD operations\n\u2502   \u251c\u2500\u2500 crud_posts.py     # Post CRUD operations\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 core/db/               # Database configuration\n    \u251c\u2500\u2500 database.py       # Connection and session setup\n    \u2514\u2500\u2500 models.py         # Base classes and mixins\n</code></pre>"},{"location":"user-guide/database/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/database/#create-with-validation","title":"Create with Validation","text":"<pre><code>@router.post(\"/users/\", response_model=UserRead)\nasync def create_user(\n    user_data: UserCreate,  # Validates input automatically\n    db: Annotated[AsyncSession, Depends(async_get_db)]\n):\n    # Check for duplicates\n    if await crud_users.exists(db=db, email=user_data.email):\n        raise DuplicateValueException(\"Email already exists\")\n\n    # Create user (password gets hashed automatically)\n    return await crud_users.create(db=db, object=user_data)\n</code></pre>"},{"location":"user-guide/database/#query-with-filters","title":"Query with Filters","text":"<pre><code># Get active users only\nusers = await crud_users.get_multi(\n    db=db,\n    is_active=True,\n    is_deleted=False,\n    offset=0,\n    limit=10\n)\n\n# Search users\nusers = await crud_users.get_multi(\n    db=db,\n    username__icontains=\"john\",  # Contains \"john\"\n    schema_to_select=UserRead\n)\n</code></pre>"},{"location":"user-guide/database/#soft-delete-pattern","title":"Soft Delete Pattern","text":"<pre><code># Soft delete (sets is_deleted=True)\nawait crud_users.delete(db=db, id=user_id)\n\n# Hard delete (actually removes from database)\nawait crud_users.db_delete(db=db, id=user_id)\n\n# Get only non-deleted records\nusers = await crud_users.get_multi(db=db, is_deleted=False)\n</code></pre>"},{"location":"user-guide/database/#whats-next","title":"What's Next","text":"<p>Each guide builds on the previous one with practical examples:</p> <ol> <li>Models - Define your database structure</li> <li>Schemas - Add validation and serialization</li> <li>CRUD Operations - Implement business logic</li> <li>Migrations - Deploy changes safely</li> </ol> <p>The boilerplate provides a solid foundation - just follow these patterns to build your data layer!</p>"},{"location":"user-guide/database/crud/","title":"CRUD Operations","text":"<p>This guide covers all CRUD (Create, Read, Update, Delete) operations available in the FastAPI Boilerplate using FastCRUD, a powerful library that provides consistent and efficient database operations.</p>"},{"location":"user-guide/database/crud/#overview","title":"Overview","text":"<p>The boilerplate uses FastCRUD for all database operations. FastCRUD provides:</p> <ul> <li>Consistent API across all models</li> <li>Type safety with generic type parameters</li> <li>Automatic pagination support</li> <li>Advanced filtering and joining capabilities</li> <li>Soft delete support</li> <li>Optimized queries with selective field loading</li> </ul>"},{"location":"user-guide/database/crud/#crud-class-structure","title":"CRUD Class Structure","text":"<p>Each model has a corresponding CRUD class that defines the available operations:</p> <pre><code># src/app/crud/crud_users.py\nfrom fastcrud import FastCRUD\nfrom app.models.user import User\nfrom app.schemas.user import (\n    UserCreateInternal, UserUpdate, UserUpdateInternal, \n    UserDelete, UserRead\n)\n\nCRUDUser = FastCRUD[\n    User,                # Model class\n    UserCreateInternal,  # Create schema\n    UserUpdate,          # Update schema  \n    UserUpdateInternal,  # Internal update schema\n    UserDelete,          # Delete schema\n    UserRead             # Read schema\n]\ncrud_users = CRUDUser(User)\n</code></pre>"},{"location":"user-guide/database/crud/#read-operations","title":"Read Operations","text":""},{"location":"user-guide/database/crud/#get-single-record","title":"Get Single Record","text":"<p>Retrieve a single record by any field:</p> <pre><code># Get user by ID\nuser = await crud_users.get(db=db, id=user_id)\n\n# Get user by username\nuser = await crud_users.get(db=db, username=\"john_doe\")\n\n# Get user by email\nuser = await crud_users.get(db=db, email=\"john@example.com\")\n\n# Get with specific fields only\nuser = await crud_users.get(\n    db=db, \n    schema_to_select=UserRead, # Only select fields defined in UserRead\n    id=user_id,\n)\n</code></pre> <p>Real usage from the codebase:</p> <pre><code># From src/app/api/v1/users.py\ndb_user = await crud_users.get(\n    db=db, \n    schema_to_select=UserRead,\n    username=username, \n    is_deleted=False,\n)\n</code></pre>"},{"location":"user-guide/database/crud/#get-multiple-records","title":"Get Multiple Records","text":"<p>Retrieve multiple records with filtering and pagination:</p> <pre><code># Get all users\nusers = await crud_users.get_multi(db=db)\n\n# Get with pagination\nusers = await crud_users.get_multi(\n    db=db,\n    offset=0,      # Skip first 0 records\n    limit=10,      # Return maximum 10 records\n)\n\n# Get with filtering\nactive_users = await crud_users.get_multi(\n    db=db,\n    is_deleted=False,  # Filter condition\n    offset=compute_offset(page, items_per_page),\n    limit=items_per_page\n)\n</code></pre> <p>Pagination response structure:</p> <pre><code>{\n    \"data\": [\n        {\"id\": 1, \"username\": \"john\", \"email\": \"john@example.com\"},\n        {\"id\": 2, \"username\": \"jane\", \"email\": \"jane@example.com\"}\n    ],\n    \"total_count\": 25,\n    \"has_more\": true,\n    \"page\": 1,\n    \"items_per_page\": 10\n}\n</code></pre>"},{"location":"user-guide/database/crud/#check-existence","title":"Check Existence","text":"<p>Check if a record exists without fetching it:</p> <pre><code># Check if user exists\nuser_exists = await crud_users.exists(db=db, email=\"john@example.com\")\n# Returns True or False\n\n# Check if username is available\nusername_taken = await crud_users.exists(db=db, username=\"john_doe\")\n</code></pre> <p>Real usage example:</p> <pre><code># From src/app/api/v1/users.py - checking before creating\nemail_row = await crud_users.exists(db=db, email=user.email)\nif email_row:\n    raise DuplicateValueException(\"Email is already registered\")\n</code></pre>"},{"location":"user-guide/database/crud/#count-records","title":"Count Records","text":"<p>Get count of records matching criteria:</p> <pre><code># Count all users\ntotal_users = await crud_users.count(db=db)\n\n# Count active users\nactive_count = await crud_users.count(db=db, is_deleted=False)\n\n# Count by specific criteria\nadmin_count = await crud_users.count(db=db, is_superuser=True)\n</code></pre>"},{"location":"user-guide/database/crud/#create-operations","title":"Create Operations","text":""},{"location":"user-guide/database/crud/#basic-creation","title":"Basic Creation","text":"<p>Create new records using Pydantic schemas:</p> <pre><code># Create user\nuser_data = UserCreateInternal(\n    username=\"john_doe\",\n    email=\"john@example.com\", \n    hashed_password=\"hashed_password_here\"\n)\n\ncreated_user = await crud_users.create(db=db, object=user_data)\n</code></pre> <p>Real creation example:</p> <pre><code># From src/app/api/v1/users.py\nuser_internal_dict = user.model_dump()\nuser_internal_dict[\"hashed_password\"] = get_password_hash(password=user_internal_dict[\"password\"])\ndel user_internal_dict[\"password\"]\n\nuser_internal = UserCreateInternal(**user_internal_dict)\ncreated_user = await crud_users.create(db=db, object=user_internal)\n</code></pre>"},{"location":"user-guide/database/crud/#create-with-relationships","title":"Create with Relationships","text":"<p>When creating records with foreign keys:</p> <pre><code># Create post for a user\npost_data = PostCreateInternal(\n    title=\"My First Post\",\n    content=\"This is the content of my post\",\n    created_by_user_id=user.id  # Foreign key reference\n)\n\ncreated_post = await crud_posts.create(db=db, object=post_data)\n</code></pre>"},{"location":"user-guide/database/crud/#update-operations","title":"Update Operations","text":""},{"location":"user-guide/database/crud/#basic-updates","title":"Basic Updates","text":"<p>Update records by any field:</p> <pre><code># Update user by ID\nupdate_data = UserUpdate(email=\"newemail@example.com\")\nawait crud_users.update(db=db, object=update_data, id=user_id)\n\n# Update by username\nawait crud_users.update(db=db, object=update_data, username=\"john_doe\")\n\n# Update multiple fields\nupdate_data = UserUpdate(\n    email=\"newemail@example.com\",\n    profile_image_url=\"https://newimage.com/photo.jpg\"\n)\nawait crud_users.update(db=db, object=update_data, id=user_id)\n</code></pre>"},{"location":"user-guide/database/crud/#conditional-updates","title":"Conditional Updates","text":"<p>Update with validation:</p> <pre><code># From real endpoint - check before updating\nif values.username != db_user.username:\n    existing_username = await crud_users.exists(db=db, username=values.username)\n    if existing_username:\n        raise DuplicateValueException(\"Username not available\")\n\nawait crud_users.update(db=db, object=values, username=username)\n</code></pre>"},{"location":"user-guide/database/crud/#bulk-updates","title":"Bulk Updates","text":"<p>Update multiple records at once:</p> <pre><code># Update all users with specific criteria\nupdate_data = {\"is_active\": False}\nawait crud_users.update(db=db, object=update_data, is_deleted=True)\n</code></pre>"},{"location":"user-guide/database/crud/#delete-operations","title":"Delete Operations","text":""},{"location":"user-guide/database/crud/#soft-delete","title":"Soft Delete","text":"<p>For models with soft delete fields (like User, Post):</p> <pre><code># Soft delete - sets is_deleted=True, deleted_at=now()\nawait crud_users.delete(db=db, username=\"john_doe\")\n\n# The record stays in the database but is marked as deleted\nuser = await crud_users.get(db=db, username=\"john_doe\", is_deleted=True)\n</code></pre>"},{"location":"user-guide/database/crud/#hard-delete","title":"Hard Delete","text":"<p>Permanently remove records from the database:</p> <pre><code># Permanently delete from database\nawait crud_users.db_delete(db=db, username=\"john_doe\")\n\n# The record is completely removed\n</code></pre> <p>Real deletion example:</p> <pre><code># From src/app/api/v1/users.py\n# Regular users get soft delete\nawait crud_users.delete(db=db, username=username)\n\n# Superusers can hard delete\nawait crud_users.db_delete(db=db, username=username)\n</code></pre>"},{"location":"user-guide/database/crud/#advanced-operations","title":"Advanced Operations","text":""},{"location":"user-guide/database/crud/#joined-queries","title":"Joined Queries","text":"<p>Get data from multiple related tables:</p> <pre><code># Get posts with user information\nposts_with_users = await crud_posts.get_multi_joined(\n    db=db,\n    join_model=User,\n    join_on=Post.created_by_user_id == User.id,\n    schema_to_select=PostRead,\n    join_schema_to_select=UserRead,\n    join_prefix=\"user_\"\n)\n</code></pre> <p>Result structure: <pre><code>{\n    \"id\": 1,\n    \"title\": \"My Post\",\n    \"content\": \"Post content\",\n    \"user_id\": 123,\n    \"user_username\": \"john_doe\",\n    \"user_email\": \"john@example.com\"\n}\n</code></pre></p>"},{"location":"user-guide/database/crud/#custom-filtering","title":"Custom Filtering","text":"<p>Advanced filtering with SQLAlchemy expressions:</p> <pre><code>from sqlalchemy import and_, or_\n\n# Complex filters\nusers = await crud_users.get_multi(\n    db=db,\n    filter_criteria=[\n        and_(\n            User.is_deleted == False,\n            User.created_at &gt; datetime(2024, 1, 1)\n        )\n    ]\n)\n</code></pre>"},{"location":"user-guide/database/crud/#optimized-field-selection","title":"Optimized Field Selection","text":"<p>Select only needed fields for better performance:</p> <pre><code># Only select id and username\nusers = await crud_users.get_multi(\n    db=db,\n    schema_to_select=UserRead,  # Use schema to define fields\n    limit=100\n)\n\n# Or specify fields directly\nusers = await crud_users.get_multi(\n    db=db,\n    schema_to_select=[\"id\", \"username\", \"email\"],\n    limit=100\n)\n</code></pre>"},{"location":"user-guide/database/crud/#practical-examples","title":"Practical Examples","text":""},{"location":"user-guide/database/crud/#complete-crud-workflow","title":"Complete CRUD Workflow","text":"<p>Here's a complete example showing all CRUD operations:</p> <pre><code>from sqlalchemy.ext.asyncio import AsyncSession\nfrom app.crud.crud_users import crud_users\nfrom app.schemas.user import UserCreateInternal, UserUpdate, UserRead\n\nasync def user_management_example(db: AsyncSession):\n    # 1. CREATE\n    user_data = UserCreateInternal(\n        username=\"demo_user\",\n        email=\"demo@example.com\",\n        hashed_password=\"hashed_password\"\n    )\n    new_user = await crud_users.create(db=db, object=user_data)\n    print(f\"Created user: {new_user.id}\")\n\n    # 2. READ\n    user = await crud_users.get(\n        db=db, \n        id=new_user.id, \n        schema_to_select=UserRead\n    )\n    print(f\"Retrieved user: {user.username}\")\n\n    # 3. UPDATE  \n    update_data = UserUpdate(email=\"updated@example.com\")\n    await crud_users.update(db=db, object=update_data, id=new_user.id)\n    print(\"User updated\")\n\n    # 4. DELETE (soft delete)\n    await crud_users.delete(db=db, id=new_user.id)\n    print(\"User soft deleted\")\n\n    # 5. VERIFY DELETION\n    deleted_user = await crud_users.get(db=db, id=new_user.id, is_deleted=True)\n    print(f\"User deleted at: {deleted_user.deleted_at}\")\n</code></pre>"},{"location":"user-guide/database/crud/#pagination-helper","title":"Pagination Helper","text":"<p>Using FastCRUD's pagination utilities:</p> <pre><code>from fastcrud.paginated import compute_offset, paginated_response\n\nasync def get_paginated_users(\n    db: AsyncSession, \n    page: int = 1, \n    items_per_page: int = 10\n):\n    users_data = await crud_users.get_multi(\n        db=db,\n        offset=compute_offset(page, items_per_page),\n        limit=items_per_page,\n        is_deleted=False,\n        schema_to_select=UserRead\n    )\n\n    return paginated_response(\n        crud_data=users_data, \n        page=page, \n        items_per_page=items_per_page\n    )\n</code></pre>"},{"location":"user-guide/database/crud/#error-handling","title":"Error Handling","text":"<p>Proper error handling with CRUD operations:</p> <pre><code>from app.core.exceptions.http_exceptions import NotFoundException, DuplicateValueException\n\nasync def safe_user_creation(db: AsyncSession, user_data: UserCreate):\n    # Check for duplicates\n    if await crud_users.exists(db=db, email=user_data.email):\n        raise DuplicateValueException(\"Email already registered\")\n\n    if await crud_users.exists(db=db, username=user_data.username):\n        raise DuplicateValueException(\"Username not available\")\n\n    # Create user\n    try:\n        user_internal = UserCreateInternal(**user_data.model_dump())\n        created_user = await crud_users.create(db=db, object=user_internal)\n        return created_user\n    except Exception as e:\n        # Handle database errors\n        await db.rollback()\n        raise e\n</code></pre>"},{"location":"user-guide/database/crud/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/database/crud/#1-use-schema-selection","title":"1. Use Schema Selection","text":"<p>Always specify <code>schema_to_select</code> to avoid loading unnecessary data:</p> <pre><code># Good - only loads needed fields\nuser = await crud_users.get(db=db, id=user_id, schema_to_select=UserRead)\n\n# Avoid - loads all fields\nuser = await crud_users.get(db=db, id=user_id)\n</code></pre>"},{"location":"user-guide/database/crud/#2-batch-operations","title":"2. Batch Operations","text":"<p>For multiple operations, use transactions:</p> <pre><code>async def batch_user_updates(db: AsyncSession, updates: List[dict]):\n    try:\n        for update in updates:\n            await crud_users.update(db=db, object=update[\"data\"], id=update[\"id\"])\n        await db.commit()\n    except Exception:\n        await db.rollback()\n        raise\n</code></pre>"},{"location":"user-guide/database/crud/#3-use-exists-for-checks","title":"3. Use Exists for Checks","text":"<p>Use <code>exists()</code> instead of <code>get()</code> when you only need to check existence:</p> <pre><code># Good - faster, doesn't load data\nif await crud_users.exists(db=db, email=email):\n    raise DuplicateValueException(\"Email taken\")\n\n# Avoid - slower, loads unnecessary data\nuser = await crud_users.get(db=db, email=email)\nif user:\n    raise DuplicateValueException(\"Email taken\")\n</code></pre>"},{"location":"user-guide/database/crud/#next-steps","title":"Next Steps","text":"<ul> <li>Database Migrations - Managing database schema changes</li> <li>API Development - Using CRUD in API endpoints</li> <li>Caching - Optimizing CRUD with caching </li> </ul>"},{"location":"user-guide/database/migrations/","title":"Database Migrations","text":"<p>This guide covers database migrations using Alembic, the migration tool for SQLAlchemy. Learn how to manage database schema changes safely and efficiently in development and production.</p>"},{"location":"user-guide/database/migrations/#overview","title":"Overview","text":"<p>The FastAPI Boilerplate uses Alembic for database migrations. Alembic provides:</p> <ul> <li>Version-controlled schema changes - Track every database modification</li> <li>Automatic migration generation - Generate migrations from model changes  </li> <li>Reversible migrations - Upgrade and downgrade database versions</li> <li>Environment-specific configurations - Different settings for dev/staging/production</li> <li>Safe schema evolution - Apply changes incrementally</li> </ul>"},{"location":"user-guide/database/migrations/#simple-setup-automatic-table-creation","title":"Simple Setup: Automatic Table Creation","text":"<p>For simple projects or development, the boilerplate includes <code>create_tables_on_start</code> parameter that automatically creates all tables on application startup:</p> <pre><code># This is enabled by default in create_application()\napp = create_application(\n    router=router, \n    settings=settings, \n    create_tables_on_start=True  # Default: True\n)\n</code></pre> <p>When to use:</p> <ul> <li>\u2705 Development - Quick setup without migration management</li> <li>\u2705 Simple projects - When you don't need migration history  </li> <li>\u2705 Prototyping - Fast iteration without migration complexity</li> <li>\u2705 Testing - Clean database state for each test run</li> </ul> <p>When NOT to use:</p> <ul> <li>\u274c Production - No migration history or rollback capability</li> <li>\u274c Team development - Can't track schema changes between developers</li> <li>\u274c Data migrations - Only handles schema, not data transformations</li> <li>\u274c Complex deployments - No control over when/how schema changes apply</li> </ul> <pre><code># Disable for production environments\napp = create_application(\n    router=router, \n    settings=settings, \n    create_tables_on_start=False  # Use migrations instead\n)\n</code></pre> <p>For production deployments and team development, use proper Alembic migrations as described below.</p>"},{"location":"user-guide/database/migrations/#configuration","title":"Configuration","text":""},{"location":"user-guide/database/migrations/#alembic-setup","title":"Alembic Setup","text":"<p>Alembic is configured in <code>src/alembic.ini</code>:</p> <pre><code>[alembic]\n# Path to migration files\nscript_location = migrations\n\n# Database URL with environment variable substitution\nsqlalchemy.url = postgresql://%(POSTGRES_USER)s:%(POSTGRES_PASSWORD)s@%(POSTGRES_SERVER)s:%(POSTGRES_PORT)s/%(POSTGRES_DB)s\n\n# Other configurations\nfile_template = %%(year)d%%(month).2d%%(day).2d_%%(hour).2d%%(minute).2d_%%(rev)s_%%(slug)s\ntimezone = UTC\n</code></pre>"},{"location":"user-guide/database/migrations/#environment-configuration","title":"Environment Configuration","text":"<p>Migration environment is configured in <code>src/migrations/env.py</code>:</p> <pre><code># src/migrations/env.py\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\nfrom app.core.db.database import Base\nfrom app.core.config import settings\n\n# Import all models to ensure they're registered\nfrom app.models import *  # This imports all models\n\nconfig = context.config\n\n# Override database URL from environment\nconfig.set_main_option(\"sqlalchemy.url\", settings.DATABASE_URL)\n\ntarget_metadata = Base.metadata\n</code></pre>"},{"location":"user-guide/database/migrations/#migration-workflow","title":"Migration Workflow","text":""},{"location":"user-guide/database/migrations/#1-creating-migrations","title":"1. Creating Migrations","text":"<p>Generate migrations automatically when you change models:</p> <pre><code># Navigate to src directory\ncd src\n\n# Generate migration from model changes\nuv run alembic revision --autogenerate -m \"Add user profile fields\"\n</code></pre> <p>What happens: - Alembic compares current models with database schema - Generates a new migration file in <code>src/migrations/versions/</code> - Migration includes upgrade and downgrade functions</p>"},{"location":"user-guide/database/migrations/#2-review-generated-migration","title":"2. Review Generated Migration","text":"<p>Always review auto-generated migrations before applying:</p> <pre><code># Example migration file: src/migrations/versions/20241215_1430_add_user_profile_fields.py\n\"\"\"Add user profile fields\n\nRevision ID: abc123def456\nRevises: previous_revision_id\nCreate Date: 2024-12-15 14:30:00.000000\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n# revision identifiers\nrevision = 'abc123def456'\ndown_revision = 'previous_revision_id'\nbranch_labels = None\ndepends_on = None\n\ndef upgrade() -&gt; None:\n    # Add new columns\n    op.add_column('user', sa.Column('bio', sa.String(500), nullable=True))\n    op.add_column('user', sa.Column('website', sa.String(255), nullable=True))\n\n    # Create index\n    op.create_index('ix_user_website', 'user', ['website'])\n\ndef downgrade() -&gt; None:\n    # Remove changes (reverse order)\n    op.drop_index('ix_user_website', 'user')\n    op.drop_column('user', 'website')\n    op.drop_column('user', 'bio')\n</code></pre>"},{"location":"user-guide/database/migrations/#3-apply-migration","title":"3. Apply Migration","text":"<p>Apply migrations to update database schema:</p> <pre><code># Apply all pending migrations\nuv run alembic upgrade head\n\n# Apply specific number of migrations\nuv run alembic upgrade +2\n\n# Apply to specific revision\nuv run alembic upgrade abc123def456\n</code></pre>"},{"location":"user-guide/database/migrations/#4-verify-migration","title":"4. Verify Migration","text":"<p>Check migration status and current version:</p> <pre><code># Show current database version\nuv run alembic current\n\n# Show migration history\nuv run alembic history\n\n# Show pending migrations\nuv run alembic show head\n</code></pre>"},{"location":"user-guide/database/migrations/#common-migration-scenarios","title":"Common Migration Scenarios","text":""},{"location":"user-guide/database/migrations/#adding-new-model","title":"Adding New Model","text":"<ol> <li>Create the model in <code>src/app/models/</code>:</li> </ol> <pre><code># src/app/models/category.py\nfrom sqlalchemy import String, DateTime\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom datetime import datetime\nfrom app.core.db.database import Base\n\nclass Category(Base):\n    __tablename__ = \"category\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, init=False)\n    name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\n    slug: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\n    description: Mapped[str] = mapped_column(String(255), nullable=True)\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)\n</code></pre> <ol> <li>Import in init.py:</li> </ol> <pre><code># src/app/models/__init__.py\nfrom .user import User\nfrom .post import Post\nfrom .tier import Tier\nfrom .rate_limit import RateLimit\nfrom .category import Category  # Add new import\n</code></pre> <ol> <li>Generate migration:</li> </ol> <pre><code>uv run alembic revision --autogenerate -m \"Add category model\"\n</code></pre>"},{"location":"user-guide/database/migrations/#adding-foreign-key","title":"Adding Foreign Key","text":"<ol> <li>Update model with foreign key:</li> </ol> <pre><code># Add to Post model\ncategory_id: Mapped[Optional[int]] = mapped_column(ForeignKey(\"category.id\"), nullable=True)\n</code></pre> <ol> <li>Generate migration:</li> </ol> <pre><code>uv run alembic revision --autogenerate -m \"Add category_id to posts\"\n</code></pre> <ol> <li>Review and apply:</li> </ol> <pre><code># Generated migration will include:\ndef upgrade() -&gt; None:\n    op.add_column('post', sa.Column('category_id', sa.Integer(), nullable=True))\n    op.create_foreign_key('fk_post_category_id', 'post', 'category', ['category_id'], ['id'])\n    op.create_index('ix_post_category_id', 'post', ['category_id'])\n</code></pre>"},{"location":"user-guide/database/migrations/#data-migrations","title":"Data Migrations","text":"<p>Sometimes you need to migrate data, not just schema:</p> <pre><code># Example: Populate default category for existing posts\ndef upgrade() -&gt; None:\n    # Add the column\n    op.add_column('post', sa.Column('category_id', sa.Integer(), nullable=True))\n\n    # Data migration\n    connection = op.get_bind()\n\n    # Create default category\n    connection.execute(\n        \"INSERT INTO category (name, slug, description) VALUES ('General', 'general', 'Default category')\"\n    )\n\n    # Get default category ID\n    result = connection.execute(\"SELECT id FROM category WHERE slug = 'general'\")\n    default_category_id = result.fetchone()[0]\n\n    # Update existing posts\n    connection.execute(\n        f\"UPDATE post SET category_id = {default_category_id} WHERE category_id IS NULL\"\n    )\n\n    # Make column non-nullable after data migration\n    op.alter_column('post', 'category_id', nullable=False)\n</code></pre>"},{"location":"user-guide/database/migrations/#renaming-columns","title":"Renaming Columns","text":"<pre><code>def upgrade() -&gt; None:\n    # Rename column\n    op.alter_column('user', 'full_name', new_column_name='name')\n\ndef downgrade() -&gt; None:\n    # Reverse the rename\n    op.alter_column('user', 'name', new_column_name='full_name')\n</code></pre>"},{"location":"user-guide/database/migrations/#dropping-tables","title":"Dropping Tables","text":"<pre><code>def upgrade() -&gt; None:\n    # Drop table (be careful!)\n    op.drop_table('old_table')\n\ndef downgrade() -&gt; None:\n    # Recreate table structure\n    op.create_table('old_table',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('name', sa.String(50), nullable=True),\n        sa.PrimaryKeyConstraint('id')\n    )\n</code></pre>"},{"location":"user-guide/database/migrations/#production-migration-strategy","title":"Production Migration Strategy","text":""},{"location":"user-guide/database/migrations/#1-development-workflow","title":"1. Development Workflow","text":"<pre><code># 1. Make model changes\n# 2. Generate migration\nuv run alembic revision --autogenerate -m \"Descriptive message\"\n\n# 3. Review migration file\n# 4. Test migration\nuv run alembic upgrade head\n\n# 5. Test downgrade (optional)\nuv run alembic downgrade -1\nuv run alembic upgrade head\n</code></pre>"},{"location":"user-guide/database/migrations/#2-staging-deployment","title":"2. Staging Deployment","text":"<pre><code># 1. Deploy code with migrations\n# 2. Backup database\npg_dump -h staging-db -U user dbname &gt; backup_$(date +%Y%m%d_%H%M%S).sql\n\n# 3. Apply migrations\nuv run alembic upgrade head\n\n# 4. Verify application works\n# 5. Run tests\n</code></pre>"},{"location":"user-guide/database/migrations/#3-production-deployment","title":"3. Production Deployment","text":"<pre><code># 1. Schedule maintenance window\n# 2. Create database backup\npg_dump -h prod-db -U user dbname &gt; prod_backup_$(date +%Y%m%d_%H%M%S).sql\n\n# 3. Apply migrations (with monitoring)\nuv run alembic upgrade head\n\n# 4. Verify health checks pass\n# 5. Monitor application metrics\n</code></pre>"},{"location":"user-guide/database/migrations/#docker-considerations","title":"Docker Considerations","text":""},{"location":"user-guide/database/migrations/#development-with-docker-compose","title":"Development with Docker Compose","text":"<p>For local development, migrations run automatically:</p> <pre><code># docker-compose.yml\nservices:\n  web:\n    # ... other config\n    depends_on:\n      - db\n    command: |\n      sh -c \"\n        uv run alembic upgrade head &amp;&amp;\n        uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload\n      \"\n</code></pre>"},{"location":"user-guide/database/migrations/#production-docker","title":"Production Docker","text":"<p>In production, run migrations separately:</p> <pre><code># Dockerfile migration stage\nFROM python:3.11-slim as migration\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY src/ /app/\nWORKDIR /app\nCMD [\"alembic\", \"upgrade\", \"head\"]\n</code></pre> <pre><code># docker-compose.prod.yml\nservices:\n  migrate:\n    build:\n      context: .\n      target: migration\n    env_file:\n      - .env\n    depends_on:\n      - db\n    command: alembic upgrade head\n\n  web:\n    # ... web service config\n    depends_on:\n      - migrate\n</code></pre>"},{"location":"user-guide/database/migrations/#migration-best-practices","title":"Migration Best Practices","text":""},{"location":"user-guide/database/migrations/#1-always-review-generated-migrations","title":"1. Always Review Generated Migrations","text":"<pre><code># Check for issues like:\n# - Missing imports\n# - Incorrect nullable settings\n# - Missing indexes\n# - Data loss operations\n</code></pre>"},{"location":"user-guide/database/migrations/#2-use-descriptive-messages","title":"2. Use Descriptive Messages","text":"<pre><code># Good\nuv run alembic revision --autogenerate -m \"Add user email verification fields\"\n\n# Bad\nuv run alembic revision --autogenerate -m \"Update user model\"\n</code></pre>"},{"location":"user-guide/database/migrations/#3-handle-nullable-columns-carefully","title":"3. Handle Nullable Columns Carefully","text":"<pre><code># When adding non-nullable columns to existing tables:\ndef upgrade() -&gt; None:\n    # 1. Add as nullable first\n    op.add_column('user', sa.Column('phone', sa.String(20), nullable=True))\n\n    # 2. Populate with default data\n    op.execute(\"UPDATE user SET phone = '' WHERE phone IS NULL\")\n\n    # 3. Make non-nullable\n    op.alter_column('user', 'phone', nullable=False)\n</code></pre>"},{"location":"user-guide/database/migrations/#4-test-rollbacks","title":"4. Test Rollbacks","text":"<pre><code># Test that your downgrade works\nuv run alembic downgrade -1\nuv run alembic upgrade head\n</code></pre>"},{"location":"user-guide/database/migrations/#5-use-transactions-for-complex-migrations","title":"5. Use Transactions for Complex Migrations","text":"<pre><code>def upgrade() -&gt; None:\n    # Complex migration with transaction\n    connection = op.get_bind()\n    trans = connection.begin()\n    try:\n        # Multiple operations\n        op.create_table(...)\n        op.add_column(...)\n        connection.execute(\"UPDATE ...\")\n        trans.commit()\n    except:\n        trans.rollback()\n        raise\n</code></pre>"},{"location":"user-guide/database/migrations/#next-steps","title":"Next Steps","text":"<ul> <li>CRUD Operations - Working with migrated database schema</li> <li>API Development - Building endpoints for your models</li> <li>Testing - Testing database migrations </li> </ul>"},{"location":"user-guide/database/models/","title":"Database Models","text":"<p>This section explains how SQLAlchemy models are implemented in the boilerplate, how to create new models, and the patterns used for relationships, validation, and data integrity.</p>"},{"location":"user-guide/database/models/#model-structure","title":"Model Structure","text":"<p>Models are defined in <code>src/app/models/</code> using SQLAlchemy 2.0's declarative syntax with <code>Mapped</code> type annotations.</p>"},{"location":"user-guide/database/models/#base-model","title":"Base Model","text":"<p>All models inherit from <code>Base</code> defined in <code>src/app/core/db/database.py</code>:</p> <pre><code>from sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n</code></pre> <p>SQLAlchemy 2.0 Change: Uses <code>DeclarativeBase</code> instead of the older <code>declarative_base()</code> function. This provides better type checking and IDE support.</p>"},{"location":"user-guide/database/models/#model-file-structure","title":"Model File Structure","text":"<p>Each model is in its own file:</p> <pre><code>src/app/models/\n\u251c\u2500\u2500 __init__.py          # Imports all models for Alembic discovery\n\u251c\u2500\u2500 user.py             # User authentication model\n\u251c\u2500\u2500 post.py             # Example content model with relationships\n\u251c\u2500\u2500 tier.py             # User subscription tiers\n\u2514\u2500\u2500 rate_limit.py       # API rate limiting configuration\n</code></pre> <p>Import Requirement: Models must be imported in <code>__init__.py</code> for Alembic to detect them during migration generation.</p>"},{"location":"user-guide/database/models/#design-decision-no-sqlalchemy-relationships","title":"Design Decision: No SQLAlchemy Relationships","text":"<p>The boilerplate deliberately avoids using SQLAlchemy's <code>relationship()</code> feature. This is an intentional architectural choice with specific benefits.</p>"},{"location":"user-guide/database/models/#why-no-relationships","title":"Why No Relationships","text":"<p>Performance Concerns:</p> <ul> <li>N+1 Query Problem: Relationships can trigger multiple queries when accessing related data</li> <li>Lazy Loading: Unpredictable when queries execute, making performance optimization difficult</li> <li>Memory Usage: Loading large object graphs consumes significant memory</li> </ul> <p>Code Clarity:</p> <ul> <li>Explicit Data Fetching: Developers see exactly what data is being loaded and when</li> <li>Predictable Queries: No \"magic\" queries triggered by attribute access</li> <li>Easier Debugging: SQL queries are explicit in the code, not hidden in relationship configuration</li> </ul> <p>Flexibility:</p> <ul> <li>Query Optimization: Can optimize each query for its specific use case</li> <li>Selective Loading: Load only the fields needed for each operation</li> <li>Join Control: Use FastCRUD's join methods when needed, skip when not</li> </ul>"},{"location":"user-guide/database/models/#what-this-means-in-practice","title":"What This Means in Practice","text":"<p>Instead of this (traditional SQLAlchemy): <pre><code># Not used in the boilerplate\nclass User(Base):\n    posts: Mapped[List[\"Post\"]] = relationship(\"Post\", back_populates=\"created_by_user\")\n\nclass Post(Base):\n    created_by_user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"posts\")\n</code></pre></p> <p>The boilerplate uses this approach: <pre><code># DO - Explicit and controlled\nclass User(Base):\n    # Only foreign key, no relationship\n    tier_id: Mapped[int | None] = mapped_column(ForeignKey(\"tier.id\"), index=True, default=None)\n\nclass Post(Base):\n    # Only foreign key, no relationship  \n    created_by_user_id: Mapped[int] = mapped_column(ForeignKey(\"user.id\"), index=True)\n\n# Explicit queries - you control exactly what's loaded\nuser = await crud_users.get(db=db, id=1)\nposts = await crud_posts.get_multi(db=db, created_by_user_id=user.id)\n\n# Or use joins when needed\nposts_with_users = await crud_posts.get_multi_joined(\n    db=db,\n    join_model=User,\n    schema_to_select=PostRead,\n    join_schema_to_select=UserRead\n)\n</code></pre></p>"},{"location":"user-guide/database/models/#benefits-of-this-approach","title":"Benefits of This Approach","text":"<p>Predictable Performance:</p> <ul> <li>Every database query is explicit in the code</li> <li>No surprise queries from accessing relationships</li> <li>Easier to identify and optimize slow operations</li> </ul> <p>Better Caching:</p> <ul> <li>Can cache individual models without worrying about related data</li> <li>Cache invalidation is simpler and more predictable</li> </ul> <p>API Design:</p> <ul> <li>Forces thinking about what data clients actually need</li> <li>Prevents over-fetching in API responses</li> <li>Encourages lean, focused endpoints</li> </ul> <p>Testing:</p> <ul> <li>Easier to mock database operations</li> <li>No complex relationship setup in test fixtures</li> <li>More predictable test data requirements</li> </ul>"},{"location":"user-guide/database/models/#when-you-need-related-data","title":"When You Need Related Data","text":"<p>Use FastCRUD's join capabilities:</p> <pre><code># Single record with related data\npost_with_author = await crud_posts.get_joined(\n    db=db,\n    join_model=User,\n    schema_to_select=PostRead,\n    join_schema_to_select=UserRead,\n    id=post_id\n)\n\n# Multiple records with joins\nposts_with_authors = await crud_posts.get_multi_joined(\n    db=db,\n    join_model=User,\n    offset=0,\n    limit=10\n)\n</code></pre>"},{"location":"user-guide/database/models/#alternative-approaches","title":"Alternative Approaches","text":"<p>If you need relationships in your project, you can add them:</p> <pre><code># Add relationships if needed for your use case\nfrom sqlalchemy.orm import relationship\n\nclass User(Base):\n    # ... existing fields ...\n    posts: Mapped[List[\"Post\"]] = relationship(\"Post\", back_populates=\"created_by_user\")\n\nclass Post(Base):\n    # ... existing fields ...\n    created_by_user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"posts\")\n</code></pre> <p>But consider the trade-offs and whether explicit queries might be better for your use case.</p>"},{"location":"user-guide/database/models/#user-model-implementation","title":"User Model Implementation","text":"<p>The User model (<code>src/app/models/user.py</code>) demonstrates authentication patterns:</p> <pre><code>import uuid as uuid_pkg\nfrom datetime import UTC, datetime\nfrom sqlalchemy import DateTime, ForeignKey, String\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom ..core.db.database import Base\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[int] = mapped_column(\"id\", autoincrement=True, nullable=False, unique=True, primary_key=True, init=False)\n\n    # User data\n    name: Mapped[str] = mapped_column(String(30))\n    username: Mapped[str] = mapped_column(String(20), unique=True, index=True)\n    email: Mapped[str] = mapped_column(String(50), unique=True, index=True)\n    hashed_password: Mapped[str] = mapped_column(String)\n\n    # Profile\n    profile_image_url: Mapped[str] = mapped_column(String, default=\"https://profileimageurl.com\")\n\n    # UUID for external references\n    uuid: Mapped[uuid_pkg.UUID] = mapped_column(default_factory=uuid_pkg.uuid4, primary_key=True, unique=True)\n\n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default_factory=lambda: datetime.now(UTC))\n    updated_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), default=None)\n    deleted_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), default=None)\n\n    # Status flags\n    is_deleted: Mapped[bool] = mapped_column(default=False, index=True)\n    is_superuser: Mapped[bool] = mapped_column(default=False)\n\n    # Foreign key to tier system (no relationship defined)\n    tier_id: Mapped[int | None] = mapped_column(ForeignKey(\"tier.id\"), index=True, default=None, init=False)\n</code></pre>"},{"location":"user-guide/database/models/#key-implementation-details","title":"Key Implementation Details","text":"<p>Type Annotations: <code>Mapped[type]</code> provides type hints for SQLAlchemy 2.0. IDE and mypy can validate types.</p> <p>String Lengths: Explicit lengths (<code>String(50)</code>) prevent database errors and define constraints clearly.</p> <p>Nullable Fields: Explicitly set <code>nullable=False</code> for required fields, <code>nullable=True</code> for optional ones.</p> <p>Default Values: Use <code>default=</code> for database-level defaults, Python functions for computed defaults.</p>"},{"location":"user-guide/database/models/#post-model-with-relationships","title":"Post Model with Relationships","text":"<p>The Post model (<code>src/app/models/post.py</code>) shows relationships and soft deletion:</p> <pre><code>import uuid as uuid_pkg\nfrom datetime import UTC, datetime\nfrom sqlalchemy import DateTime, ForeignKey, String\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom ..core.db.database import Base\n\nclass Post(Base):\n    __tablename__ = \"post\"\n\n    id: Mapped[int] = mapped_column(\"id\", autoincrement=True, nullable=False, unique=True, primary_key=True, init=False)\n\n    # Content\n    title: Mapped[str] = mapped_column(String(30))\n    text: Mapped[str] = mapped_column(String(63206))  # Large text field\n    media_url: Mapped[str | None] = mapped_column(String, default=None)\n\n    # UUID for external references\n    uuid: Mapped[uuid_pkg.UUID] = mapped_column(default_factory=uuid_pkg.uuid4, primary_key=True, unique=True)\n\n    # Foreign key (no relationship defined)\n    created_by_user_id: Mapped[int] = mapped_column(ForeignKey(\"user.id\"), index=True)\n\n    # Timestamps (built-in soft delete pattern)\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default_factory=lambda: datetime.now(UTC))\n    updated_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), default=None)\n    deleted_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), default=None)\n    is_deleted: Mapped[bool] = mapped_column(default=False, index=True)\n</code></pre>"},{"location":"user-guide/database/models/#soft-deletion-pattern","title":"Soft Deletion Pattern","text":"<p>Soft deletion is built directly into models:</p> <pre><code># Built into each model that needs soft deletes\nclass Post(Base):\n    # ... other fields ...\n\n    # Soft delete fields\n    is_deleted: Mapped[bool] = mapped_column(default=False, index=True)\n    deleted_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), default=None)\n</code></pre> <p>Usage: When <code>crud_posts.delete()</code> is called, it sets <code>is_deleted=True</code> and <code>deleted_at=datetime.now(UTC)</code> instead of removing the database row.</p>"},{"location":"user-guide/database/models/#tier-and-rate-limiting-models","title":"Tier and Rate Limiting Models","text":""},{"location":"user-guide/database/models/#tier-model","title":"Tier Model","text":"<pre><code># src/app/models/tier.py\nclass Tier(Base):\n    __tablename__ = \"tier\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, init=False)\n    name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, nullable=False)\n</code></pre>"},{"location":"user-guide/database/models/#rate-limit-model","title":"Rate Limit Model","text":"<pre><code># src/app/models/rate_limit.py\nclass RateLimit(Base):\n    __tablename__ = \"rate_limit\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, init=False)\n    tier_id: Mapped[int] = mapped_column(ForeignKey(\"tier.id\"), nullable=False)\n    path: Mapped[str] = mapped_column(String(255), nullable=False)\n    limit: Mapped[int] = mapped_column(nullable=False)  # requests allowed\n    period: Mapped[int] = mapped_column(nullable=False)  # time period in seconds\n    name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)\n</code></pre> <p>Purpose: Links API endpoints (<code>path</code>) to rate limits (<code>limit</code> requests per <code>period</code> seconds) for specific user tiers.</p>"},{"location":"user-guide/database/models/#creating-new-models","title":"Creating New Models","text":""},{"location":"user-guide/database/models/#step-by-step-process","title":"Step-by-Step Process","text":"<ol> <li>Create model file in <code>src/app/models/your_model.py</code></li> <li>Define model class inheriting from <code>Base</code></li> <li>Add to imports in <code>src/app/models/__init__.py</code></li> <li>Generate migration with <code>alembic revision --autogenerate</code></li> <li>Apply migration with <code>alembic upgrade head</code></li> </ol>"},{"location":"user-guide/database/models/#example-creating-a-category-model","title":"Example: Creating a Category Model","text":"<pre><code># src/app/models/category.py\nfrom datetime import datetime\nfrom typing import List\nfrom sqlalchemy import String, DateTime\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom app.core.db.database import Base\n\nclass Category(Base):\n    __tablename__ = \"category\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, init=False)\n    name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\n    description: Mapped[str] = mapped_column(String(255), nullable=True)\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, nullable=False)\n</code></pre> <p>If you want to relate Category to Post, just add the id reference in the model:</p> <pre><code>class Post(Base):\n    __tablename__ = \"post\"\n    ...\n\n    # Foreign key (no relationship defined)\n    category_id: Mapped[int] = mapped_column(ForeignKey(\"category.id\"), index=True)\n</code></pre>"},{"location":"user-guide/database/models/#import-in-initpy","title":"Import in init.py","text":"<pre><code># src/app/models/__init__.py\nfrom .user import User\nfrom .post import Post\nfrom .tier import Tier\nfrom .rate_limit import RateLimit\nfrom .category import Category  # Add new model\n</code></pre> <p>Critical: Without this import, Alembic won't detect the model for migrations.</p>"},{"location":"user-guide/database/models/#model-validation-and-constraints","title":"Model Validation and Constraints","text":""},{"location":"user-guide/database/models/#database-level-constraints","title":"Database-Level Constraints","text":"<pre><code>from sqlalchemy import CheckConstraint, Index\n\nclass Product(Base):\n    __tablename__ = \"product\"\n\n    price: Mapped[float] = mapped_column(nullable=False)\n    quantity: Mapped[int] = mapped_column(nullable=False)\n\n    # Table-level constraints\n    __table_args__ = (\n        CheckConstraint('price &gt; 0', name='positive_price'),\n        CheckConstraint('quantity &gt;= 0', name='non_negative_quantity'),\n        Index('idx_product_price', 'price'),\n    )\n</code></pre>"},{"location":"user-guide/database/models/#unique-constraints","title":"Unique Constraints","text":"<pre><code># Single column unique\nemail: Mapped[str] = mapped_column(String(100), unique=True)\n\n# Multi-column unique constraint\n__table_args__ = (\n    UniqueConstraint('user_id', 'category_id', name='unique_user_category'),\n)\n</code></pre>"},{"location":"user-guide/database/models/#common-model-patterns","title":"Common Model Patterns","text":""},{"location":"user-guide/database/models/#timestamp-tracking","title":"Timestamp Tracking","text":"<pre><code>class TimestampedModel:\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, nullable=False)\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime, \n        default=datetime.utcnow, \n        onupdate=datetime.utcnow, \n        nullable=False\n    )\n\n# Use as mixin\nclass Post(Base, TimestampedModel, SoftDeleteMixin):\n    # Model automatically gets created_at, updated_at, is_deleted, deleted_at\n    __tablename__ = \"post\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n</code></pre>"},{"location":"user-guide/database/models/#enumeration-fields","title":"Enumeration Fields","text":"<pre><code>from enum import Enum\nfrom sqlalchemy import Enum as SQLEnum\n\nclass UserStatus(Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\" \n    SUSPENDED = \"suspended\"\n\nclass User(Base):\n    status: Mapped[UserStatus] = mapped_column(SQLEnum(UserStatus), default=UserStatus.ACTIVE)\n</code></pre>"},{"location":"user-guide/database/models/#json-fields","title":"JSON Fields","text":"<pre><code>from sqlalchemy.dialects.postgresql import JSONB\n\nclass UserProfile(Base):\n    preferences: Mapped[dict] = mapped_column(JSONB, nullable=True)\n    metadata: Mapped[dict] = mapped_column(JSONB, default=lambda: {})\n</code></pre> <p>PostgreSQL-specific: Uses JSONB for efficient JSON storage and querying.</p>"},{"location":"user-guide/database/models/#model-testing","title":"Model Testing","text":""},{"location":"user-guide/database/models/#basic-model-tests","title":"Basic Model Tests","text":"<pre><code># tests/test_models.py\nimport pytest\nfrom sqlalchemy.exc import IntegrityError\nfrom app.models.user import User\n\ndef test_user_creation():\n    user = User(\n        username=\"testuser\",\n        email=\"test@example.com\", \n        hashed_password=\"hashed123\"\n    )\n    assert user.username == \"testuser\"\n    assert user.is_active is True  # Default value\n\ndef test_user_unique_constraint():\n    # Test that duplicate emails raise IntegrityError\n    with pytest.raises(IntegrityError):\n        # Create users with same email\n        pass\n</code></pre>"},{"location":"user-guide/database/models/#migration-considerations","title":"Migration Considerations","text":""},{"location":"user-guide/database/models/#backwards-compatible-changes","title":"Backwards Compatible Changes","text":"<p>Safe changes that don't break existing code:</p> <ul> <li>Adding nullable columns</li> <li>Adding new tables</li> <li>Adding indexes</li> <li>Increasing column lengths</li> </ul>"},{"location":"user-guide/database/models/#breaking-changes","title":"Breaking Changes","text":"<p>Changes requiring careful migration:</p> <ul> <li>Making columns non-nullable</li> <li>Removing columns</li> <li>Changing column types</li> <li>Removing tables</li> </ul>"},{"location":"user-guide/database/models/#next-steps","title":"Next Steps","text":"<p>Now that you understand model implementation:</p> <ol> <li>Schemas - Learn Pydantic validation and serialization</li> <li>CRUD Operations - Implement database operations with FastCRUD  </li> <li>Migrations - Manage schema changes with Alembic</li> </ol> <p>The next section covers how Pydantic schemas provide validation and API contracts separate from database models. </p>"},{"location":"user-guide/database/schemas/","title":"Database Schemas","text":"<p>This section explains how Pydantic schemas handle data validation, serialization, and API contracts in the boilerplate. Schemas are separate from SQLAlchemy models and define what data enters and exits your API.</p>"},{"location":"user-guide/database/schemas/#schema-purpose-and-structure","title":"Schema Purpose and Structure","text":"<p>Schemas serve three main purposes:</p> <ol> <li>Input Validation - Validate incoming API request data</li> <li>Output Serialization - Format database data for API responses  </li> <li>API Contracts - Define clear interfaces between frontend and backend</li> </ol>"},{"location":"user-guide/database/schemas/#schema-file-organization","title":"Schema File Organization","text":"<p>Schemas are organized in <code>src/app/schemas/</code> with one file per model:</p> <pre><code>src/app/schemas/\n\u251c\u2500\u2500 __init__.py       # Imports for easy access\n\u251c\u2500\u2500 user.py          # User-related schemas\n\u251c\u2500\u2500 post.py          # Post-related schemas\n\u251c\u2500\u2500 tier.py          # Tier schemas\n\u251c\u2500\u2500 rate_limit.py    # Rate limit schemas\n\u2514\u2500\u2500 job.py           # Background job schemas\n</code></pre>"},{"location":"user-guide/database/schemas/#user-schema-implementation","title":"User Schema Implementation","text":"<p>The User schemas (<code>src/app/schemas/user.py</code>) demonstrate common validation patterns:</p> <pre><code>from datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ConfigDict, EmailStr, Field\n\nfrom ..core.schemas import PersistentDeletion, TimestampSchema, UUIDSchema\n\n\n# Base schema with common fields\nclass UserBase(BaseModel):\n    name: Annotated[\n        str, \n        Field(\n            min_length=2,\n            max_length=30,\n            examples=[\"User Userson\"]\n        )\n    ]\n    username: Annotated[\n        str,\n        Field(\n            min_length=2,\n            max_length=20,\n            pattern=r\"^[a-z0-9]+$\",\n            examples=[\"userson\"]\n        )\n    ]\n    email: Annotated[EmailStr, Field(examples=[\"user.userson@example.com\"])]\n\n\n# Full User data\nclass User(TimestampSchema, UserBase, UUIDSchema, PersistentDeletion):\n    profile_image_url: Annotated[\n        str,\n        Field(default=\"https://www.profileimageurl.com\")\n    ]\n    hashed_password: str\n    is_superuser: bool = False\n    tier_id: int | None = None\n\n\n# Schema for reading user data (API output)\nclass UserRead(BaseModel):\n    id: int\n\n    name: Annotated[\n        str,\n        Field(\n            min_length=2, \n            max_length=30, \n            examples=[\"User Userson\"]\n        )\n    ]\n    username: Annotated[\n        str, \n        Field(\n            min_length=2, \n            max_length=20, \n            pattern=r\"^[a-z0-9]+$\", \n            examples=[\"userson\"]\n        )\n    ]\n    email: Annotated[EmailStr, Field(examples=[\"user.userson@example.com\"])]\n    profile_image_url: str\n    tier_id: int | None\n\n\n# Schema for creating new users (API input)\nclass UserCreate(UserBase): # Inherits from UserBase\n    model_config = ConfigDict(extra=\"forbid\")\n\n    password: Annotated[\n        str,\n        Field(\n            pattern=r\"^.{8,}|[0-9]+|[A-Z]+|[a-z]+|[^a-zA-Z0-9]+$\",\n            examples=[\"Str1ngst!\"]\n        )\n    ]\n\n\n# Schema that FastCRUD will use to store just the hash\nclass UserCreateInternal(UserBase):\n    hashed_password: str\n\n\n# Schema for updating users\nclass UserUpdate(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    name: Annotated[\n        str | None,\n        Field(\n            min_length=2, \n            max_length=30, \n            examples=[\"User Userberg\"],\n            default=None\n        )\n    ]\n    username: Annotated[\n        str | None, \n        Field(\n            min_length=2,\n            max_length=20, \n            pattern=r\"^[a-z0-9]+$\", \n            examples=[\"userberg\"], \n            default=None\n        )\n    ]\n    email: Annotated[\n        EmailStr | None, \n        Field(\n            examples=[\"user.userberg@example.com\"],\n            default=None\n        )\n    ]\n    profile_image_url: Annotated[\n        str | None,\n        Field(\n            pattern=r\"^(https?|ftp)://[^\\s/$.?#].[^\\s]*$\",\n            examples=[\"https://www.profileimageurl.com\"],\n            default=None\n        ),\n    ]\n\n\n# Internal update schema\nclass UserUpdateInternal(UserUpdate):\n    updated_at: datetime\n\n\n# Schema to update tier id\nclass UserTierUpdate(BaseModel):\n    tier_id: int\n\n\n# Schema for user deletion (soft delete timestamps)\nclass UserDelete(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    is_deleted: bool\n    deleted_at: datetime\n\n\n# User specific schema\nclass UserRestoreDeleted(BaseModel):\n    is_deleted: bool\n</code></pre>"},{"location":"user-guide/database/schemas/#key-implementation-details","title":"Key Implementation Details","text":"<p>Field Validation: Uses <code>Annotated[type, Field(...)]</code> for validation rules. <code>Field</code> parameters include:</p> <ul> <li><code>min_length/max_length</code> - String length constraints</li> <li><code>gt/ge/lt/le</code> - Numeric constraints  </li> <li><code>pattern</code> - Pattern matching (regex)</li> <li><code>default</code> - Default values</li> </ul> <p>EmailStr: Validates email format and normalizes the value.</p> <p>ConfigDict: Replaces the old <code>Config</code> class. <code>from_attributes=True</code> allows creating schemas from SQLAlchemy model instances.</p> <p>Internal vs External: Separate schemas for internal operations (like password hashing) vs API exposure.</p>"},{"location":"user-guide/database/schemas/#schema-patterns","title":"Schema Patterns","text":""},{"location":"user-guide/database/schemas/#base-schema-pattern","title":"Base Schema Pattern","text":"<pre><code># Common fields shared across operations\nclass PostBase(BaseModel):\n    title: Annotated[\n        str, \n        Field(\n            min_length=1, \n            max_length=100\n        )\n    ]\n    content: Annotated[\n        str, \n        Field(\n            min_length=1, \n            max_length=10000\n        )\n    ]\n\n# Specific operation schemas inherit from base\nclass PostCreate(PostBase):\n    pass  # Only title and content needed for creation\n\nclass PostRead(PostBase):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    created_at: datetime\n    created_by_user_id: int\n    is_deleted: bool = False  # From model's soft delete fields\n</code></pre> <p>Purpose: Reduces duplication and ensures consistency across related schemas.</p>"},{"location":"user-guide/database/schemas/#optional-fields-in-updates","title":"Optional Fields in Updates","text":"<pre><code>class PostUpdate(BaseModel):\n    title: Annotated[\n        str | None, \n        Field(\n            min_length=1, \n            max_length=100,\n            default=None\n        )\n    ]\n    content: Annotated[\n        str | None, \n        Field(\n            min_length=1, \n            max_length=10000,\n            default=None\n        )\n    ]\n</code></pre> <p>Pattern: All fields optional in update schemas. Only provided fields are updated in the database.</p>"},{"location":"user-guide/database/schemas/#nested-schemas","title":"Nested Schemas","text":"<pre><code># Post schema with user information\nclass PostWithUser(PostRead):\n    created_by_user: UserRead  # Nested user data\n\n# Alternative: Custom nested schema\nclass PostAuthor(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    username: str\n    # Only include fields needed for this context\n\nclass PostRead(PostBase):\n    created_by_user: PostAuthor\n</code></pre> <p>Usage: Include related model data in responses without exposing all fields.</p>"},{"location":"user-guide/database/schemas/#validation-patterns","title":"Validation Patterns","text":""},{"location":"user-guide/database/schemas/#custom-validators","title":"Custom Validators","text":"<pre><code>from pydantic import field_validator, model_validator\n\nclass UserCreateWithConfirm(UserBase):\n    password: str\n    confirm_password: str\n\n    @field_validator('username')\n    @classmethod\n    def validate_username(cls, v):\n        if v.lower() in ['admin', 'root', 'system']:\n            raise ValueError('Username not allowed')\n        return v.lower()  # Normalize to lowercase\n\n    @model_validator(mode='after')\n    def validate_passwords_match(self):\n        if self.password != self.confirm_password:\n            raise ValueError('Passwords do not match')\n        return self\n</code></pre> <p>field_validator: Validates individual fields. Can transform values.</p> <p>model_validator: Validates across multiple fields. Access to full model data.</p>"},{"location":"user-guide/database/schemas/#computed-fields","title":"Computed Fields","text":"<pre><code>from pydantic import computed_field\n\nclass UserReadWithComputed(UserRead):\n    created_at: datetime  # Would need to be added to actual UserRead\n\n    @computed_field\n    @property\n    def age_days(self) -&gt; int:\n        return (datetime.utcnow() - self.created_at).days\n\n    @computed_field\n    @property  \n    def display_name(self) -&gt; str:\n        return f\"@{self.username}\"\n</code></pre> <p>Purpose: Add computed values to API responses without storing them in the database.</p>"},{"location":"user-guide/database/schemas/#conditional-validation","title":"Conditional Validation","text":"<pre><code>class PostCreate(BaseModel):\n    title: str\n    content: str\n    category: Optional[str] = None\n    is_premium: bool = False\n\n    @model_validator(mode='after')\n    def validate_premium_content(self):\n        if self.is_premium and not self.category:\n            raise ValueError('Premium posts must have a category')\n        return self\n</code></pre>"},{"location":"user-guide/database/schemas/#schema-configuration","title":"Schema Configuration","text":""},{"location":"user-guide/database/schemas/#model-config-options","title":"Model Config Options","text":"<pre><code>class UserRead(BaseModel):\n    model_config = ConfigDict(\n        from_attributes=True,    # Allow creation from SQLAlchemy models\n        extra=\"forbid\",          # Reject extra fields\n        str_strip_whitespace=True,  # Strip whitespace from strings\n        validate_assignment=True,   # Validate on field assignment\n        populate_by_name=True,      # Allow field names and aliases\n    )\n</code></pre>"},{"location":"user-guide/database/schemas/#field-aliases","title":"Field Aliases","text":"<pre><code>class UserResponse(BaseModel):\n    user_id: Annotated[\n        int, \n        Field(alias=\"id\")\n    ]\n    username: str\n    email_address: Annotated[\n        str, \n        Field(alias=\"email\")\n    ]\n\n    model_config = ConfigDict(populate_by_name=True)\n</code></pre> <p>Usage: API can accept both <code>id</code> and <code>user_id</code>, <code>email</code> and <code>email_address</code>.</p>"},{"location":"user-guide/database/schemas/#response-schema-patterns","title":"Response Schema Patterns","text":""},{"location":"user-guide/database/schemas/#multi-record-responses","title":"Multi-Record Responses","text":"<p>FastCRUD's <code>get_multi</code> method returns a <code>GetMultiResponse</code>:</p> <pre><code># Using get_multi directly\nusers = await crud_users.get_multi(\n    db=db,\n    offset=0,\n    limit=10,\n    schema_to_select=UserRead,\n    return_as_model=True,\n    return_total_count=True\n)\n# Returns GetMultiResponse structure:\n# {\n#   \"data\": [UserRead, ...],\n#   \"total_count\": 150\n# }\n</code></pre>"},{"location":"user-guide/database/schemas/#paginated-responses","title":"Paginated Responses","text":"<p>For pagination with page numbers, use <code>PaginatedListResponse</code>:</p> <pre><code>from fastcrud.paginated import PaginatedListResponse\n\n# In API endpoint - ONLY for paginated list responses\n@router.get(\"/users/\", response_model=PaginatedListResponse[UserRead])\nasync def get_users(page: int = 1, items_per_page: int = 10):\n    # Returns paginated structure with additional pagination fields:\n    # {\n    #   \"data\": [UserRead, ...],\n    #   \"total_count\": 150,\n    #   \"has_more\": true,\n    #   \"page\": 1, \n    #   \"items_per_page\": 10\n    # }\n\n# Single user endpoints return UserRead directly\n@router.get(\"/users/{user_id}\", response_model=UserRead)\nasync def get_user(user_id: int):\n    # Returns single UserRead object:\n    # {\n    #   \"id\": 1,\n    #   \"name\": \"User Userson\", \n    #   \"username\": \"userson\",\n    #   \"email\": \"user.userson@example.com\",\n    #   \"profile_image_url\": \"https://...\",\n    #   \"tier_id\": null\n    # }\n</code></pre>"},{"location":"user-guide/database/schemas/#error-response-schemas","title":"Error Response Schemas","text":"<pre><code>class ErrorResponse(BaseModel):\n    detail: str\n    error_code: Optional[str] = None\n\nclass ValidationErrorResponse(BaseModel):\n    detail: str\n    errors: list[dict]  # Pydantic validation errors\n</code></pre>"},{"location":"user-guide/database/schemas/#success-response-wrapper","title":"Success Response Wrapper","text":"<pre><code>from typing import Generic, TypeVar\n\nT = TypeVar('T')\n\nclass SuccessResponse(BaseModel, Generic[T]):\n    success: bool = True\n    data: T\n    message: Optional[str] = None\n\n# Usage in endpoint\n@router.post(\"/users/\", response_model=SuccessResponse[UserRead])\nasync def create_user(user_data: UserCreate):\n    user = await crud_users.create(db=db, object=user_data)\n    return SuccessResponse(data=user, message=\"User created successfully\")\n</code></pre>"},{"location":"user-guide/database/schemas/#creating-new-schemas","title":"Creating New Schemas","text":""},{"location":"user-guide/database/schemas/#step-by-step-process","title":"Step-by-Step Process","text":"<ol> <li>Create schema file in <code>src/app/schemas/your_model.py</code></li> <li>Define base schema with common fields</li> <li>Create operation-specific schemas (Create, Read, Update, Delete)</li> <li>Add validation rules as needed</li> <li>Import in init.py for easy access</li> </ol>"},{"location":"user-guide/database/schemas/#example-category-schemas","title":"Example: Category Schemas","text":"<pre><code># src/app/schemas/category.py\nfrom datetime import datetime\nfrom typing import Annotated\nfrom pydantic import BaseModel, Field, ConfigDict\n\nclass CategoryBase(BaseModel):\n    name: Annotated[\n        str, \n        Field(\n            min_length=1, \n            max_length=50\n        )\n    ]\n    description: Annotated[\n        str | None, \n        Field(\n            max_length=255,\n            default=None\n        )\n    ]\n\nclass CategoryCreate(CategoryBase):\n    pass\n\nclass CategoryRead(CategoryBase):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    created_at: datetime\n\nclass CategoryUpdate(BaseModel):\n    name: Annotated[\n        str | None, \n        Field(\n            min_length=1, \n            max_length=50,\n            default=None\n        )\n    ]\n    description: Annotated[\n        str | None, \n        Field(\n            max_length=255,\n            default=None\n        )\n    ]\n\nclass CategoryWithPosts(CategoryRead):\n    posts: list[PostRead] = []  # Include related posts\n</code></pre>"},{"location":"user-guide/database/schemas/#import-in-initpy","title":"Import in init.py","text":"<pre><code># src/app/schemas/__init__.py\nfrom .user import UserCreate, UserRead, UserUpdate\nfrom .post import PostCreate, PostRead, PostUpdate\nfrom .category import CategoryCreate, CategoryRead, CategoryUpdate\n</code></pre>"},{"location":"user-guide/database/schemas/#schema-testing","title":"Schema Testing","text":""},{"location":"user-guide/database/schemas/#validation-testing","title":"Validation Testing","text":"<pre><code># tests/test_schemas.py\nimport pytest\nfrom pydantic import ValidationError\nfrom app.schemas.user import UserCreate\n\ndef test_user_create_valid():\n    user_data = {\n        \"name\": \"Test User\",\n        \"username\": \"testuser\",\n        \"email\": \"test@example.com\",\n        \"password\": \"Str1ngst!\"\n    }\n    user = UserCreate(**user_data)\n    assert user.username == \"testuser\"\n    assert user.name == \"Test User\"\n\ndef test_user_create_invalid_email():\n    with pytest.raises(ValidationError) as exc_info:\n        UserCreate(\n            name=\"Test User\",\n            username=\"test\",\n            email=\"invalid-email\",\n            password=\"Str1ngst!\"\n        )\n\n    errors = exc_info.value.errors()\n    assert any(error['type'] == 'value_error' for error in errors)\n\ndef test_password_validation():\n    with pytest.raises(ValidationError) as exc_info:\n        UserCreate(\n            name=\"Test User\",\n            username=\"test\", \n            email=\"test@example.com\",\n            password=\"123\"  # Doesn't match pattern\n        )\n</code></pre>"},{"location":"user-guide/database/schemas/#serialization-testing","title":"Serialization Testing","text":"<pre><code>from app.models.user import User\nfrom app.schemas.user import UserRead\n\ndef test_user_read_from_model():\n    # Create model instance\n    user_model = User(\n        id=1,\n        name=\"Test User\",\n        username=\"testuser\",\n        email=\"test@example.com\",\n        profile_image_url=\"https://example.com/image.jpg\",\n        hashed_password=\"hashed123\",\n        is_superuser=False,\n        tier_id=None,\n        created_at=datetime.utcnow()\n    )\n\n    # Convert to schema\n    user_schema = UserRead.model_validate(user_model)\n    assert user_schema.username == \"testuser\"\n    assert user_schema.id == 1\n    assert user_schema.name == \"Test User\"\n    # hashed_password not included in UserRead\n</code></pre>"},{"location":"user-guide/database/schemas/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"user-guide/database/schemas/#model-vs-schema-field-names","title":"Model vs Schema Field Names","text":"<pre><code># DON'T - Exposing sensitive fields\nclass UserRead(BaseModel):\n    hashed_password: str  # Never expose password hashes\n\n# DO - Only expose safe fields  \nclass UserRead(BaseModel):\n    id: int\n    name: str\n    username: str\n    email: str\n    profile_image_url: str\n    tier_id: int | None\n</code></pre>"},{"location":"user-guide/database/schemas/#validation-performance","title":"Validation Performance","text":"<pre><code># DON'T - Complex validation in every request\n@field_validator('email')\n@classmethod  \ndef validate_email_unique(cls, v):\n    # Database query in validator - slow!\n    if crud_users.exists(email=v):\n        raise ValueError('Email already exists')\n\n# DO - Handle uniqueness in business logic\n# Let database unique constraints handle this\n</code></pre>"},{"location":"user-guide/database/schemas/#next-steps","title":"Next Steps","text":"<p>Now that you understand schema implementation:</p> <ol> <li>CRUD Operations - Learn how schemas integrate with database operations</li> <li>Migrations - Manage database schema changes</li> <li>API Endpoints - Use schemas in FastAPI endpoints</li> </ol> <p>The next section covers CRUD operations and how they use these schemas for data validation and transformation.</p>"},{"location":"user-guide/rate-limiting/","title":"Rate Limiting","text":"<p>The boilerplate includes a sophisticated rate limiting system built on Redis that protects your API from abuse while supporting user tiers with different access levels. This system provides flexible, scalable rate limiting for production applications.</p>"},{"location":"user-guide/rate-limiting/#overview","title":"Overview","text":"<p>Rate limiting controls how many requests users can make within a specific time period. The boilerplate implements:</p> <ul> <li>Redis-Based Storage: Fast, distributed rate limiting using Redis</li> <li>User Tier System: Different limits for different user types  </li> <li>Path-Specific Limits: Granular control per API endpoint</li> <li>Fallback Protection: Default limits for unauthenticated users</li> </ul>"},{"location":"user-guide/rate-limiting/#quick-example","title":"Quick Example","text":"<pre><code>from fastapi import Depends\nfrom app.api.dependencies import rate_limiter_dependency\n\n@router.post(\"/api/v1/posts\", dependencies=[Depends(rate_limiter_dependency)])\nasync def create_post(post_data: PostCreate):\n    # This endpoint is automatically rate limited based on:\n    # - User's tier (basic, premium, enterprise)  \n    # - Specific limits for the /posts endpoint\n    # - Default limits for unauthenticated users\n    return await crud_posts.create(db=db, object=post_data)\n</code></pre>"},{"location":"user-guide/rate-limiting/#architecture","title":"Architecture","text":""},{"location":"user-guide/rate-limiting/#rate-limiting-components","title":"Rate Limiting Components","text":"<p>Rate Limiter Class: Singleton Redis client for checking limits User Tiers: Database-stored user subscription levels Rate Limit Rules: Path-specific limits per tier Dependency Injection: Automatic enforcement via FastAPI dependencies</p>"},{"location":"user-guide/rate-limiting/#how-it-works","title":"How It Works","text":"<ol> <li>Request Arrives: User makes API request to protected endpoint</li> <li>User Identification: System identifies user and their tier</li> <li>Limit Lookup: Finds applicable rate limit for user tier + endpoint</li> <li>Redis Check: Increments counter in Redis sliding window</li> <li>Allow/Deny: Request proceeds or returns 429 Too Many Requests</li> </ol>"},{"location":"user-guide/rate-limiting/#user-tier-system","title":"User Tier System","text":""},{"location":"user-guide/rate-limiting/#default-tiers","title":"Default Tiers","text":"<p>The system supports flexible user tiers with different access levels:</p> <pre><code># Example tier configuration\ntiers = {\n    \"free\": {\n        \"requests_per_minute\": 10,\n        \"requests_per_hour\": 100,\n        \"special_endpoints\": {\n            \"/api/v1/ai/generate\": {\"limit\": 2, \"period\": 3600},  # 2 per hour\n            \"/api/v1/exports\": {\"limit\": 1, \"period\": 86400},     # 1 per day\n        }\n    },\n    \"premium\": {\n        \"requests_per_minute\": 60,\n        \"requests_per_hour\": 1000,\n        \"special_endpoints\": {\n            \"/api/v1/ai/generate\": {\"limit\": 50, \"period\": 3600},\n            \"/api/v1/exports\": {\"limit\": 10, \"period\": 86400},\n        }\n    },\n    \"enterprise\": {\n        \"requests_per_minute\": 300,\n        \"requests_per_hour\": 10000,\n        \"special_endpoints\": {\n            \"/api/v1/ai/generate\": {\"limit\": 500, \"period\": 3600},\n            \"/api/v1/exports\": {\"limit\": 100, \"period\": 86400},\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/rate-limiting/#rate-limit-database-structure","title":"Rate Limit Database Structure","text":"<pre><code># Rate limits are stored per tier and path\nclass RateLimit:\n    id: int\n    tier_id: int           # Links to user tier\n    name: str             # Descriptive name\n    path: str             # API path (sanitized)\n    limit: int            # Number of requests allowed\n    period: int           # Time period in seconds\n</code></pre>"},{"location":"user-guide/rate-limiting/#implementation-details","title":"Implementation Details","text":""},{"location":"user-guide/rate-limiting/#automatic-rate-limiting","title":"Automatic Rate Limiting","text":"<p>The system automatically applies rate limiting through dependency injection:</p> <pre><code>@router.post(\"/protected-endpoint\", dependencies=[Depends(rate_limiter_dependency)])\nasync def protected_endpoint():\n    \"\"\"This endpoint is automatically rate limited.\"\"\"\n    pass\n\n# The dependency:\n# 1. Identifies the user and their tier\n# 2. Looks up rate limits for this path\n# 3. Checks Redis counter\n# 4. Allows or blocks the request\n</code></pre>"},{"location":"user-guide/rate-limiting/#redis-based-counting","title":"Redis-Based Counting","text":"<p>The rate limiter uses Redis for distributed, high-performance counting:</p> <pre><code># Sliding window implementation\nasync def is_rate_limited(self, user_id: int, path: str, limit: int, period: int) -&gt; bool:\n    current_timestamp = int(datetime.now(UTC).timestamp())\n    window_start = current_timestamp - (current_timestamp % period)\n\n    # Create unique key for this user/path/window\n    key = f\"ratelimit:{user_id}:{sanitized_path}:{window_start}\"\n\n    # Increment counter\n    current_count = await redis_client.incr(key)\n\n    # Set expiration on first increment\n    if current_count == 1:\n        await redis_client.expire(key, period)\n\n    # Check if limit exceeded\n    return current_count &gt; limit\n</code></pre>"},{"location":"user-guide/rate-limiting/#path-sanitization","title":"Path Sanitization","text":"<p>API paths are sanitized for consistent Redis key generation:</p> <pre><code>def sanitize_path(path: str) -&gt; str:\n    return path.strip(\"/\").replace(\"/\", \"_\")\n\n# Examples:\n# \"/api/v1/users\" \u2192 \"api_v1_users\"\n# \"/posts/{id}\" \u2192 \"posts_{id}\"\n</code></pre>"},{"location":"user-guide/rate-limiting/#configuration","title":"Configuration","text":""},{"location":"user-guide/rate-limiting/#environment-variables","title":"Environment Variables","text":"<pre><code># Rate Limiting Settings\nDEFAULT_RATE_LIMIT_LIMIT=100      # Default requests per period\nDEFAULT_RATE_LIMIT_PERIOD=3600    # Default period (1 hour)\n\n# Redis Rate Limiter Settings  \nREDIS_RATE_LIMITER_HOST=localhost\nREDIS_RATE_LIMITER_PORT=6379\nREDIS_RATE_LIMITER_DB=2           # Separate from cache/queue\n</code></pre>"},{"location":"user-guide/rate-limiting/#creating-user-tiers","title":"Creating User Tiers","text":"<pre><code># Create tiers via API (superuser only)\nPOST /api/v1/tiers\n{\n    \"name\": \"premium\",\n    \"description\": \"Premium subscription with higher limits\"\n}\n\n# Assign tier to user\nPUT /api/v1/users/{user_id}/tier\n{\n    \"tier_id\": 2\n}\n</code></pre>"},{"location":"user-guide/rate-limiting/#setting-rate-limits","title":"Setting Rate Limits","text":"<pre><code># Create rate limits per tier and endpoint\nPOST /api/v1/tier/premium/rate_limit\n{\n    \"name\": \"premium_posts_limit\",\n    \"path\": \"/api/v1/posts\",\n    \"limit\": 100,        # 100 requests\n    \"period\": 3600       # per hour\n}\n\n# Different limits for different endpoints\nPOST /api/v1/tier/free/rate_limit  \n{\n    \"name\": \"free_ai_limit\",\n    \"path\": \"/api/v1/ai/generate\",\n    \"limit\": 5,          # 5 requests  \n    \"period\": 86400      # per day\n}\n</code></pre>"},{"location":"user-guide/rate-limiting/#usage-patterns","title":"Usage Patterns","text":""},{"location":"user-guide/rate-limiting/#basic-protection","title":"Basic Protection","text":"<pre><code># Protect all endpoints in a router\nrouter = APIRouter(dependencies=[Depends(rate_limiter_dependency)])\n\n@router.get(\"/users\")\nasync def get_users():\n    \"\"\"Rate limited based on user tier.\"\"\"\n    pass\n\n@router.post(\"/posts\")  \nasync def create_post():\n    \"\"\"Rate limited based on user tier.\"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/rate-limiting/#selective-protection","title":"Selective Protection","text":"<pre><code># Protect only specific endpoints\n@router.get(\"/public-data\")\nasync def get_public_data():\n    \"\"\"No rate limiting - public endpoint.\"\"\"\n    pass\n\n@router.post(\"/premium-feature\", dependencies=[Depends(rate_limiter_dependency)])\nasync def premium_feature():\n    \"\"\"Rate limited - premium feature.\"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/rate-limiting/#custom-error-handling","title":"Custom Error Handling","text":"<pre><code>from app.core.exceptions.http_exceptions import RateLimitException\n\n@app.exception_handler(RateLimitException)\nasync def rate_limit_handler(request: Request, exc: RateLimitException):\n    \"\"\"Custom rate limit error response.\"\"\"\n    return JSONResponse(\n        status_code=429,\n        content={\n            \"error\": \"Rate limit exceeded\",\n            \"message\": \"Too many requests. Please try again later.\",\n            \"retry_after\": 60  # Suggest retry time\n        },\n        headers={\"Retry-After\": \"60\"}\n    )\n</code></pre>"},{"location":"user-guide/rate-limiting/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"user-guide/rate-limiting/#rate-limit-metrics","title":"Rate Limit Metrics","text":"<pre><code>@router.get(\"/admin/rate-limit-stats\")\nasync def get_rate_limit_stats():\n    \"\"\"Monitor rate limiting effectiveness.\"\"\"\n\n    # Get Redis statistics\n    redis_info = await rate_limiter.client.info()\n\n    # Count current rate limit keys\n    pattern = \"ratelimit:*\"\n    keys = await rate_limiter.client.keys(pattern)\n\n    # Analyze by endpoint\n    endpoint_stats = {}\n    for key in keys:\n        parts = key.split(\":\")\n        if len(parts) &gt;= 3:\n            endpoint = parts[2]\n            endpoint_stats[endpoint] = endpoint_stats.get(endpoint, 0) + 1\n\n    return {\n        \"total_active_limits\": len(keys),\n        \"redis_memory_usage\": redis_info.get(\"used_memory_human\"),\n        \"endpoint_stats\": endpoint_stats\n    }\n</code></pre>"},{"location":"user-guide/rate-limiting/#user-analytics","title":"User Analytics","text":"<pre><code>async def analyze_user_usage(user_id: int, days: int = 7):\n    \"\"\"Analyze user's API usage patterns.\"\"\"\n\n    # This would require additional logging/analytics\n    # implementation to track request patterns\n\n    return {\n        \"user_id\": user_id,\n        \"tier\": \"premium\",\n        \"requests_last_7_days\": 2540,\n        \"average_requests_per_day\": 363,\n        \"top_endpoints\": [\n            {\"path\": \"/api/v1/posts\", \"count\": 1200},\n            {\"path\": \"/api/v1/users\", \"count\": 800},\n            {\"path\": \"/api/v1/ai/generate\", \"count\": 540}\n        ],\n        \"rate_limit_hits\": 12,  # Times user hit rate limits\n        \"suggested_tier\": \"enterprise\"  # Based on usage patterns\n    }\n</code></pre>"},{"location":"user-guide/rate-limiting/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/rate-limiting/#rate-limit-design","title":"Rate Limit Design","text":"<pre><code># Design limits based on resource cost\nexpensive_endpoints = {\n    \"/api/v1/ai/generate\": {\"limit\": 10, \"period\": 3600},    # AI is expensive\n    \"/api/v1/reports/export\": {\"limit\": 3, \"period\": 86400}, # Export is heavy\n    \"/api/v1/bulk/import\": {\"limit\": 1, \"period\": 3600},     # Import is intensive\n}\n\n# More generous limits for lightweight endpoints  \nlightweight_endpoints = {\n    \"/api/v1/users/me\": {\"limit\": 1000, \"period\": 3600},     # Profile access\n    \"/api/v1/posts\": {\"limit\": 300, \"period\": 3600},         # Content browsing\n    \"/api/v1/search\": {\"limit\": 500, \"period\": 3600},        # Search queries\n}\n</code></pre>"},{"location":"user-guide/rate-limiting/#production-considerations","title":"Production Considerations","text":"<pre><code># Use separate Redis database for rate limiting\nREDIS_RATE_LIMITER_DB=2  # Isolate from cache and queues\n\n# Set appropriate Redis memory policies\n# maxmemory-policy volatile-lru  # Remove expired rate limit keys first\n\n# Monitor Redis memory usage\n# Rate limit keys can accumulate quickly under high load\n\n# Consider rate limit key cleanup\nasync def cleanup_expired_rate_limits():\n    \"\"\"Clean up expired rate limit keys.\"\"\"\n    pattern = \"ratelimit:*\"\n    keys = await redis_client.keys(pattern)\n\n    for key in keys:\n        ttl = await redis_client.ttl(key)\n        if ttl == -2:  # Key expired but not cleaned up\n            await redis_client.delete(key)\n</code></pre>"},{"location":"user-guide/rate-limiting/#security-considerations","title":"Security Considerations","text":"<pre><code># Rate limit by IP for unauthenticated users\nif not user:\n    user_id = request.client.host if request.client else \"unknown\"\n    limit, period = DEFAULT_LIMIT, DEFAULT_PERIOD\n\n# Prevent rate limit enumeration attacks\n# Don't expose exact remaining requests in error messages\n\n# Use progressive delays for repeated violations\n# Consider temporary bans for severe abuse\n\n# Log rate limit violations for security monitoring\nif is_limited:\n    logger.warning(\n        f\"Rate limit exceeded\",\n        extra={\n            \"user_id\": user_id,\n            \"path\": path,\n            \"ip\": request.client.host if request.client else \"unknown\",\n            \"user_agent\": request.headers.get(\"user-agent\")\n        }\n    )\n</code></pre>"},{"location":"user-guide/rate-limiting/#common-use-cases","title":"Common Use Cases","text":""},{"location":"user-guide/rate-limiting/#api-monetization","title":"API Monetization","text":"<pre><code># Different tiers for different pricing levels\ntiers = {\n    \"free\": {\"daily_requests\": 1000, \"cost\": 0},\n    \"starter\": {\"daily_requests\": 10000, \"cost\": 29},\n    \"professional\": {\"daily_requests\": 100000, \"cost\": 99},\n    \"enterprise\": {\"daily_requests\": 1000000, \"cost\": 499}\n}\n</code></pre>"},{"location":"user-guide/rate-limiting/#resource-protection","title":"Resource Protection","text":"<pre><code># Protect expensive operations\n@router.post(\"/ai/generate-image\", dependencies=[Depends(rate_limiter_dependency)])\nasync def generate_image():\n    \"\"\"Expensive AI operation - heavily rate limited.\"\"\"\n    pass\n\n@router.get(\"/data/export\", dependencies=[Depends(rate_limiter_dependency)])  \nasync def export_data():\n    \"\"\"Database-intensive operation - rate limited.\"\"\"\n    pass\n</code></pre>"},{"location":"user-guide/rate-limiting/#abuse-prevention","title":"Abuse Prevention","text":"<pre><code># Strict limits on user-generated content\n@router.post(\"/posts\", dependencies=[Depends(rate_limiter_dependency)])\nasync def create_post():\n    \"\"\"Prevent spam posting.\"\"\"\n    pass\n\n@router.post(\"/comments\", dependencies=[Depends(rate_limiter_dependency)])\nasync def create_comment():\n    \"\"\"Prevent comment spam.\"\"\" \n    pass\n</code></pre> <p>This comprehensive rate limiting system provides robust protection against API abuse while supporting flexible business models through user tiers and granular endpoint controls. </p>"}]}